Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     constant -> CTEI
Rule 2     constant -> CTEF
Rule 3     constant -> CTESTRING
Rule 4     constant -> CTEBOOL
Rule 5     constant -> ID
Rule 6     constant -> functioncall
Rule 7     functioncall -> ID LPAREN expresion RPAREN
Rule 8     functioncall -> ID LPAREN CTEI RPAREN
Rule 9     functioncall -> ID LPAREN CTEF RPAREN
Rule 10    data -> DATA LCURLY asignmany RCURLY
Rule 11    asignmany -> asign SEMIC asignlist
Rule 12    asignmany -> asign
Rule 13    asignlist -> empty
Rule 14    asignlist -> asignmany
Rule 15    optimize -> MIN EQUALS restrictions
Rule 16    optimize -> MAX EQUALS restrictions
Rule 17    restrictions -> WHERE restrictions2
Rule 18    restrictions2 -> expresion
Rule 19    restrictions2 -> sum SEMIC forlist
Rule 20    for -> FOR ID IN DOT ID LBRACKET statement RBRACKET
Rule 21    forlist -> for SEMIC lfor
Rule 22    lfor -> empty
Rule 23    lfor -> forlist
Rule 24    sum -> SUM LPAREN ID POINTS expresion RPAREN
Rule 25    factor -> PLUS constant
Rule 26    factor -> MINUS constant
Rule 27    factor -> constant
Rule 28    factor -> LPAREN expresion RPAREN
Rule 29    term -> factor
Rule 30    term -> factor STAR term
Rule 31    term -> factor SLASH term
Rule 32    condition -> IF LPAREN expresion RPAREN block SEMIC
Rule 33    condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC
Rule 34    expresiones -> expresion COMMA expresiones
Rule 35    expresiones -> expresion
Rule 36    expresion -> exp
Rule 37    expresion -> exp LESSTHAN exp
Rule 38    expresion -> exp GREATERTHAN exp
Rule 39    expresion -> exp BETWEEN exp
Rule 40    exp -> term
Rule 41    exp -> term PLUS exp
Rule 42    exp -> term MINUS exp
Rule 43    write -> PRINT LPAREN write2 RPAREN SEMIC
Rule 44    write2 -> expresion
Rule 45    write2 -> CTESTRING
Rule 46    write2 -> expresion DOT write2
Rule 47    write2 -> CTESTRING DOT write2
Rule 48    asign -> ID EQUALS expresiones SEMIC
Rule 49    statement -> asign
Rule 50    statement -> condition
Rule 51    statement -> write
Rule 52    statement -> optimize
Rule 53    statement -> loop
Rule 54    statement -> return
Rule 55    loop -> for
Rule 56    return -> RETURN asign
Rule 57    function -> FUNC ID LPAREN manyargs RPAREN LCURLY varsdata block2 RCURLY
Rule 58    manyargs -> empty
Rule 59    manyargs -> tipo ID liargs
Rule 60    liargs -> empty
Rule 61    liargs -> COMMA manyargs
Rule 62    block -> block2
Rule 63    block -> LCURLY RCURLY
Rule 64    block2 -> statement block2
Rule 65    block2 -> statement
Rule 66    block2 -> empty
Rule 67    tipo -> TINT
Rule 68    tipo -> TFLOAT
Rule 69    tipo -> TBOOL
Rule 70    vars -> VARS LCURLY listofvars RCURLY
Rule 71    matrix -> LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET
Rule 72    array -> LBRACKET CTEI RBRACKET
Rule 73    declaracion -> tipo array
Rule 74    declaracion -> tipo matrix
Rule 75    declaracion -> tipo
Rule 76    lid -> COMMA listofids
Rule 77    lid -> empty
Rule 78    listofids -> ID lid
Rule 79    lvars -> listofvars
Rule 80    lvars -> empty
Rule 81    listofvars -> declaracion POINTS listofids SEMIC lvars
Rule 82    varsdata -> vars data
Rule 83    varsdata -> empty
Rule 84    varsdata -> vars
Rule 85    declarefunc -> function
Rule 86    declarefunc -> empty
Rule 87    declarevars -> vars
Rule 88    declarevars -> empty
Rule 89    program -> declarevars declarefunc MODEL LCURLY varsdata block2 RCURLY
Rule 90    empty -> <empty>

Terminals, with rules where they appear

BETWEEN              : 39
COMMA                : 34 61 76
CTEBOOL              : 4
CTEF                 : 2 9
CTEI                 : 1 8 71 71 72
CTESTRING            : 3 45 47
DATA                 : 10
DOT                  : 20 46 47
ELSE                 : 33
EQUALS               : 15 16 48
FOR                  : 20
FUNC                 : 57
GREATERTHAN          : 38
ID                   : 5 7 8 9 20 20 24 48 57 59 78
IF                   : 32 33
IN                   : 20
LBRACKET             : 20 71 71 72
LCURLY               : 10 57 63 70 89
LESSTHAN             : 37
LPAREN               : 7 8 9 24 28 32 33 43 57
MAX                  : 16
MIN                  : 15
MINUS                : 26 42
MODEL                : 89
PLUS                 : 25 41
POINTS               : 24 81
PRINT                : 43
RBRACKET             : 20 71 71 72
RCURLY               : 10 57 63 70 89
RETURN               : 56
RPAREN               : 7 8 9 24 28 32 33 43 57
SEMIC                : 11 19 21 32 33 43 48 81
SLASH                : 31
STAR                 : 30
SUM                  : 24
TBOOL                : 69
TFLOAT               : 68
TINT                 : 67
VARS                 : 70
WHERE                : 17
error                : 

Nonterminals, with rules where they appear

array                : 73
asign                : 11 12 49 56
asignlist            : 11
asignmany            : 10 14
block                : 32 33 33
block2               : 57 62 64 89
condition            : 50
constant             : 25 26 27
data                 : 82
declaracion          : 81
declarefunc          : 89
declarevars          : 89
empty                : 13 22 58 60 66 77 80 83 86 88
exp                  : 36 37 37 38 38 39 39 41 42
expresion            : 7 18 24 28 32 33 34 35 44 46
expresiones          : 34 48
factor               : 29 30 31
for                  : 21 55
forlist              : 19 23
function             : 85
functioncall         : 6
lfor                 : 21
liargs               : 59
lid                  : 78
listofids            : 76 81
listofvars           : 70 79
loop                 : 53
lvars                : 81
manyargs             : 57 61
matrix               : 74
optimize             : 52
program              : 0
restrictions         : 15 16
restrictions2        : 17
return               : 54
statement            : 20 64 65
sum                  : 19
term                 : 30 31 40 41 42
tipo                 : 59 73 74 75
vars                 : 82 84 87
varsdata             : 57 89
write                : 51
write2               : 43 46 47

Parsing method: LALR

state 0

    (0) S' -> . program
    (89) program -> . declarevars declarefunc MODEL LCURLY varsdata block2 RCURLY
    (87) declarevars -> . vars
    (88) declarevars -> . empty
    (70) vars -> . VARS LCURLY listofvars RCURLY
    (90) empty -> .

    VARS            shift and go to state 4
    FUNC            reduce using rule 90 (empty -> .)
    MODEL           reduce using rule 90 (empty -> .)

    program                        shift and go to state 1
    declarevars                    shift and go to state 2
    vars                           shift and go to state 3
    empty                          shift and go to state 5

state 1

    (0) S' -> program .



state 2

    (89) program -> declarevars . declarefunc MODEL LCURLY varsdata block2 RCURLY
    (85) declarefunc -> . function
    (86) declarefunc -> . empty
    (57) function -> . FUNC ID LPAREN manyargs RPAREN LCURLY varsdata block2 RCURLY
    (90) empty -> .

    FUNC            shift and go to state 8
    MODEL           reduce using rule 90 (empty -> .)

    function                       shift and go to state 6
    declarefunc                    shift and go to state 7
    empty                          shift and go to state 9

state 3

    (87) declarevars -> vars .

    FUNC            reduce using rule 87 (declarevars -> vars .)
    MODEL           reduce using rule 87 (declarevars -> vars .)


state 4

    (70) vars -> VARS . LCURLY listofvars RCURLY

    LCURLY          shift and go to state 10


state 5

    (88) declarevars -> empty .

    FUNC            reduce using rule 88 (declarevars -> empty .)
    MODEL           reduce using rule 88 (declarevars -> empty .)


state 6

    (85) declarefunc -> function .

    MODEL           reduce using rule 85 (declarefunc -> function .)


state 7

    (89) program -> declarevars declarefunc . MODEL LCURLY varsdata block2 RCURLY

    MODEL           shift and go to state 11


state 8

    (57) function -> FUNC . ID LPAREN manyargs RPAREN LCURLY varsdata block2 RCURLY

    ID              shift and go to state 12


state 9

    (86) declarefunc -> empty .

    MODEL           reduce using rule 86 (declarefunc -> empty .)


state 10

    (70) vars -> VARS LCURLY . listofvars RCURLY
    (81) listofvars -> . declaracion POINTS listofids SEMIC lvars
    (73) declaracion -> . tipo array
    (74) declaracion -> . tipo matrix
    (75) declaracion -> . tipo
    (67) tipo -> . TINT
    (68) tipo -> . TFLOAT
    (69) tipo -> . TBOOL

    TINT            shift and go to state 13
    TFLOAT          shift and go to state 17
    TBOOL           shift and go to state 16

    tipo                           shift and go to state 14
    listofvars                     shift and go to state 15
    declaracion                    shift and go to state 18

state 11

    (89) program -> declarevars declarefunc MODEL . LCURLY varsdata block2 RCURLY

    LCURLY          shift and go to state 19


state 12

    (57) function -> FUNC ID . LPAREN manyargs RPAREN LCURLY varsdata block2 RCURLY

    LPAREN          shift and go to state 20


state 13

    (67) tipo -> TINT .

    ID              reduce using rule 67 (tipo -> TINT .)
    LBRACKET        reduce using rule 67 (tipo -> TINT .)
    POINTS          reduce using rule 67 (tipo -> TINT .)


state 14

    (73) declaracion -> tipo . array
    (74) declaracion -> tipo . matrix
    (75) declaracion -> tipo .
    (72) array -> . LBRACKET CTEI RBRACKET
    (71) matrix -> . LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET

    POINTS          reduce using rule 75 (declaracion -> tipo .)
    LBRACKET        shift and go to state 22

    array                          shift and go to state 23
    matrix                         shift and go to state 21

state 15

    (70) vars -> VARS LCURLY listofvars . RCURLY

    RCURLY          shift and go to state 24


state 16

    (69) tipo -> TBOOL .

    ID              reduce using rule 69 (tipo -> TBOOL .)
    LBRACKET        reduce using rule 69 (tipo -> TBOOL .)
    POINTS          reduce using rule 69 (tipo -> TBOOL .)


state 17

    (68) tipo -> TFLOAT .

    ID              reduce using rule 68 (tipo -> TFLOAT .)
    LBRACKET        reduce using rule 68 (tipo -> TFLOAT .)
    POINTS          reduce using rule 68 (tipo -> TFLOAT .)


state 18

    (81) listofvars -> declaracion . POINTS listofids SEMIC lvars

    POINTS          shift and go to state 25


state 19

    (89) program -> declarevars declarefunc MODEL LCURLY . varsdata block2 RCURLY
    (82) varsdata -> . vars data
    (83) varsdata -> . empty
    (84) varsdata -> . vars
    (70) vars -> . VARS LCURLY listofvars RCURLY
    (90) empty -> .

    VARS            shift and go to state 4
    ID              reduce using rule 90 (empty -> .)
    IF              reduce using rule 90 (empty -> .)
    PRINT           reduce using rule 90 (empty -> .)
    MIN             reduce using rule 90 (empty -> .)
    MAX             reduce using rule 90 (empty -> .)
    RETURN          reduce using rule 90 (empty -> .)
    FOR             reduce using rule 90 (empty -> .)
    RCURLY          reduce using rule 90 (empty -> .)

    vars                           shift and go to state 26
    varsdata                       shift and go to state 27
    empty                          shift and go to state 28

state 20

    (57) function -> FUNC ID LPAREN . manyargs RPAREN LCURLY varsdata block2 RCURLY
    (58) manyargs -> . empty
    (59) manyargs -> . tipo ID liargs
    (90) empty -> .
    (67) tipo -> . TINT
    (68) tipo -> . TFLOAT
    (69) tipo -> . TBOOL

    RPAREN          reduce using rule 90 (empty -> .)
    TINT            shift and go to state 13
    TFLOAT          shift and go to state 17
    TBOOL           shift and go to state 16

    tipo                           shift and go to state 29
    manyargs                       shift and go to state 30
    empty                          shift and go to state 31

state 21

    (74) declaracion -> tipo matrix .

    POINTS          reduce using rule 74 (declaracion -> tipo matrix .)


state 22

    (72) array -> LBRACKET . CTEI RBRACKET
    (71) matrix -> LBRACKET . CTEI RBRACKET LBRACKET CTEI RBRACKET

    CTEI            shift and go to state 32


state 23

    (73) declaracion -> tipo array .

    POINTS          reduce using rule 73 (declaracion -> tipo array .)


state 24

    (70) vars -> VARS LCURLY listofvars RCURLY .

    DATA            reduce using rule 70 (vars -> VARS LCURLY listofvars RCURLY .)
    ID              reduce using rule 70 (vars -> VARS LCURLY listofvars RCURLY .)
    IF              reduce using rule 70 (vars -> VARS LCURLY listofvars RCURLY .)
    PRINT           reduce using rule 70 (vars -> VARS LCURLY listofvars RCURLY .)
    MIN             reduce using rule 70 (vars -> VARS LCURLY listofvars RCURLY .)
    MAX             reduce using rule 70 (vars -> VARS LCURLY listofvars RCURLY .)
    RETURN          reduce using rule 70 (vars -> VARS LCURLY listofvars RCURLY .)
    FOR             reduce using rule 70 (vars -> VARS LCURLY listofvars RCURLY .)
    RCURLY          reduce using rule 70 (vars -> VARS LCURLY listofvars RCURLY .)
    FUNC            reduce using rule 70 (vars -> VARS LCURLY listofvars RCURLY .)
    MODEL           reduce using rule 70 (vars -> VARS LCURLY listofvars RCURLY .)


state 25

    (81) listofvars -> declaracion POINTS . listofids SEMIC lvars
    (78) listofids -> . ID lid

    ID              shift and go to state 33

    listofids                      shift and go to state 34

state 26

    (82) varsdata -> vars . data
    (84) varsdata -> vars .
    (10) data -> . DATA LCURLY asignmany RCURLY

    ID              reduce using rule 84 (varsdata -> vars .)
    IF              reduce using rule 84 (varsdata -> vars .)
    PRINT           reduce using rule 84 (varsdata -> vars .)
    MIN             reduce using rule 84 (varsdata -> vars .)
    MAX             reduce using rule 84 (varsdata -> vars .)
    RETURN          reduce using rule 84 (varsdata -> vars .)
    FOR             reduce using rule 84 (varsdata -> vars .)
    RCURLY          reduce using rule 84 (varsdata -> vars .)
    DATA            shift and go to state 36

    data                           shift and go to state 35

state 27

    (89) program -> declarevars declarefunc MODEL LCURLY varsdata . block2 RCURLY
    (64) block2 -> . statement block2
    (65) block2 -> . statement
    (66) block2 -> . empty
    (49) statement -> . asign
    (50) statement -> . condition
    (51) statement -> . write
    (52) statement -> . optimize
    (53) statement -> . loop
    (54) statement -> . return
    (90) empty -> .
    (48) asign -> . ID EQUALS expresiones SEMIC
    (32) condition -> . IF LPAREN expresion RPAREN block SEMIC
    (33) condition -> . IF LPAREN expresion RPAREN block ELSE block SEMIC
    (43) write -> . PRINT LPAREN write2 RPAREN SEMIC
    (15) optimize -> . MIN EQUALS restrictions
    (16) optimize -> . MAX EQUALS restrictions
    (55) loop -> . for
    (56) return -> . RETURN asign
    (20) for -> . FOR ID IN DOT ID LBRACKET statement RBRACKET

    RCURLY          reduce using rule 90 (empty -> .)
    ID              shift and go to state 48
    IF              shift and go to state 50
    PRINT           shift and go to state 40
    MIN             shift and go to state 39
    MAX             shift and go to state 51
    RETURN          shift and go to state 37
    FOR             shift and go to state 47

    return                         shift and go to state 46
    block2                         shift and go to state 38
    for                            shift and go to state 41
    asign                          shift and go to state 52
    write                          shift and go to state 43
    condition                      shift and go to state 49
    statement                      shift and go to state 44
    loop                           shift and go to state 53
    optimize                       shift and go to state 42
    empty                          shift and go to state 45

state 28

    (83) varsdata -> empty .

    ID              reduce using rule 83 (varsdata -> empty .)
    IF              reduce using rule 83 (varsdata -> empty .)
    PRINT           reduce using rule 83 (varsdata -> empty .)
    MIN             reduce using rule 83 (varsdata -> empty .)
    MAX             reduce using rule 83 (varsdata -> empty .)
    RETURN          reduce using rule 83 (varsdata -> empty .)
    FOR             reduce using rule 83 (varsdata -> empty .)
    RCURLY          reduce using rule 83 (varsdata -> empty .)


state 29

    (59) manyargs -> tipo . ID liargs

    ID              shift and go to state 54


state 30

    (57) function -> FUNC ID LPAREN manyargs . RPAREN LCURLY varsdata block2 RCURLY

    RPAREN          shift and go to state 55


state 31

    (58) manyargs -> empty .

    RPAREN          reduce using rule 58 (manyargs -> empty .)


state 32

    (72) array -> LBRACKET CTEI . RBRACKET
    (71) matrix -> LBRACKET CTEI . RBRACKET LBRACKET CTEI RBRACKET

    RBRACKET        shift and go to state 56


state 33

    (78) listofids -> ID . lid
    (76) lid -> . COMMA listofids
    (77) lid -> . empty
    (90) empty -> .

    COMMA           shift and go to state 59
    SEMIC           reduce using rule 90 (empty -> .)

    lid                            shift and go to state 57
    empty                          shift and go to state 58

state 34

    (81) listofvars -> declaracion POINTS listofids . SEMIC lvars

    SEMIC           shift and go to state 60


state 35

    (82) varsdata -> vars data .

    ID              reduce using rule 82 (varsdata -> vars data .)
    IF              reduce using rule 82 (varsdata -> vars data .)
    PRINT           reduce using rule 82 (varsdata -> vars data .)
    MIN             reduce using rule 82 (varsdata -> vars data .)
    MAX             reduce using rule 82 (varsdata -> vars data .)
    RETURN          reduce using rule 82 (varsdata -> vars data .)
    FOR             reduce using rule 82 (varsdata -> vars data .)
    RCURLY          reduce using rule 82 (varsdata -> vars data .)


state 36

    (10) data -> DATA . LCURLY asignmany RCURLY

    LCURLY          shift and go to state 61


state 37

    (56) return -> RETURN . asign
    (48) asign -> . ID EQUALS expresiones SEMIC

    ID              shift and go to state 48

    asign                          shift and go to state 62

state 38

    (89) program -> declarevars declarefunc MODEL LCURLY varsdata block2 . RCURLY

    RCURLY          shift and go to state 63


state 39

    (15) optimize -> MIN . EQUALS restrictions

    EQUALS          shift and go to state 64


state 40

    (43) write -> PRINT . LPAREN write2 RPAREN SEMIC

    LPAREN          shift and go to state 65


state 41

    (55) loop -> for .

    RBRACKET        reduce using rule 55 (loop -> for .)
    ID              reduce using rule 55 (loop -> for .)
    IF              reduce using rule 55 (loop -> for .)
    PRINT           reduce using rule 55 (loop -> for .)
    MIN             reduce using rule 55 (loop -> for .)
    MAX             reduce using rule 55 (loop -> for .)
    RETURN          reduce using rule 55 (loop -> for .)
    FOR             reduce using rule 55 (loop -> for .)
    RCURLY          reduce using rule 55 (loop -> for .)
    SEMIC           reduce using rule 55 (loop -> for .)
    ELSE            reduce using rule 55 (loop -> for .)


state 42

    (52) statement -> optimize .

    ID              reduce using rule 52 (statement -> optimize .)
    IF              reduce using rule 52 (statement -> optimize .)
    PRINT           reduce using rule 52 (statement -> optimize .)
    MIN             reduce using rule 52 (statement -> optimize .)
    MAX             reduce using rule 52 (statement -> optimize .)
    RETURN          reduce using rule 52 (statement -> optimize .)
    FOR             reduce using rule 52 (statement -> optimize .)
    RCURLY          reduce using rule 52 (statement -> optimize .)
    SEMIC           reduce using rule 52 (statement -> optimize .)
    ELSE            reduce using rule 52 (statement -> optimize .)
    RBRACKET        reduce using rule 52 (statement -> optimize .)


state 43

    (51) statement -> write .

    ID              reduce using rule 51 (statement -> write .)
    IF              reduce using rule 51 (statement -> write .)
    PRINT           reduce using rule 51 (statement -> write .)
    MIN             reduce using rule 51 (statement -> write .)
    MAX             reduce using rule 51 (statement -> write .)
    RETURN          reduce using rule 51 (statement -> write .)
    FOR             reduce using rule 51 (statement -> write .)
    RCURLY          reduce using rule 51 (statement -> write .)
    SEMIC           reduce using rule 51 (statement -> write .)
    ELSE            reduce using rule 51 (statement -> write .)
    RBRACKET        reduce using rule 51 (statement -> write .)


state 44

    (64) block2 -> statement . block2
    (65) block2 -> statement .
    (64) block2 -> . statement block2
    (65) block2 -> . statement
    (66) block2 -> . empty
    (49) statement -> . asign
    (50) statement -> . condition
    (51) statement -> . write
    (52) statement -> . optimize
    (53) statement -> . loop
    (54) statement -> . return
    (90) empty -> .
    (48) asign -> . ID EQUALS expresiones SEMIC
    (32) condition -> . IF LPAREN expresion RPAREN block SEMIC
    (33) condition -> . IF LPAREN expresion RPAREN block ELSE block SEMIC
    (43) write -> . PRINT LPAREN write2 RPAREN SEMIC
    (15) optimize -> . MIN EQUALS restrictions
    (16) optimize -> . MAX EQUALS restrictions
    (55) loop -> . for
    (56) return -> . RETURN asign
    (20) for -> . FOR ID IN DOT ID LBRACKET statement RBRACKET

  ! reduce/reduce conflict for RCURLY resolved using rule 65 (block2 -> statement .)
  ! reduce/reduce conflict for SEMIC resolved using rule 65 (block2 -> statement .)
  ! reduce/reduce conflict for ELSE resolved using rule 65 (block2 -> statement .)
    SEMIC           reduce using rule 65 (block2 -> statement .)
    ELSE            reduce using rule 65 (block2 -> statement .)
    RCURLY          reduce using rule 65 (block2 -> statement .)
    ID              shift and go to state 48
    IF              shift and go to state 50
    PRINT           shift and go to state 40
    MIN             shift and go to state 39
    MAX             shift and go to state 51
    RETURN          shift and go to state 37
    FOR             shift and go to state 47

  ! RCURLY          [ reduce using rule 90 (empty -> .) ]
  ! SEMIC           [ reduce using rule 90 (empty -> .) ]
  ! ELSE            [ reduce using rule 90 (empty -> .) ]

    return                         shift and go to state 46
    block2                         shift and go to state 66
    for                            shift and go to state 41
    asign                          shift and go to state 52
    write                          shift and go to state 43
    condition                      shift and go to state 49
    statement                      shift and go to state 44
    loop                           shift and go to state 53
    optimize                       shift and go to state 42
    empty                          shift and go to state 45

state 45

    (66) block2 -> empty .

    SEMIC           reduce using rule 66 (block2 -> empty .)
    ELSE            reduce using rule 66 (block2 -> empty .)
    RCURLY          reduce using rule 66 (block2 -> empty .)


state 46

    (54) statement -> return .

    ID              reduce using rule 54 (statement -> return .)
    IF              reduce using rule 54 (statement -> return .)
    PRINT           reduce using rule 54 (statement -> return .)
    MIN             reduce using rule 54 (statement -> return .)
    MAX             reduce using rule 54 (statement -> return .)
    RETURN          reduce using rule 54 (statement -> return .)
    FOR             reduce using rule 54 (statement -> return .)
    RCURLY          reduce using rule 54 (statement -> return .)
    SEMIC           reduce using rule 54 (statement -> return .)
    ELSE            reduce using rule 54 (statement -> return .)
    RBRACKET        reduce using rule 54 (statement -> return .)


state 47

    (20) for -> FOR . ID IN DOT ID LBRACKET statement RBRACKET

    ID              shift and go to state 67


state 48

    (48) asign -> ID . EQUALS expresiones SEMIC

    EQUALS          shift and go to state 68


state 49

    (50) statement -> condition .

    ID              reduce using rule 50 (statement -> condition .)
    IF              reduce using rule 50 (statement -> condition .)
    PRINT           reduce using rule 50 (statement -> condition .)
    MIN             reduce using rule 50 (statement -> condition .)
    MAX             reduce using rule 50 (statement -> condition .)
    RETURN          reduce using rule 50 (statement -> condition .)
    FOR             reduce using rule 50 (statement -> condition .)
    RCURLY          reduce using rule 50 (statement -> condition .)
    SEMIC           reduce using rule 50 (statement -> condition .)
    ELSE            reduce using rule 50 (statement -> condition .)
    RBRACKET        reduce using rule 50 (statement -> condition .)


state 50

    (32) condition -> IF . LPAREN expresion RPAREN block SEMIC
    (33) condition -> IF . LPAREN expresion RPAREN block ELSE block SEMIC

    LPAREN          shift and go to state 69


state 51

    (16) optimize -> MAX . EQUALS restrictions

    EQUALS          shift and go to state 70


state 52

    (49) statement -> asign .

    ID              reduce using rule 49 (statement -> asign .)
    IF              reduce using rule 49 (statement -> asign .)
    PRINT           reduce using rule 49 (statement -> asign .)
    MIN             reduce using rule 49 (statement -> asign .)
    MAX             reduce using rule 49 (statement -> asign .)
    RETURN          reduce using rule 49 (statement -> asign .)
    FOR             reduce using rule 49 (statement -> asign .)
    RCURLY          reduce using rule 49 (statement -> asign .)
    SEMIC           reduce using rule 49 (statement -> asign .)
    ELSE            reduce using rule 49 (statement -> asign .)
    RBRACKET        reduce using rule 49 (statement -> asign .)


state 53

    (53) statement -> loop .

    ID              reduce using rule 53 (statement -> loop .)
    IF              reduce using rule 53 (statement -> loop .)
    PRINT           reduce using rule 53 (statement -> loop .)
    MIN             reduce using rule 53 (statement -> loop .)
    MAX             reduce using rule 53 (statement -> loop .)
    RETURN          reduce using rule 53 (statement -> loop .)
    FOR             reduce using rule 53 (statement -> loop .)
    RCURLY          reduce using rule 53 (statement -> loop .)
    SEMIC           reduce using rule 53 (statement -> loop .)
    ELSE            reduce using rule 53 (statement -> loop .)
    RBRACKET        reduce using rule 53 (statement -> loop .)


state 54

    (59) manyargs -> tipo ID . liargs
    (60) liargs -> . empty
    (61) liargs -> . COMMA manyargs
    (90) empty -> .

    COMMA           shift and go to state 72
    RPAREN          reduce using rule 90 (empty -> .)

    liargs                         shift and go to state 71
    empty                          shift and go to state 73

state 55

    (57) function -> FUNC ID LPAREN manyargs RPAREN . LCURLY varsdata block2 RCURLY

    LCURLY          shift and go to state 74


state 56

    (72) array -> LBRACKET CTEI RBRACKET .
    (71) matrix -> LBRACKET CTEI RBRACKET . LBRACKET CTEI RBRACKET

    POINTS          reduce using rule 72 (array -> LBRACKET CTEI RBRACKET .)
    LBRACKET        shift and go to state 75


state 57

    (78) listofids -> ID lid .

    SEMIC           reduce using rule 78 (listofids -> ID lid .)


state 58

    (77) lid -> empty .

    SEMIC           reduce using rule 77 (lid -> empty .)


state 59

    (76) lid -> COMMA . listofids
    (78) listofids -> . ID lid

    ID              shift and go to state 33

    listofids                      shift and go to state 76

state 60

    (81) listofvars -> declaracion POINTS listofids SEMIC . lvars
    (79) lvars -> . listofvars
    (80) lvars -> . empty
    (81) listofvars -> . declaracion POINTS listofids SEMIC lvars
    (90) empty -> .
    (73) declaracion -> . tipo array
    (74) declaracion -> . tipo matrix
    (75) declaracion -> . tipo
    (67) tipo -> . TINT
    (68) tipo -> . TFLOAT
    (69) tipo -> . TBOOL

    RCURLY          reduce using rule 90 (empty -> .)
    TINT            shift and go to state 13
    TFLOAT          shift and go to state 17
    TBOOL           shift and go to state 16

    tipo                           shift and go to state 14
    listofvars                     shift and go to state 77
    lvars                          shift and go to state 78
    declaracion                    shift and go to state 18
    empty                          shift and go to state 79

state 61

    (10) data -> DATA LCURLY . asignmany RCURLY
    (11) asignmany -> . asign SEMIC asignlist
    (12) asignmany -> . asign
    (48) asign -> . ID EQUALS expresiones SEMIC

    ID              shift and go to state 48

    asignmany                      shift and go to state 80
    asign                          shift and go to state 81

state 62

    (56) return -> RETURN asign .

    ID              reduce using rule 56 (return -> RETURN asign .)
    IF              reduce using rule 56 (return -> RETURN asign .)
    PRINT           reduce using rule 56 (return -> RETURN asign .)
    MIN             reduce using rule 56 (return -> RETURN asign .)
    MAX             reduce using rule 56 (return -> RETURN asign .)
    RETURN          reduce using rule 56 (return -> RETURN asign .)
    FOR             reduce using rule 56 (return -> RETURN asign .)
    RCURLY          reduce using rule 56 (return -> RETURN asign .)
    RBRACKET        reduce using rule 56 (return -> RETURN asign .)
    SEMIC           reduce using rule 56 (return -> RETURN asign .)
    ELSE            reduce using rule 56 (return -> RETURN asign .)


state 63

    (89) program -> declarevars declarefunc MODEL LCURLY varsdata block2 RCURLY .

    $end            reduce using rule 89 (program -> declarevars declarefunc MODEL LCURLY varsdata block2 RCURLY .)


state 64

    (15) optimize -> MIN EQUALS . restrictions
    (17) restrictions -> . WHERE restrictions2

    WHERE           shift and go to state 83

    restrictions                   shift and go to state 82

state 65

    (43) write -> PRINT LPAREN . write2 RPAREN SEMIC
    (44) write2 -> . expresion
    (45) write2 -> . CTESTRING
    (46) write2 -> . expresion DOT write2
    (47) write2 -> . CTESTRING DOT write2
    (36) expresion -> . exp
    (37) expresion -> . exp LESSTHAN exp
    (38) expresion -> . exp GREATERTHAN exp
    (39) expresion -> . exp BETWEEN exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . ID
    (6) constant -> . functioncall
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    CTESTRING       shift and go to state 85
    PLUS            shift and go to state 87
    MINUS           shift and go to state 86
    LPAREN          shift and go to state 84
    CTEI            shift and go to state 98
    CTEF            shift and go to state 96
    CTEBOOL         shift and go to state 94
    ID              shift and go to state 91

    expresion                      shift and go to state 92
    term                           shift and go to state 93
    constant                       shift and go to state 90
    write2                         shift and go to state 95
    functioncall                   shift and go to state 89
    exp                            shift and go to state 97
    factor                         shift and go to state 88

state 66

    (64) block2 -> statement block2 .

    SEMIC           reduce using rule 64 (block2 -> statement block2 .)
    ELSE            reduce using rule 64 (block2 -> statement block2 .)
    RCURLY          reduce using rule 64 (block2 -> statement block2 .)


state 67

    (20) for -> FOR ID . IN DOT ID LBRACKET statement RBRACKET

    IN              shift and go to state 99


state 68

    (48) asign -> ID EQUALS . expresiones SEMIC
    (34) expresiones -> . expresion COMMA expresiones
    (35) expresiones -> . expresion
    (36) expresion -> . exp
    (37) expresion -> . exp LESSTHAN exp
    (38) expresion -> . exp GREATERTHAN exp
    (39) expresion -> . exp BETWEEN exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . ID
    (6) constant -> . functioncall
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 87
    MINUS           shift and go to state 86
    LPAREN          shift and go to state 84
    CTEI            shift and go to state 98
    CTEF            shift and go to state 96
    CTESTRING       shift and go to state 102
    CTEBOOL         shift and go to state 94
    ID              shift and go to state 91

    expresion                      shift and go to state 101
    expresiones                    shift and go to state 100
    constant                       shift and go to state 90
    term                           shift and go to state 93
    functioncall                   shift and go to state 89
    exp                            shift and go to state 97
    factor                         shift and go to state 88

state 69

    (32) condition -> IF LPAREN . expresion RPAREN block SEMIC
    (33) condition -> IF LPAREN . expresion RPAREN block ELSE block SEMIC
    (36) expresion -> . exp
    (37) expresion -> . exp LESSTHAN exp
    (38) expresion -> . exp GREATERTHAN exp
    (39) expresion -> . exp BETWEEN exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . ID
    (6) constant -> . functioncall
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 87
    MINUS           shift and go to state 86
    LPAREN          shift and go to state 84
    CTEI            shift and go to state 98
    CTEF            shift and go to state 96
    CTESTRING       shift and go to state 102
    CTEBOOL         shift and go to state 94
    ID              shift and go to state 91

    expresion                      shift and go to state 103
    term                           shift and go to state 93
    constant                       shift and go to state 90
    functioncall                   shift and go to state 89
    exp                            shift and go to state 97
    factor                         shift and go to state 88

state 70

    (16) optimize -> MAX EQUALS . restrictions
    (17) restrictions -> . WHERE restrictions2

    WHERE           shift and go to state 83

    restrictions                   shift and go to state 104

state 71

    (59) manyargs -> tipo ID liargs .

    RPAREN          reduce using rule 59 (manyargs -> tipo ID liargs .)


state 72

    (61) liargs -> COMMA . manyargs
    (58) manyargs -> . empty
    (59) manyargs -> . tipo ID liargs
    (90) empty -> .
    (67) tipo -> . TINT
    (68) tipo -> . TFLOAT
    (69) tipo -> . TBOOL

    RPAREN          reduce using rule 90 (empty -> .)
    TINT            shift and go to state 13
    TFLOAT          shift and go to state 17
    TBOOL           shift and go to state 16

    empty                          shift and go to state 31
    manyargs                       shift and go to state 105
    tipo                           shift and go to state 29

state 73

    (60) liargs -> empty .

    RPAREN          reduce using rule 60 (liargs -> empty .)


state 74

    (57) function -> FUNC ID LPAREN manyargs RPAREN LCURLY . varsdata block2 RCURLY
    (82) varsdata -> . vars data
    (83) varsdata -> . empty
    (84) varsdata -> . vars
    (70) vars -> . VARS LCURLY listofvars RCURLY
    (90) empty -> .

    VARS            shift and go to state 4
    ID              reduce using rule 90 (empty -> .)
    IF              reduce using rule 90 (empty -> .)
    PRINT           reduce using rule 90 (empty -> .)
    MIN             reduce using rule 90 (empty -> .)
    MAX             reduce using rule 90 (empty -> .)
    RETURN          reduce using rule 90 (empty -> .)
    FOR             reduce using rule 90 (empty -> .)
    RCURLY          reduce using rule 90 (empty -> .)

    vars                           shift and go to state 26
    varsdata                       shift and go to state 106
    empty                          shift and go to state 28

state 75

    (71) matrix -> LBRACKET CTEI RBRACKET LBRACKET . CTEI RBRACKET

    CTEI            shift and go to state 107


state 76

    (76) lid -> COMMA listofids .

    SEMIC           reduce using rule 76 (lid -> COMMA listofids .)


state 77

    (79) lvars -> listofvars .

    RCURLY          reduce using rule 79 (lvars -> listofvars .)


state 78

    (81) listofvars -> declaracion POINTS listofids SEMIC lvars .

    RCURLY          reduce using rule 81 (listofvars -> declaracion POINTS listofids SEMIC lvars .)


state 79

    (80) lvars -> empty .

    RCURLY          reduce using rule 80 (lvars -> empty .)


state 80

    (10) data -> DATA LCURLY asignmany . RCURLY

    RCURLY          shift and go to state 108


state 81

    (11) asignmany -> asign . SEMIC asignlist
    (12) asignmany -> asign .

    SEMIC           shift and go to state 109
    RCURLY          reduce using rule 12 (asignmany -> asign .)


state 82

    (15) optimize -> MIN EQUALS restrictions .

    RBRACKET        reduce using rule 15 (optimize -> MIN EQUALS restrictions .)
    ID              reduce using rule 15 (optimize -> MIN EQUALS restrictions .)
    IF              reduce using rule 15 (optimize -> MIN EQUALS restrictions .)
    PRINT           reduce using rule 15 (optimize -> MIN EQUALS restrictions .)
    MIN             reduce using rule 15 (optimize -> MIN EQUALS restrictions .)
    MAX             reduce using rule 15 (optimize -> MIN EQUALS restrictions .)
    RETURN          reduce using rule 15 (optimize -> MIN EQUALS restrictions .)
    FOR             reduce using rule 15 (optimize -> MIN EQUALS restrictions .)
    SEMIC           reduce using rule 15 (optimize -> MIN EQUALS restrictions .)
    ELSE            reduce using rule 15 (optimize -> MIN EQUALS restrictions .)
    RCURLY          reduce using rule 15 (optimize -> MIN EQUALS restrictions .)


state 83

    (17) restrictions -> WHERE . restrictions2
    (18) restrictions2 -> . expresion
    (19) restrictions2 -> . sum SEMIC forlist
    (36) expresion -> . exp
    (37) expresion -> . exp LESSTHAN exp
    (38) expresion -> . exp GREATERTHAN exp
    (39) expresion -> . exp BETWEEN exp
    (24) sum -> . SUM LPAREN ID POINTS expresion RPAREN
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . ID
    (6) constant -> . functioncall
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    SUM             shift and go to state 110
    PLUS            shift and go to state 87
    MINUS           shift and go to state 86
    LPAREN          shift and go to state 84
    CTEI            shift and go to state 98
    CTEF            shift and go to state 96
    CTESTRING       shift and go to state 102
    CTEBOOL         shift and go to state 94
    ID              shift and go to state 91

    expresion                      shift and go to state 113
    term                           shift and go to state 93
    constant                       shift and go to state 90
    sum                            shift and go to state 111
    functioncall                   shift and go to state 89
    exp                            shift and go to state 97
    factor                         shift and go to state 88
    restrictions2                  shift and go to state 112

state 84

    (28) factor -> LPAREN . expresion RPAREN
    (36) expresion -> . exp
    (37) expresion -> . exp LESSTHAN exp
    (38) expresion -> . exp GREATERTHAN exp
    (39) expresion -> . exp BETWEEN exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . ID
    (6) constant -> . functioncall
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 87
    MINUS           shift and go to state 86
    LPAREN          shift and go to state 84
    CTEI            shift and go to state 98
    CTEF            shift and go to state 96
    CTESTRING       shift and go to state 102
    CTEBOOL         shift and go to state 94
    ID              shift and go to state 91

    expresion                      shift and go to state 114
    term                           shift and go to state 93
    constant                       shift and go to state 90
    functioncall                   shift and go to state 89
    exp                            shift and go to state 97
    factor                         shift and go to state 88

state 85

    (45) write2 -> CTESTRING .
    (47) write2 -> CTESTRING . DOT write2
    (3) constant -> CTESTRING .

  ! shift/reduce conflict for DOT resolved as shift
  ! reduce/reduce conflict for RPAREN resolved using rule 3 (constant -> CTESTRING .)
    DOT             shift and go to state 115
    STAR            reduce using rule 3 (constant -> CTESTRING .)
    SLASH           reduce using rule 3 (constant -> CTESTRING .)
    PLUS            reduce using rule 3 (constant -> CTESTRING .)
    MINUS           reduce using rule 3 (constant -> CTESTRING .)
    LESSTHAN        reduce using rule 3 (constant -> CTESTRING .)
    GREATERTHAN     reduce using rule 3 (constant -> CTESTRING .)
    BETWEEN         reduce using rule 3 (constant -> CTESTRING .)
    RPAREN          reduce using rule 3 (constant -> CTESTRING .)

  ! RPAREN          [ reduce using rule 45 (write2 -> CTESTRING .) ]
  ! DOT             [ reduce using rule 3 (constant -> CTESTRING .) ]


state 86

    (26) factor -> MINUS . constant
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . ID
    (6) constant -> . functioncall
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    CTEI            shift and go to state 98
    CTEF            shift and go to state 96
    CTESTRING       shift and go to state 102
    CTEBOOL         shift and go to state 94
    ID              shift and go to state 91

    functioncall                   shift and go to state 89
    constant                       shift and go to state 116

state 87

    (25) factor -> PLUS . constant
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . ID
    (6) constant -> . functioncall
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    CTEI            shift and go to state 98
    CTEF            shift and go to state 96
    CTESTRING       shift and go to state 102
    CTEBOOL         shift and go to state 94
    ID              shift and go to state 91

    functioncall                   shift and go to state 89
    constant                       shift and go to state 117

state 88

    (29) term -> factor .
    (30) term -> factor . STAR term
    (31) term -> factor . SLASH term

    PLUS            reduce using rule 29 (term -> factor .)
    MINUS           reduce using rule 29 (term -> factor .)
    DOT             reduce using rule 29 (term -> factor .)
    RPAREN          reduce using rule 29 (term -> factor .)
    COMMA           reduce using rule 29 (term -> factor .)
    SEMIC           reduce using rule 29 (term -> factor .)
    ID              reduce using rule 29 (term -> factor .)
    IF              reduce using rule 29 (term -> factor .)
    PRINT           reduce using rule 29 (term -> factor .)
    MIN             reduce using rule 29 (term -> factor .)
    MAX             reduce using rule 29 (term -> factor .)
    RETURN          reduce using rule 29 (term -> factor .)
    FOR             reduce using rule 29 (term -> factor .)
    RCURLY          reduce using rule 29 (term -> factor .)
    ELSE            reduce using rule 29 (term -> factor .)
    RBRACKET        reduce using rule 29 (term -> factor .)
    LESSTHAN        reduce using rule 29 (term -> factor .)
    GREATERTHAN     reduce using rule 29 (term -> factor .)
    BETWEEN         reduce using rule 29 (term -> factor .)
    STAR            shift and go to state 118
    SLASH           shift and go to state 119


state 89

    (6) constant -> functioncall .

    STAR            reduce using rule 6 (constant -> functioncall .)
    SLASH           reduce using rule 6 (constant -> functioncall .)
    PLUS            reduce using rule 6 (constant -> functioncall .)
    MINUS           reduce using rule 6 (constant -> functioncall .)
    LESSTHAN        reduce using rule 6 (constant -> functioncall .)
    GREATERTHAN     reduce using rule 6 (constant -> functioncall .)
    BETWEEN         reduce using rule 6 (constant -> functioncall .)
    DOT             reduce using rule 6 (constant -> functioncall .)
    RPAREN          reduce using rule 6 (constant -> functioncall .)
    COMMA           reduce using rule 6 (constant -> functioncall .)
    SEMIC           reduce using rule 6 (constant -> functioncall .)
    ID              reduce using rule 6 (constant -> functioncall .)
    IF              reduce using rule 6 (constant -> functioncall .)
    PRINT           reduce using rule 6 (constant -> functioncall .)
    MIN             reduce using rule 6 (constant -> functioncall .)
    MAX             reduce using rule 6 (constant -> functioncall .)
    RETURN          reduce using rule 6 (constant -> functioncall .)
    FOR             reduce using rule 6 (constant -> functioncall .)
    RCURLY          reduce using rule 6 (constant -> functioncall .)
    ELSE            reduce using rule 6 (constant -> functioncall .)
    RBRACKET        reduce using rule 6 (constant -> functioncall .)


state 90

    (27) factor -> constant .

    STAR            reduce using rule 27 (factor -> constant .)
    SLASH           reduce using rule 27 (factor -> constant .)
    PLUS            reduce using rule 27 (factor -> constant .)
    MINUS           reduce using rule 27 (factor -> constant .)
    LESSTHAN        reduce using rule 27 (factor -> constant .)
    GREATERTHAN     reduce using rule 27 (factor -> constant .)
    BETWEEN         reduce using rule 27 (factor -> constant .)
    DOT             reduce using rule 27 (factor -> constant .)
    RPAREN          reduce using rule 27 (factor -> constant .)
    COMMA           reduce using rule 27 (factor -> constant .)
    SEMIC           reduce using rule 27 (factor -> constant .)
    ID              reduce using rule 27 (factor -> constant .)
    IF              reduce using rule 27 (factor -> constant .)
    PRINT           reduce using rule 27 (factor -> constant .)
    MIN             reduce using rule 27 (factor -> constant .)
    MAX             reduce using rule 27 (factor -> constant .)
    RETURN          reduce using rule 27 (factor -> constant .)
    FOR             reduce using rule 27 (factor -> constant .)
    RCURLY          reduce using rule 27 (factor -> constant .)
    ELSE            reduce using rule 27 (factor -> constant .)
    RBRACKET        reduce using rule 27 (factor -> constant .)


state 91

    (5) constant -> ID .
    (7) functioncall -> ID . LPAREN expresion RPAREN
    (8) functioncall -> ID . LPAREN CTEI RPAREN
    (9) functioncall -> ID . LPAREN CTEF RPAREN

    STAR            reduce using rule 5 (constant -> ID .)
    SLASH           reduce using rule 5 (constant -> ID .)
    PLUS            reduce using rule 5 (constant -> ID .)
    MINUS           reduce using rule 5 (constant -> ID .)
    LESSTHAN        reduce using rule 5 (constant -> ID .)
    GREATERTHAN     reduce using rule 5 (constant -> ID .)
    BETWEEN         reduce using rule 5 (constant -> ID .)
    DOT             reduce using rule 5 (constant -> ID .)
    RPAREN          reduce using rule 5 (constant -> ID .)
    COMMA           reduce using rule 5 (constant -> ID .)
    SEMIC           reduce using rule 5 (constant -> ID .)
    ID              reduce using rule 5 (constant -> ID .)
    IF              reduce using rule 5 (constant -> ID .)
    PRINT           reduce using rule 5 (constant -> ID .)
    MIN             reduce using rule 5 (constant -> ID .)
    MAX             reduce using rule 5 (constant -> ID .)
    RETURN          reduce using rule 5 (constant -> ID .)
    FOR             reduce using rule 5 (constant -> ID .)
    RCURLY          reduce using rule 5 (constant -> ID .)
    ELSE            reduce using rule 5 (constant -> ID .)
    RBRACKET        reduce using rule 5 (constant -> ID .)
    LPAREN          shift and go to state 120


state 92

    (44) write2 -> expresion .
    (46) write2 -> expresion . DOT write2

    RPAREN          reduce using rule 44 (write2 -> expresion .)
    DOT             shift and go to state 121


state 93

    (40) exp -> term .
    (41) exp -> term . PLUS exp
    (42) exp -> term . MINUS exp

    LESSTHAN        reduce using rule 40 (exp -> term .)
    GREATERTHAN     reduce using rule 40 (exp -> term .)
    BETWEEN         reduce using rule 40 (exp -> term .)
    DOT             reduce using rule 40 (exp -> term .)
    RPAREN          reduce using rule 40 (exp -> term .)
    COMMA           reduce using rule 40 (exp -> term .)
    SEMIC           reduce using rule 40 (exp -> term .)
    ID              reduce using rule 40 (exp -> term .)
    IF              reduce using rule 40 (exp -> term .)
    PRINT           reduce using rule 40 (exp -> term .)
    MIN             reduce using rule 40 (exp -> term .)
    MAX             reduce using rule 40 (exp -> term .)
    RETURN          reduce using rule 40 (exp -> term .)
    FOR             reduce using rule 40 (exp -> term .)
    RCURLY          reduce using rule 40 (exp -> term .)
    ELSE            reduce using rule 40 (exp -> term .)
    RBRACKET        reduce using rule 40 (exp -> term .)
    PLUS            shift and go to state 122
    MINUS           shift and go to state 123


state 94

    (4) constant -> CTEBOOL .

    STAR            reduce using rule 4 (constant -> CTEBOOL .)
    SLASH           reduce using rule 4 (constant -> CTEBOOL .)
    PLUS            reduce using rule 4 (constant -> CTEBOOL .)
    MINUS           reduce using rule 4 (constant -> CTEBOOL .)
    LESSTHAN        reduce using rule 4 (constant -> CTEBOOL .)
    GREATERTHAN     reduce using rule 4 (constant -> CTEBOOL .)
    BETWEEN         reduce using rule 4 (constant -> CTEBOOL .)
    DOT             reduce using rule 4 (constant -> CTEBOOL .)
    RPAREN          reduce using rule 4 (constant -> CTEBOOL .)
    COMMA           reduce using rule 4 (constant -> CTEBOOL .)
    SEMIC           reduce using rule 4 (constant -> CTEBOOL .)
    ID              reduce using rule 4 (constant -> CTEBOOL .)
    IF              reduce using rule 4 (constant -> CTEBOOL .)
    PRINT           reduce using rule 4 (constant -> CTEBOOL .)
    MIN             reduce using rule 4 (constant -> CTEBOOL .)
    MAX             reduce using rule 4 (constant -> CTEBOOL .)
    RETURN          reduce using rule 4 (constant -> CTEBOOL .)
    FOR             reduce using rule 4 (constant -> CTEBOOL .)
    RCURLY          reduce using rule 4 (constant -> CTEBOOL .)
    ELSE            reduce using rule 4 (constant -> CTEBOOL .)
    RBRACKET        reduce using rule 4 (constant -> CTEBOOL .)


state 95

    (43) write -> PRINT LPAREN write2 . RPAREN SEMIC

    RPAREN          shift and go to state 124


state 96

    (2) constant -> CTEF .

    STAR            reduce using rule 2 (constant -> CTEF .)
    SLASH           reduce using rule 2 (constant -> CTEF .)
    PLUS            reduce using rule 2 (constant -> CTEF .)
    MINUS           reduce using rule 2 (constant -> CTEF .)
    LESSTHAN        reduce using rule 2 (constant -> CTEF .)
    GREATERTHAN     reduce using rule 2 (constant -> CTEF .)
    BETWEEN         reduce using rule 2 (constant -> CTEF .)
    DOT             reduce using rule 2 (constant -> CTEF .)
    RPAREN          reduce using rule 2 (constant -> CTEF .)
    COMMA           reduce using rule 2 (constant -> CTEF .)
    SEMIC           reduce using rule 2 (constant -> CTEF .)
    ID              reduce using rule 2 (constant -> CTEF .)
    IF              reduce using rule 2 (constant -> CTEF .)
    PRINT           reduce using rule 2 (constant -> CTEF .)
    MIN             reduce using rule 2 (constant -> CTEF .)
    MAX             reduce using rule 2 (constant -> CTEF .)
    RETURN          reduce using rule 2 (constant -> CTEF .)
    FOR             reduce using rule 2 (constant -> CTEF .)
    RCURLY          reduce using rule 2 (constant -> CTEF .)
    ELSE            reduce using rule 2 (constant -> CTEF .)
    RBRACKET        reduce using rule 2 (constant -> CTEF .)


state 97

    (36) expresion -> exp .
    (37) expresion -> exp . LESSTHAN exp
    (38) expresion -> exp . GREATERTHAN exp
    (39) expresion -> exp . BETWEEN exp

    DOT             reduce using rule 36 (expresion -> exp .)
    RPAREN          reduce using rule 36 (expresion -> exp .)
    COMMA           reduce using rule 36 (expresion -> exp .)
    SEMIC           reduce using rule 36 (expresion -> exp .)
    ID              reduce using rule 36 (expresion -> exp .)
    IF              reduce using rule 36 (expresion -> exp .)
    PRINT           reduce using rule 36 (expresion -> exp .)
    MIN             reduce using rule 36 (expresion -> exp .)
    MAX             reduce using rule 36 (expresion -> exp .)
    RETURN          reduce using rule 36 (expresion -> exp .)
    FOR             reduce using rule 36 (expresion -> exp .)
    RCURLY          reduce using rule 36 (expresion -> exp .)
    ELSE            reduce using rule 36 (expresion -> exp .)
    RBRACKET        reduce using rule 36 (expresion -> exp .)
    LESSTHAN        shift and go to state 125
    GREATERTHAN     shift and go to state 126
    BETWEEN         shift and go to state 127


state 98

    (1) constant -> CTEI .

    STAR            reduce using rule 1 (constant -> CTEI .)
    SLASH           reduce using rule 1 (constant -> CTEI .)
    PLUS            reduce using rule 1 (constant -> CTEI .)
    MINUS           reduce using rule 1 (constant -> CTEI .)
    LESSTHAN        reduce using rule 1 (constant -> CTEI .)
    GREATERTHAN     reduce using rule 1 (constant -> CTEI .)
    BETWEEN         reduce using rule 1 (constant -> CTEI .)
    DOT             reduce using rule 1 (constant -> CTEI .)
    RPAREN          reduce using rule 1 (constant -> CTEI .)
    COMMA           reduce using rule 1 (constant -> CTEI .)
    SEMIC           reduce using rule 1 (constant -> CTEI .)
    ID              reduce using rule 1 (constant -> CTEI .)
    IF              reduce using rule 1 (constant -> CTEI .)
    PRINT           reduce using rule 1 (constant -> CTEI .)
    MIN             reduce using rule 1 (constant -> CTEI .)
    MAX             reduce using rule 1 (constant -> CTEI .)
    RETURN          reduce using rule 1 (constant -> CTEI .)
    FOR             reduce using rule 1 (constant -> CTEI .)
    RCURLY          reduce using rule 1 (constant -> CTEI .)
    ELSE            reduce using rule 1 (constant -> CTEI .)
    RBRACKET        reduce using rule 1 (constant -> CTEI .)


state 99

    (20) for -> FOR ID IN . DOT ID LBRACKET statement RBRACKET

    DOT             shift and go to state 128


state 100

    (48) asign -> ID EQUALS expresiones . SEMIC

    SEMIC           shift and go to state 129


state 101

    (34) expresiones -> expresion . COMMA expresiones
    (35) expresiones -> expresion .

    COMMA           shift and go to state 130
    SEMIC           reduce using rule 35 (expresiones -> expresion .)


state 102

    (3) constant -> CTESTRING .

    STAR            reduce using rule 3 (constant -> CTESTRING .)
    SLASH           reduce using rule 3 (constant -> CTESTRING .)
    PLUS            reduce using rule 3 (constant -> CTESTRING .)
    MINUS           reduce using rule 3 (constant -> CTESTRING .)
    LESSTHAN        reduce using rule 3 (constant -> CTESTRING .)
    GREATERTHAN     reduce using rule 3 (constant -> CTESTRING .)
    BETWEEN         reduce using rule 3 (constant -> CTESTRING .)
    COMMA           reduce using rule 3 (constant -> CTESTRING .)
    SEMIC           reduce using rule 3 (constant -> CTESTRING .)
    DOT             reduce using rule 3 (constant -> CTESTRING .)
    RPAREN          reduce using rule 3 (constant -> CTESTRING .)
    ID              reduce using rule 3 (constant -> CTESTRING .)
    IF              reduce using rule 3 (constant -> CTESTRING .)
    PRINT           reduce using rule 3 (constant -> CTESTRING .)
    MIN             reduce using rule 3 (constant -> CTESTRING .)
    MAX             reduce using rule 3 (constant -> CTESTRING .)
    RETURN          reduce using rule 3 (constant -> CTESTRING .)
    FOR             reduce using rule 3 (constant -> CTESTRING .)
    RCURLY          reduce using rule 3 (constant -> CTESTRING .)
    ELSE            reduce using rule 3 (constant -> CTESTRING .)
    RBRACKET        reduce using rule 3 (constant -> CTESTRING .)


state 103

    (32) condition -> IF LPAREN expresion . RPAREN block SEMIC
    (33) condition -> IF LPAREN expresion . RPAREN block ELSE block SEMIC

    RPAREN          shift and go to state 131


state 104

    (16) optimize -> MAX EQUALS restrictions .

    RBRACKET        reduce using rule 16 (optimize -> MAX EQUALS restrictions .)
    ID              reduce using rule 16 (optimize -> MAX EQUALS restrictions .)
    IF              reduce using rule 16 (optimize -> MAX EQUALS restrictions .)
    PRINT           reduce using rule 16 (optimize -> MAX EQUALS restrictions .)
    MIN             reduce using rule 16 (optimize -> MAX EQUALS restrictions .)
    MAX             reduce using rule 16 (optimize -> MAX EQUALS restrictions .)
    RETURN          reduce using rule 16 (optimize -> MAX EQUALS restrictions .)
    FOR             reduce using rule 16 (optimize -> MAX EQUALS restrictions .)
    SEMIC           reduce using rule 16 (optimize -> MAX EQUALS restrictions .)
    ELSE            reduce using rule 16 (optimize -> MAX EQUALS restrictions .)
    RCURLY          reduce using rule 16 (optimize -> MAX EQUALS restrictions .)


state 105

    (61) liargs -> COMMA manyargs .

    RPAREN          reduce using rule 61 (liargs -> COMMA manyargs .)


state 106

    (57) function -> FUNC ID LPAREN manyargs RPAREN LCURLY varsdata . block2 RCURLY
    (64) block2 -> . statement block2
    (65) block2 -> . statement
    (66) block2 -> . empty
    (49) statement -> . asign
    (50) statement -> . condition
    (51) statement -> . write
    (52) statement -> . optimize
    (53) statement -> . loop
    (54) statement -> . return
    (90) empty -> .
    (48) asign -> . ID EQUALS expresiones SEMIC
    (32) condition -> . IF LPAREN expresion RPAREN block SEMIC
    (33) condition -> . IF LPAREN expresion RPAREN block ELSE block SEMIC
    (43) write -> . PRINT LPAREN write2 RPAREN SEMIC
    (15) optimize -> . MIN EQUALS restrictions
    (16) optimize -> . MAX EQUALS restrictions
    (55) loop -> . for
    (56) return -> . RETURN asign
    (20) for -> . FOR ID IN DOT ID LBRACKET statement RBRACKET

    RCURLY          reduce using rule 90 (empty -> .)
    ID              shift and go to state 48
    IF              shift and go to state 50
    PRINT           shift and go to state 40
    MIN             shift and go to state 39
    MAX             shift and go to state 51
    RETURN          shift and go to state 37
    FOR             shift and go to state 47

    return                         shift and go to state 46
    block2                         shift and go to state 132
    for                            shift and go to state 41
    asign                          shift and go to state 52
    write                          shift and go to state 43
    condition                      shift and go to state 49
    statement                      shift and go to state 44
    loop                           shift and go to state 53
    optimize                       shift and go to state 42
    empty                          shift and go to state 45

state 107

    (71) matrix -> LBRACKET CTEI RBRACKET LBRACKET CTEI . RBRACKET

    RBRACKET        shift and go to state 133


state 108

    (10) data -> DATA LCURLY asignmany RCURLY .

    ID              reduce using rule 10 (data -> DATA LCURLY asignmany RCURLY .)
    IF              reduce using rule 10 (data -> DATA LCURLY asignmany RCURLY .)
    PRINT           reduce using rule 10 (data -> DATA LCURLY asignmany RCURLY .)
    MIN             reduce using rule 10 (data -> DATA LCURLY asignmany RCURLY .)
    MAX             reduce using rule 10 (data -> DATA LCURLY asignmany RCURLY .)
    RETURN          reduce using rule 10 (data -> DATA LCURLY asignmany RCURLY .)
    FOR             reduce using rule 10 (data -> DATA LCURLY asignmany RCURLY .)
    RCURLY          reduce using rule 10 (data -> DATA LCURLY asignmany RCURLY .)


state 109

    (11) asignmany -> asign SEMIC . asignlist
    (13) asignlist -> . empty
    (14) asignlist -> . asignmany
    (90) empty -> .
    (11) asignmany -> . asign SEMIC asignlist
    (12) asignmany -> . asign
    (48) asign -> . ID EQUALS expresiones SEMIC

    RCURLY          reduce using rule 90 (empty -> .)
    ID              shift and go to state 48

    asignmany                      shift and go to state 134
    asignlist                      shift and go to state 135
    empty                          shift and go to state 136
    asign                          shift and go to state 81

state 110

    (24) sum -> SUM . LPAREN ID POINTS expresion RPAREN

    LPAREN          shift and go to state 137


state 111

    (19) restrictions2 -> sum . SEMIC forlist

    SEMIC           shift and go to state 138


state 112

    (17) restrictions -> WHERE restrictions2 .

    ID              reduce using rule 17 (restrictions -> WHERE restrictions2 .)
    IF              reduce using rule 17 (restrictions -> WHERE restrictions2 .)
    PRINT           reduce using rule 17 (restrictions -> WHERE restrictions2 .)
    MIN             reduce using rule 17 (restrictions -> WHERE restrictions2 .)
    MAX             reduce using rule 17 (restrictions -> WHERE restrictions2 .)
    RETURN          reduce using rule 17 (restrictions -> WHERE restrictions2 .)
    FOR             reduce using rule 17 (restrictions -> WHERE restrictions2 .)
    RCURLY          reduce using rule 17 (restrictions -> WHERE restrictions2 .)
    SEMIC           reduce using rule 17 (restrictions -> WHERE restrictions2 .)
    ELSE            reduce using rule 17 (restrictions -> WHERE restrictions2 .)
    RBRACKET        reduce using rule 17 (restrictions -> WHERE restrictions2 .)


state 113

    (18) restrictions2 -> expresion .

    ID              reduce using rule 18 (restrictions2 -> expresion .)
    IF              reduce using rule 18 (restrictions2 -> expresion .)
    PRINT           reduce using rule 18 (restrictions2 -> expresion .)
    MIN             reduce using rule 18 (restrictions2 -> expresion .)
    MAX             reduce using rule 18 (restrictions2 -> expresion .)
    RETURN          reduce using rule 18 (restrictions2 -> expresion .)
    FOR             reduce using rule 18 (restrictions2 -> expresion .)
    RCURLY          reduce using rule 18 (restrictions2 -> expresion .)
    SEMIC           reduce using rule 18 (restrictions2 -> expresion .)
    ELSE            reduce using rule 18 (restrictions2 -> expresion .)
    RBRACKET        reduce using rule 18 (restrictions2 -> expresion .)


state 114

    (28) factor -> LPAREN expresion . RPAREN

    RPAREN          shift and go to state 139


state 115

    (47) write2 -> CTESTRING DOT . write2
    (44) write2 -> . expresion
    (45) write2 -> . CTESTRING
    (46) write2 -> . expresion DOT write2
    (47) write2 -> . CTESTRING DOT write2
    (36) expresion -> . exp
    (37) expresion -> . exp LESSTHAN exp
    (38) expresion -> . exp GREATERTHAN exp
    (39) expresion -> . exp BETWEEN exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . ID
    (6) constant -> . functioncall
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    CTESTRING       shift and go to state 85
    PLUS            shift and go to state 87
    MINUS           shift and go to state 86
    LPAREN          shift and go to state 84
    CTEI            shift and go to state 98
    CTEF            shift and go to state 96
    CTEBOOL         shift and go to state 94
    ID              shift and go to state 91

    expresion                      shift and go to state 92
    term                           shift and go to state 93
    constant                       shift and go to state 90
    write2                         shift and go to state 140
    functioncall                   shift and go to state 89
    exp                            shift and go to state 97
    factor                         shift and go to state 88

state 116

    (26) factor -> MINUS constant .

    STAR            reduce using rule 26 (factor -> MINUS constant .)
    SLASH           reduce using rule 26 (factor -> MINUS constant .)
    PLUS            reduce using rule 26 (factor -> MINUS constant .)
    MINUS           reduce using rule 26 (factor -> MINUS constant .)
    LESSTHAN        reduce using rule 26 (factor -> MINUS constant .)
    GREATERTHAN     reduce using rule 26 (factor -> MINUS constant .)
    BETWEEN         reduce using rule 26 (factor -> MINUS constant .)
    DOT             reduce using rule 26 (factor -> MINUS constant .)
    RPAREN          reduce using rule 26 (factor -> MINUS constant .)
    COMMA           reduce using rule 26 (factor -> MINUS constant .)
    SEMIC           reduce using rule 26 (factor -> MINUS constant .)
    ID              reduce using rule 26 (factor -> MINUS constant .)
    IF              reduce using rule 26 (factor -> MINUS constant .)
    PRINT           reduce using rule 26 (factor -> MINUS constant .)
    MIN             reduce using rule 26 (factor -> MINUS constant .)
    MAX             reduce using rule 26 (factor -> MINUS constant .)
    RETURN          reduce using rule 26 (factor -> MINUS constant .)
    FOR             reduce using rule 26 (factor -> MINUS constant .)
    RCURLY          reduce using rule 26 (factor -> MINUS constant .)
    ELSE            reduce using rule 26 (factor -> MINUS constant .)
    RBRACKET        reduce using rule 26 (factor -> MINUS constant .)


state 117

    (25) factor -> PLUS constant .

    STAR            reduce using rule 25 (factor -> PLUS constant .)
    SLASH           reduce using rule 25 (factor -> PLUS constant .)
    PLUS            reduce using rule 25 (factor -> PLUS constant .)
    MINUS           reduce using rule 25 (factor -> PLUS constant .)
    LESSTHAN        reduce using rule 25 (factor -> PLUS constant .)
    GREATERTHAN     reduce using rule 25 (factor -> PLUS constant .)
    BETWEEN         reduce using rule 25 (factor -> PLUS constant .)
    DOT             reduce using rule 25 (factor -> PLUS constant .)
    RPAREN          reduce using rule 25 (factor -> PLUS constant .)
    COMMA           reduce using rule 25 (factor -> PLUS constant .)
    SEMIC           reduce using rule 25 (factor -> PLUS constant .)
    ID              reduce using rule 25 (factor -> PLUS constant .)
    IF              reduce using rule 25 (factor -> PLUS constant .)
    PRINT           reduce using rule 25 (factor -> PLUS constant .)
    MIN             reduce using rule 25 (factor -> PLUS constant .)
    MAX             reduce using rule 25 (factor -> PLUS constant .)
    RETURN          reduce using rule 25 (factor -> PLUS constant .)
    FOR             reduce using rule 25 (factor -> PLUS constant .)
    RCURLY          reduce using rule 25 (factor -> PLUS constant .)
    ELSE            reduce using rule 25 (factor -> PLUS constant .)
    RBRACKET        reduce using rule 25 (factor -> PLUS constant .)


state 118

    (30) term -> factor STAR . term
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . ID
    (6) constant -> . functioncall
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 87
    MINUS           shift and go to state 86
    LPAREN          shift and go to state 84
    CTEI            shift and go to state 98
    CTEF            shift and go to state 96
    CTESTRING       shift and go to state 102
    CTEBOOL         shift and go to state 94
    ID              shift and go to state 91

    functioncall                   shift and go to state 89
    term                           shift and go to state 141
    constant                       shift and go to state 90
    factor                         shift and go to state 88

state 119

    (31) term -> factor SLASH . term
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . ID
    (6) constant -> . functioncall
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 87
    MINUS           shift and go to state 86
    LPAREN          shift and go to state 84
    CTEI            shift and go to state 98
    CTEF            shift and go to state 96
    CTESTRING       shift and go to state 102
    CTEBOOL         shift and go to state 94
    ID              shift and go to state 91

    functioncall                   shift and go to state 89
    term                           shift and go to state 142
    constant                       shift and go to state 90
    factor                         shift and go to state 88

state 120

    (7) functioncall -> ID LPAREN . expresion RPAREN
    (8) functioncall -> ID LPAREN . CTEI RPAREN
    (9) functioncall -> ID LPAREN . CTEF RPAREN
    (36) expresion -> . exp
    (37) expresion -> . exp LESSTHAN exp
    (38) expresion -> . exp GREATERTHAN exp
    (39) expresion -> . exp BETWEEN exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . ID
    (6) constant -> . functioncall
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    CTEI            shift and go to state 145
    CTEF            shift and go to state 144
    PLUS            shift and go to state 87
    MINUS           shift and go to state 86
    LPAREN          shift and go to state 84
    CTESTRING       shift and go to state 102
    CTEBOOL         shift and go to state 94
    ID              shift and go to state 91

    expresion                      shift and go to state 143
    term                           shift and go to state 93
    constant                       shift and go to state 90
    functioncall                   shift and go to state 89
    exp                            shift and go to state 97
    factor                         shift and go to state 88

state 121

    (46) write2 -> expresion DOT . write2
    (44) write2 -> . expresion
    (45) write2 -> . CTESTRING
    (46) write2 -> . expresion DOT write2
    (47) write2 -> . CTESTRING DOT write2
    (36) expresion -> . exp
    (37) expresion -> . exp LESSTHAN exp
    (38) expresion -> . exp GREATERTHAN exp
    (39) expresion -> . exp BETWEEN exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . ID
    (6) constant -> . functioncall
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    CTESTRING       shift and go to state 85
    PLUS            shift and go to state 87
    MINUS           shift and go to state 86
    LPAREN          shift and go to state 84
    CTEI            shift and go to state 98
    CTEF            shift and go to state 96
    CTEBOOL         shift and go to state 94
    ID              shift and go to state 91

    expresion                      shift and go to state 92
    term                           shift and go to state 93
    constant                       shift and go to state 90
    write2                         shift and go to state 146
    functioncall                   shift and go to state 89
    exp                            shift and go to state 97
    factor                         shift and go to state 88

state 122

    (41) exp -> term PLUS . exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . ID
    (6) constant -> . functioncall
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 87
    MINUS           shift and go to state 86
    LPAREN          shift and go to state 84
    CTEI            shift and go to state 98
    CTEF            shift and go to state 96
    CTESTRING       shift and go to state 102
    CTEBOOL         shift and go to state 94
    ID              shift and go to state 91

    term                           shift and go to state 93
    constant                       shift and go to state 90
    functioncall                   shift and go to state 89
    exp                            shift and go to state 147
    factor                         shift and go to state 88

state 123

    (42) exp -> term MINUS . exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . ID
    (6) constant -> . functioncall
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 87
    MINUS           shift and go to state 86
    LPAREN          shift and go to state 84
    CTEI            shift and go to state 98
    CTEF            shift and go to state 96
    CTESTRING       shift and go to state 102
    CTEBOOL         shift and go to state 94
    ID              shift and go to state 91

    term                           shift and go to state 93
    constant                       shift and go to state 90
    functioncall                   shift and go to state 89
    exp                            shift and go to state 148
    factor                         shift and go to state 88

state 124

    (43) write -> PRINT LPAREN write2 RPAREN . SEMIC

    SEMIC           shift and go to state 149


state 125

    (37) expresion -> exp LESSTHAN . exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . ID
    (6) constant -> . functioncall
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 87
    MINUS           shift and go to state 86
    LPAREN          shift and go to state 84
    CTEI            shift and go to state 98
    CTEF            shift and go to state 96
    CTESTRING       shift and go to state 102
    CTEBOOL         shift and go to state 94
    ID              shift and go to state 91

    term                           shift and go to state 93
    constant                       shift and go to state 90
    functioncall                   shift and go to state 89
    exp                            shift and go to state 150
    factor                         shift and go to state 88

state 126

    (38) expresion -> exp GREATERTHAN . exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . ID
    (6) constant -> . functioncall
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 87
    MINUS           shift and go to state 86
    LPAREN          shift and go to state 84
    CTEI            shift and go to state 98
    CTEF            shift and go to state 96
    CTESTRING       shift and go to state 102
    CTEBOOL         shift and go to state 94
    ID              shift and go to state 91

    term                           shift and go to state 93
    constant                       shift and go to state 90
    functioncall                   shift and go to state 89
    exp                            shift and go to state 151
    factor                         shift and go to state 88

state 127

    (39) expresion -> exp BETWEEN . exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . ID
    (6) constant -> . functioncall
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 87
    MINUS           shift and go to state 86
    LPAREN          shift and go to state 84
    CTEI            shift and go to state 98
    CTEF            shift and go to state 96
    CTESTRING       shift and go to state 102
    CTEBOOL         shift and go to state 94
    ID              shift and go to state 91

    term                           shift and go to state 93
    constant                       shift and go to state 90
    functioncall                   shift and go to state 89
    exp                            shift and go to state 152
    factor                         shift and go to state 88

state 128

    (20) for -> FOR ID IN DOT . ID LBRACKET statement RBRACKET

    ID              shift and go to state 153


state 129

    (48) asign -> ID EQUALS expresiones SEMIC .

    ID              reduce using rule 48 (asign -> ID EQUALS expresiones SEMIC .)
    IF              reduce using rule 48 (asign -> ID EQUALS expresiones SEMIC .)
    PRINT           reduce using rule 48 (asign -> ID EQUALS expresiones SEMIC .)
    MIN             reduce using rule 48 (asign -> ID EQUALS expresiones SEMIC .)
    MAX             reduce using rule 48 (asign -> ID EQUALS expresiones SEMIC .)
    RETURN          reduce using rule 48 (asign -> ID EQUALS expresiones SEMIC .)
    FOR             reduce using rule 48 (asign -> ID EQUALS expresiones SEMIC .)
    RCURLY          reduce using rule 48 (asign -> ID EQUALS expresiones SEMIC .)
    SEMIC           reduce using rule 48 (asign -> ID EQUALS expresiones SEMIC .)
    ELSE            reduce using rule 48 (asign -> ID EQUALS expresiones SEMIC .)
    RBRACKET        reduce using rule 48 (asign -> ID EQUALS expresiones SEMIC .)


state 130

    (34) expresiones -> expresion COMMA . expresiones
    (34) expresiones -> . expresion COMMA expresiones
    (35) expresiones -> . expresion
    (36) expresion -> . exp
    (37) expresion -> . exp LESSTHAN exp
    (38) expresion -> . exp GREATERTHAN exp
    (39) expresion -> . exp BETWEEN exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . ID
    (6) constant -> . functioncall
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 87
    MINUS           shift and go to state 86
    LPAREN          shift and go to state 84
    CTEI            shift and go to state 98
    CTEF            shift and go to state 96
    CTESTRING       shift and go to state 102
    CTEBOOL         shift and go to state 94
    ID              shift and go to state 91

    expresion                      shift and go to state 101
    expresiones                    shift and go to state 154
    constant                       shift and go to state 90
    term                           shift and go to state 93
    functioncall                   shift and go to state 89
    exp                            shift and go to state 97
    factor                         shift and go to state 88

state 131

    (32) condition -> IF LPAREN expresion RPAREN . block SEMIC
    (33) condition -> IF LPAREN expresion RPAREN . block ELSE block SEMIC
    (62) block -> . block2
    (63) block -> . LCURLY RCURLY
    (64) block2 -> . statement block2
    (65) block2 -> . statement
    (66) block2 -> . empty
    (49) statement -> . asign
    (50) statement -> . condition
    (51) statement -> . write
    (52) statement -> . optimize
    (53) statement -> . loop
    (54) statement -> . return
    (90) empty -> .
    (48) asign -> . ID EQUALS expresiones SEMIC
    (32) condition -> . IF LPAREN expresion RPAREN block SEMIC
    (33) condition -> . IF LPAREN expresion RPAREN block ELSE block SEMIC
    (43) write -> . PRINT LPAREN write2 RPAREN SEMIC
    (15) optimize -> . MIN EQUALS restrictions
    (16) optimize -> . MAX EQUALS restrictions
    (55) loop -> . for
    (56) return -> . RETURN asign
    (20) for -> . FOR ID IN DOT ID LBRACKET statement RBRACKET

    LCURLY          shift and go to state 156
    SEMIC           reduce using rule 90 (empty -> .)
    ELSE            reduce using rule 90 (empty -> .)
    ID              shift and go to state 48
    IF              shift and go to state 50
    PRINT           shift and go to state 40
    MIN             shift and go to state 39
    MAX             shift and go to state 51
    RETURN          shift and go to state 37
    FOR             shift and go to state 47

    return                         shift and go to state 46
    block2                         shift and go to state 155
    for                            shift and go to state 41
    condition                      shift and go to state 49
    asign                          shift and go to state 52
    write                          shift and go to state 43
    block                          shift and go to state 157
    statement                      shift and go to state 44
    loop                           shift and go to state 53
    optimize                       shift and go to state 42
    empty                          shift and go to state 45

state 132

    (57) function -> FUNC ID LPAREN manyargs RPAREN LCURLY varsdata block2 . RCURLY

    RCURLY          shift and go to state 158


state 133

    (71) matrix -> LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET .

    POINTS          reduce using rule 71 (matrix -> LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET .)


state 134

    (14) asignlist -> asignmany .

    RCURLY          reduce using rule 14 (asignlist -> asignmany .)


state 135

    (11) asignmany -> asign SEMIC asignlist .

    RCURLY          reduce using rule 11 (asignmany -> asign SEMIC asignlist .)


state 136

    (13) asignlist -> empty .

    RCURLY          reduce using rule 13 (asignlist -> empty .)


state 137

    (24) sum -> SUM LPAREN . ID POINTS expresion RPAREN

    ID              shift and go to state 159


state 138

    (19) restrictions2 -> sum SEMIC . forlist
    (21) forlist -> . for SEMIC lfor
    (20) for -> . FOR ID IN DOT ID LBRACKET statement RBRACKET

    FOR             shift and go to state 47

    forlist                        shift and go to state 161
    for                            shift and go to state 160

state 139

    (28) factor -> LPAREN expresion RPAREN .

    STAR            reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    SLASH           reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    PLUS            reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    MINUS           reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    LESSTHAN        reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    GREATERTHAN     reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    BETWEEN         reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    DOT             reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    RPAREN          reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    COMMA           reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    SEMIC           reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    ID              reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    IF              reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    PRINT           reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    MIN             reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    MAX             reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    RETURN          reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    FOR             reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    RCURLY          reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    ELSE            reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    RBRACKET        reduce using rule 28 (factor -> LPAREN expresion RPAREN .)


state 140

    (47) write2 -> CTESTRING DOT write2 .

    RPAREN          reduce using rule 47 (write2 -> CTESTRING DOT write2 .)


state 141

    (30) term -> factor STAR term .

    PLUS            reduce using rule 30 (term -> factor STAR term .)
    MINUS           reduce using rule 30 (term -> factor STAR term .)
    DOT             reduce using rule 30 (term -> factor STAR term .)
    RPAREN          reduce using rule 30 (term -> factor STAR term .)
    COMMA           reduce using rule 30 (term -> factor STAR term .)
    SEMIC           reduce using rule 30 (term -> factor STAR term .)
    ID              reduce using rule 30 (term -> factor STAR term .)
    IF              reduce using rule 30 (term -> factor STAR term .)
    PRINT           reduce using rule 30 (term -> factor STAR term .)
    MIN             reduce using rule 30 (term -> factor STAR term .)
    MAX             reduce using rule 30 (term -> factor STAR term .)
    RETURN          reduce using rule 30 (term -> factor STAR term .)
    FOR             reduce using rule 30 (term -> factor STAR term .)
    RCURLY          reduce using rule 30 (term -> factor STAR term .)
    ELSE            reduce using rule 30 (term -> factor STAR term .)
    RBRACKET        reduce using rule 30 (term -> factor STAR term .)
    LESSTHAN        reduce using rule 30 (term -> factor STAR term .)
    GREATERTHAN     reduce using rule 30 (term -> factor STAR term .)
    BETWEEN         reduce using rule 30 (term -> factor STAR term .)


state 142

    (31) term -> factor SLASH term .

    PLUS            reduce using rule 31 (term -> factor SLASH term .)
    MINUS           reduce using rule 31 (term -> factor SLASH term .)
    DOT             reduce using rule 31 (term -> factor SLASH term .)
    RPAREN          reduce using rule 31 (term -> factor SLASH term .)
    COMMA           reduce using rule 31 (term -> factor SLASH term .)
    SEMIC           reduce using rule 31 (term -> factor SLASH term .)
    ID              reduce using rule 31 (term -> factor SLASH term .)
    IF              reduce using rule 31 (term -> factor SLASH term .)
    PRINT           reduce using rule 31 (term -> factor SLASH term .)
    MIN             reduce using rule 31 (term -> factor SLASH term .)
    MAX             reduce using rule 31 (term -> factor SLASH term .)
    RETURN          reduce using rule 31 (term -> factor SLASH term .)
    FOR             reduce using rule 31 (term -> factor SLASH term .)
    RCURLY          reduce using rule 31 (term -> factor SLASH term .)
    ELSE            reduce using rule 31 (term -> factor SLASH term .)
    RBRACKET        reduce using rule 31 (term -> factor SLASH term .)
    LESSTHAN        reduce using rule 31 (term -> factor SLASH term .)
    GREATERTHAN     reduce using rule 31 (term -> factor SLASH term .)
    BETWEEN         reduce using rule 31 (term -> factor SLASH term .)


state 143

    (7) functioncall -> ID LPAREN expresion . RPAREN

    RPAREN          shift and go to state 162


state 144

    (9) functioncall -> ID LPAREN CTEF . RPAREN
    (2) constant -> CTEF .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 163
    STAR            reduce using rule 2 (constant -> CTEF .)
    SLASH           reduce using rule 2 (constant -> CTEF .)
    PLUS            reduce using rule 2 (constant -> CTEF .)
    MINUS           reduce using rule 2 (constant -> CTEF .)
    LESSTHAN        reduce using rule 2 (constant -> CTEF .)
    GREATERTHAN     reduce using rule 2 (constant -> CTEF .)
    BETWEEN         reduce using rule 2 (constant -> CTEF .)

  ! RPAREN          [ reduce using rule 2 (constant -> CTEF .) ]


state 145

    (8) functioncall -> ID LPAREN CTEI . RPAREN
    (1) constant -> CTEI .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 164
    STAR            reduce using rule 1 (constant -> CTEI .)
    SLASH           reduce using rule 1 (constant -> CTEI .)
    PLUS            reduce using rule 1 (constant -> CTEI .)
    MINUS           reduce using rule 1 (constant -> CTEI .)
    LESSTHAN        reduce using rule 1 (constant -> CTEI .)
    GREATERTHAN     reduce using rule 1 (constant -> CTEI .)
    BETWEEN         reduce using rule 1 (constant -> CTEI .)

  ! RPAREN          [ reduce using rule 1 (constant -> CTEI .) ]


state 146

    (46) write2 -> expresion DOT write2 .

    RPAREN          reduce using rule 46 (write2 -> expresion DOT write2 .)


state 147

    (41) exp -> term PLUS exp .

    LESSTHAN        reduce using rule 41 (exp -> term PLUS exp .)
    GREATERTHAN     reduce using rule 41 (exp -> term PLUS exp .)
    BETWEEN         reduce using rule 41 (exp -> term PLUS exp .)
    DOT             reduce using rule 41 (exp -> term PLUS exp .)
    RPAREN          reduce using rule 41 (exp -> term PLUS exp .)
    COMMA           reduce using rule 41 (exp -> term PLUS exp .)
    SEMIC           reduce using rule 41 (exp -> term PLUS exp .)
    ID              reduce using rule 41 (exp -> term PLUS exp .)
    IF              reduce using rule 41 (exp -> term PLUS exp .)
    PRINT           reduce using rule 41 (exp -> term PLUS exp .)
    MIN             reduce using rule 41 (exp -> term PLUS exp .)
    MAX             reduce using rule 41 (exp -> term PLUS exp .)
    RETURN          reduce using rule 41 (exp -> term PLUS exp .)
    FOR             reduce using rule 41 (exp -> term PLUS exp .)
    RCURLY          reduce using rule 41 (exp -> term PLUS exp .)
    ELSE            reduce using rule 41 (exp -> term PLUS exp .)
    RBRACKET        reduce using rule 41 (exp -> term PLUS exp .)


state 148

    (42) exp -> term MINUS exp .

    LESSTHAN        reduce using rule 42 (exp -> term MINUS exp .)
    GREATERTHAN     reduce using rule 42 (exp -> term MINUS exp .)
    BETWEEN         reduce using rule 42 (exp -> term MINUS exp .)
    DOT             reduce using rule 42 (exp -> term MINUS exp .)
    RPAREN          reduce using rule 42 (exp -> term MINUS exp .)
    COMMA           reduce using rule 42 (exp -> term MINUS exp .)
    SEMIC           reduce using rule 42 (exp -> term MINUS exp .)
    ID              reduce using rule 42 (exp -> term MINUS exp .)
    IF              reduce using rule 42 (exp -> term MINUS exp .)
    PRINT           reduce using rule 42 (exp -> term MINUS exp .)
    MIN             reduce using rule 42 (exp -> term MINUS exp .)
    MAX             reduce using rule 42 (exp -> term MINUS exp .)
    RETURN          reduce using rule 42 (exp -> term MINUS exp .)
    FOR             reduce using rule 42 (exp -> term MINUS exp .)
    RCURLY          reduce using rule 42 (exp -> term MINUS exp .)
    ELSE            reduce using rule 42 (exp -> term MINUS exp .)
    RBRACKET        reduce using rule 42 (exp -> term MINUS exp .)


state 149

    (43) write -> PRINT LPAREN write2 RPAREN SEMIC .

    ID              reduce using rule 43 (write -> PRINT LPAREN write2 RPAREN SEMIC .)
    IF              reduce using rule 43 (write -> PRINT LPAREN write2 RPAREN SEMIC .)
    PRINT           reduce using rule 43 (write -> PRINT LPAREN write2 RPAREN SEMIC .)
    MIN             reduce using rule 43 (write -> PRINT LPAREN write2 RPAREN SEMIC .)
    MAX             reduce using rule 43 (write -> PRINT LPAREN write2 RPAREN SEMIC .)
    RETURN          reduce using rule 43 (write -> PRINT LPAREN write2 RPAREN SEMIC .)
    FOR             reduce using rule 43 (write -> PRINT LPAREN write2 RPAREN SEMIC .)
    SEMIC           reduce using rule 43 (write -> PRINT LPAREN write2 RPAREN SEMIC .)
    RBRACKET        reduce using rule 43 (write -> PRINT LPAREN write2 RPAREN SEMIC .)
    RCURLY          reduce using rule 43 (write -> PRINT LPAREN write2 RPAREN SEMIC .)
    ELSE            reduce using rule 43 (write -> PRINT LPAREN write2 RPAREN SEMIC .)


state 150

    (37) expresion -> exp LESSTHAN exp .

    DOT             reduce using rule 37 (expresion -> exp LESSTHAN exp .)
    RPAREN          reduce using rule 37 (expresion -> exp LESSTHAN exp .)
    COMMA           reduce using rule 37 (expresion -> exp LESSTHAN exp .)
    SEMIC           reduce using rule 37 (expresion -> exp LESSTHAN exp .)
    ID              reduce using rule 37 (expresion -> exp LESSTHAN exp .)
    IF              reduce using rule 37 (expresion -> exp LESSTHAN exp .)
    PRINT           reduce using rule 37 (expresion -> exp LESSTHAN exp .)
    MIN             reduce using rule 37 (expresion -> exp LESSTHAN exp .)
    MAX             reduce using rule 37 (expresion -> exp LESSTHAN exp .)
    RETURN          reduce using rule 37 (expresion -> exp LESSTHAN exp .)
    FOR             reduce using rule 37 (expresion -> exp LESSTHAN exp .)
    RCURLY          reduce using rule 37 (expresion -> exp LESSTHAN exp .)
    ELSE            reduce using rule 37 (expresion -> exp LESSTHAN exp .)
    RBRACKET        reduce using rule 37 (expresion -> exp LESSTHAN exp .)


state 151

    (38) expresion -> exp GREATERTHAN exp .

    DOT             reduce using rule 38 (expresion -> exp GREATERTHAN exp .)
    RPAREN          reduce using rule 38 (expresion -> exp GREATERTHAN exp .)
    COMMA           reduce using rule 38 (expresion -> exp GREATERTHAN exp .)
    SEMIC           reduce using rule 38 (expresion -> exp GREATERTHAN exp .)
    ID              reduce using rule 38 (expresion -> exp GREATERTHAN exp .)
    IF              reduce using rule 38 (expresion -> exp GREATERTHAN exp .)
    PRINT           reduce using rule 38 (expresion -> exp GREATERTHAN exp .)
    MIN             reduce using rule 38 (expresion -> exp GREATERTHAN exp .)
    MAX             reduce using rule 38 (expresion -> exp GREATERTHAN exp .)
    RETURN          reduce using rule 38 (expresion -> exp GREATERTHAN exp .)
    FOR             reduce using rule 38 (expresion -> exp GREATERTHAN exp .)
    RCURLY          reduce using rule 38 (expresion -> exp GREATERTHAN exp .)
    ELSE            reduce using rule 38 (expresion -> exp GREATERTHAN exp .)
    RBRACKET        reduce using rule 38 (expresion -> exp GREATERTHAN exp .)


state 152

    (39) expresion -> exp BETWEEN exp .

    DOT             reduce using rule 39 (expresion -> exp BETWEEN exp .)
    RPAREN          reduce using rule 39 (expresion -> exp BETWEEN exp .)
    COMMA           reduce using rule 39 (expresion -> exp BETWEEN exp .)
    SEMIC           reduce using rule 39 (expresion -> exp BETWEEN exp .)
    ID              reduce using rule 39 (expresion -> exp BETWEEN exp .)
    IF              reduce using rule 39 (expresion -> exp BETWEEN exp .)
    PRINT           reduce using rule 39 (expresion -> exp BETWEEN exp .)
    MIN             reduce using rule 39 (expresion -> exp BETWEEN exp .)
    MAX             reduce using rule 39 (expresion -> exp BETWEEN exp .)
    RETURN          reduce using rule 39 (expresion -> exp BETWEEN exp .)
    FOR             reduce using rule 39 (expresion -> exp BETWEEN exp .)
    RCURLY          reduce using rule 39 (expresion -> exp BETWEEN exp .)
    ELSE            reduce using rule 39 (expresion -> exp BETWEEN exp .)
    RBRACKET        reduce using rule 39 (expresion -> exp BETWEEN exp .)


state 153

    (20) for -> FOR ID IN DOT ID . LBRACKET statement RBRACKET

    LBRACKET        shift and go to state 165


state 154

    (34) expresiones -> expresion COMMA expresiones .

    SEMIC           reduce using rule 34 (expresiones -> expresion COMMA expresiones .)


state 155

    (62) block -> block2 .

    SEMIC           reduce using rule 62 (block -> block2 .)
    ELSE            reduce using rule 62 (block -> block2 .)


state 156

    (63) block -> LCURLY . RCURLY

    RCURLY          shift and go to state 166


state 157

    (32) condition -> IF LPAREN expresion RPAREN block . SEMIC
    (33) condition -> IF LPAREN expresion RPAREN block . ELSE block SEMIC

    SEMIC           shift and go to state 167
    ELSE            shift and go to state 168


state 158

    (57) function -> FUNC ID LPAREN manyargs RPAREN LCURLY varsdata block2 RCURLY .

    MODEL           reduce using rule 57 (function -> FUNC ID LPAREN manyargs RPAREN LCURLY varsdata block2 RCURLY .)


state 159

    (24) sum -> SUM LPAREN ID . POINTS expresion RPAREN

    POINTS          shift and go to state 169


state 160

    (21) forlist -> for . SEMIC lfor

    SEMIC           shift and go to state 170


state 161

    (19) restrictions2 -> sum SEMIC forlist .

    ID              reduce using rule 19 (restrictions2 -> sum SEMIC forlist .)
    IF              reduce using rule 19 (restrictions2 -> sum SEMIC forlist .)
    PRINT           reduce using rule 19 (restrictions2 -> sum SEMIC forlist .)
    MIN             reduce using rule 19 (restrictions2 -> sum SEMIC forlist .)
    MAX             reduce using rule 19 (restrictions2 -> sum SEMIC forlist .)
    RETURN          reduce using rule 19 (restrictions2 -> sum SEMIC forlist .)
    FOR             reduce using rule 19 (restrictions2 -> sum SEMIC forlist .)
    RCURLY          reduce using rule 19 (restrictions2 -> sum SEMIC forlist .)
    SEMIC           reduce using rule 19 (restrictions2 -> sum SEMIC forlist .)
    ELSE            reduce using rule 19 (restrictions2 -> sum SEMIC forlist .)
    RBRACKET        reduce using rule 19 (restrictions2 -> sum SEMIC forlist .)


state 162

    (7) functioncall -> ID LPAREN expresion RPAREN .

    STAR            reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    SLASH           reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    PLUS            reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    MINUS           reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    LESSTHAN        reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    GREATERTHAN     reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    BETWEEN         reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    COMMA           reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    SEMIC           reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    DOT             reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    RPAREN          reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    ID              reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    IF              reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    PRINT           reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    MIN             reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    MAX             reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    RETURN          reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    FOR             reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    RCURLY          reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    ELSE            reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    RBRACKET        reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)


state 163

    (9) functioncall -> ID LPAREN CTEF RPAREN .

    STAR            reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    SLASH           reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    PLUS            reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    MINUS           reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    LESSTHAN        reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    GREATERTHAN     reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    BETWEEN         reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    COMMA           reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    SEMIC           reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    DOT             reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    RPAREN          reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    ID              reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    IF              reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    PRINT           reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    MIN             reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    MAX             reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    RETURN          reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    FOR             reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    RCURLY          reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    ELSE            reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    RBRACKET        reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)


state 164

    (8) functioncall -> ID LPAREN CTEI RPAREN .

    STAR            reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    SLASH           reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    PLUS            reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    MINUS           reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    LESSTHAN        reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    GREATERTHAN     reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    BETWEEN         reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    COMMA           reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    SEMIC           reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    DOT             reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    RPAREN          reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    ID              reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    IF              reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    PRINT           reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    MIN             reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    MAX             reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    RETURN          reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    FOR             reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    RCURLY          reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    ELSE            reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    RBRACKET        reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)


state 165

    (20) for -> FOR ID IN DOT ID LBRACKET . statement RBRACKET
    (49) statement -> . asign
    (50) statement -> . condition
    (51) statement -> . write
    (52) statement -> . optimize
    (53) statement -> . loop
    (54) statement -> . return
    (48) asign -> . ID EQUALS expresiones SEMIC
    (32) condition -> . IF LPAREN expresion RPAREN block SEMIC
    (33) condition -> . IF LPAREN expresion RPAREN block ELSE block SEMIC
    (43) write -> . PRINT LPAREN write2 RPAREN SEMIC
    (15) optimize -> . MIN EQUALS restrictions
    (16) optimize -> . MAX EQUALS restrictions
    (55) loop -> . for
    (56) return -> . RETURN asign
    (20) for -> . FOR ID IN DOT ID LBRACKET statement RBRACKET

    ID              shift and go to state 48
    IF              shift and go to state 50
    PRINT           shift and go to state 40
    MIN             shift and go to state 39
    MAX             shift and go to state 51
    RETURN          shift and go to state 37
    FOR             shift and go to state 47

    return                         shift and go to state 46
    for                            shift and go to state 41
    asign                          shift and go to state 52
    write                          shift and go to state 43
    condition                      shift and go to state 49
    statement                      shift and go to state 171
    optimize                       shift and go to state 42
    loop                           shift and go to state 53

state 166

    (63) block -> LCURLY RCURLY .

    SEMIC           reduce using rule 63 (block -> LCURLY RCURLY .)
    ELSE            reduce using rule 63 (block -> LCURLY RCURLY .)


state 167

    (32) condition -> IF LPAREN expresion RPAREN block SEMIC .

    RBRACKET        reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)
    ID              reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)
    IF              reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)
    PRINT           reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)
    MIN             reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)
    MAX             reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)
    RETURN          reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)
    FOR             reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)
    RCURLY          reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)
    SEMIC           reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)
    ELSE            reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)


state 168

    (33) condition -> IF LPAREN expresion RPAREN block ELSE . block SEMIC
    (62) block -> . block2
    (63) block -> . LCURLY RCURLY
    (64) block2 -> . statement block2
    (65) block2 -> . statement
    (66) block2 -> . empty
    (49) statement -> . asign
    (50) statement -> . condition
    (51) statement -> . write
    (52) statement -> . optimize
    (53) statement -> . loop
    (54) statement -> . return
    (90) empty -> .
    (48) asign -> . ID EQUALS expresiones SEMIC
    (32) condition -> . IF LPAREN expresion RPAREN block SEMIC
    (33) condition -> . IF LPAREN expresion RPAREN block ELSE block SEMIC
    (43) write -> . PRINT LPAREN write2 RPAREN SEMIC
    (15) optimize -> . MIN EQUALS restrictions
    (16) optimize -> . MAX EQUALS restrictions
    (55) loop -> . for
    (56) return -> . RETURN asign
    (20) for -> . FOR ID IN DOT ID LBRACKET statement RBRACKET

    LCURLY          shift and go to state 156
    SEMIC           reduce using rule 90 (empty -> .)
    ID              shift and go to state 48
    IF              shift and go to state 50
    PRINT           shift and go to state 40
    MIN             shift and go to state 39
    MAX             shift and go to state 51
    RETURN          shift and go to state 37
    FOR             shift and go to state 47

    return                         shift and go to state 46
    block2                         shift and go to state 155
    for                            shift and go to state 41
    condition                      shift and go to state 49
    asign                          shift and go to state 52
    write                          shift and go to state 43
    block                          shift and go to state 172
    statement                      shift and go to state 44
    loop                           shift and go to state 53
    optimize                       shift and go to state 42
    empty                          shift and go to state 45

state 169

    (24) sum -> SUM LPAREN ID POINTS . expresion RPAREN
    (36) expresion -> . exp
    (37) expresion -> . exp LESSTHAN exp
    (38) expresion -> . exp GREATERTHAN exp
    (39) expresion -> . exp BETWEEN exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . ID
    (6) constant -> . functioncall
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 87
    MINUS           shift and go to state 86
    LPAREN          shift and go to state 84
    CTEI            shift and go to state 98
    CTEF            shift and go to state 96
    CTESTRING       shift and go to state 102
    CTEBOOL         shift and go to state 94
    ID              shift and go to state 91

    expresion                      shift and go to state 173
    term                           shift and go to state 93
    constant                       shift and go to state 90
    functioncall                   shift and go to state 89
    exp                            shift and go to state 97
    factor                         shift and go to state 88

state 170

    (21) forlist -> for SEMIC . lfor
    (22) lfor -> . empty
    (23) lfor -> . forlist
    (90) empty -> .
    (21) forlist -> . for SEMIC lfor
    (20) for -> . FOR ID IN DOT ID LBRACKET statement RBRACKET

  ! shift/reduce conflict for FOR resolved as shift
    ID              reduce using rule 90 (empty -> .)
    IF              reduce using rule 90 (empty -> .)
    PRINT           reduce using rule 90 (empty -> .)
    MIN             reduce using rule 90 (empty -> .)
    MAX             reduce using rule 90 (empty -> .)
    RETURN          reduce using rule 90 (empty -> .)
    RCURLY          reduce using rule 90 (empty -> .)
    SEMIC           reduce using rule 90 (empty -> .)
    ELSE            reduce using rule 90 (empty -> .)
    RBRACKET        reduce using rule 90 (empty -> .)
    FOR             shift and go to state 47

  ! FOR             [ reduce using rule 90 (empty -> .) ]

    forlist                        shift and go to state 174
    empty                          shift and go to state 176
    lfor                           shift and go to state 175
    for                            shift and go to state 160

state 171

    (20) for -> FOR ID IN DOT ID LBRACKET statement . RBRACKET

    RBRACKET        shift and go to state 177


state 172

    (33) condition -> IF LPAREN expresion RPAREN block ELSE block . SEMIC

    SEMIC           shift and go to state 178


state 173

    (24) sum -> SUM LPAREN ID POINTS expresion . RPAREN

    RPAREN          shift and go to state 179


state 174

    (23) lfor -> forlist .

    ID              reduce using rule 23 (lfor -> forlist .)
    IF              reduce using rule 23 (lfor -> forlist .)
    PRINT           reduce using rule 23 (lfor -> forlist .)
    MIN             reduce using rule 23 (lfor -> forlist .)
    MAX             reduce using rule 23 (lfor -> forlist .)
    RETURN          reduce using rule 23 (lfor -> forlist .)
    FOR             reduce using rule 23 (lfor -> forlist .)
    RCURLY          reduce using rule 23 (lfor -> forlist .)
    SEMIC           reduce using rule 23 (lfor -> forlist .)
    ELSE            reduce using rule 23 (lfor -> forlist .)
    RBRACKET        reduce using rule 23 (lfor -> forlist .)


state 175

    (21) forlist -> for SEMIC lfor .

    ID              reduce using rule 21 (forlist -> for SEMIC lfor .)
    IF              reduce using rule 21 (forlist -> for SEMIC lfor .)
    PRINT           reduce using rule 21 (forlist -> for SEMIC lfor .)
    MIN             reduce using rule 21 (forlist -> for SEMIC lfor .)
    MAX             reduce using rule 21 (forlist -> for SEMIC lfor .)
    RETURN          reduce using rule 21 (forlist -> for SEMIC lfor .)
    FOR             reduce using rule 21 (forlist -> for SEMIC lfor .)
    RCURLY          reduce using rule 21 (forlist -> for SEMIC lfor .)
    SEMIC           reduce using rule 21 (forlist -> for SEMIC lfor .)
    ELSE            reduce using rule 21 (forlist -> for SEMIC lfor .)
    RBRACKET        reduce using rule 21 (forlist -> for SEMIC lfor .)


state 176

    (22) lfor -> empty .

    ID              reduce using rule 22 (lfor -> empty .)
    IF              reduce using rule 22 (lfor -> empty .)
    PRINT           reduce using rule 22 (lfor -> empty .)
    MIN             reduce using rule 22 (lfor -> empty .)
    MAX             reduce using rule 22 (lfor -> empty .)
    RETURN          reduce using rule 22 (lfor -> empty .)
    FOR             reduce using rule 22 (lfor -> empty .)
    RCURLY          reduce using rule 22 (lfor -> empty .)
    SEMIC           reduce using rule 22 (lfor -> empty .)
    ELSE            reduce using rule 22 (lfor -> empty .)
    RBRACKET        reduce using rule 22 (lfor -> empty .)


state 177

    (20) for -> FOR ID IN DOT ID LBRACKET statement RBRACKET .

    SEMIC           reduce using rule 20 (for -> FOR ID IN DOT ID LBRACKET statement RBRACKET .)
    ID              reduce using rule 20 (for -> FOR ID IN DOT ID LBRACKET statement RBRACKET .)
    IF              reduce using rule 20 (for -> FOR ID IN DOT ID LBRACKET statement RBRACKET .)
    PRINT           reduce using rule 20 (for -> FOR ID IN DOT ID LBRACKET statement RBRACKET .)
    MIN             reduce using rule 20 (for -> FOR ID IN DOT ID LBRACKET statement RBRACKET .)
    MAX             reduce using rule 20 (for -> FOR ID IN DOT ID LBRACKET statement RBRACKET .)
    RETURN          reduce using rule 20 (for -> FOR ID IN DOT ID LBRACKET statement RBRACKET .)
    FOR             reduce using rule 20 (for -> FOR ID IN DOT ID LBRACKET statement RBRACKET .)
    RCURLY          reduce using rule 20 (for -> FOR ID IN DOT ID LBRACKET statement RBRACKET .)
    ELSE            reduce using rule 20 (for -> FOR ID IN DOT ID LBRACKET statement RBRACKET .)
    RBRACKET        reduce using rule 20 (for -> FOR ID IN DOT ID LBRACKET statement RBRACKET .)


state 178

    (33) condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .

    RBRACKET        reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)
    ID              reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)
    IF              reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)
    PRINT           reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)
    MIN             reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)
    MAX             reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)
    RETURN          reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)
    FOR             reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)
    RCURLY          reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)
    SEMIC           reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)
    ELSE            reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)


state 179

    (24) sum -> SUM LPAREN ID POINTS expresion RPAREN .

    SEMIC           reduce using rule 24 (sum -> SUM LPAREN ID POINTS expresion RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for DOT in state 85 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 144 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 145 resolved as shift
WARNING: shift/reduce conflict for FOR in state 170 resolved as shift
WARNING: reduce/reduce conflict in state 44 resolved using rule (block2 -> statement)
WARNING: rejected rule (empty -> <empty>) in state 44
WARNING: reduce/reduce conflict in state 85 resolved using rule (constant -> CTESTRING)
WARNING: rejected rule (write2 -> CTESTRING) in state 85
WARNING: Rule (write2 -> CTESTRING) is never reduced
