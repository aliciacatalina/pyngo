Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     constant -> CTEI
Rule 2     constant -> CTEF
Rule 3     constant -> CTESTRING
Rule 4     constant -> CTEBOOL
Rule 5     constant -> id
Rule 6     constant -> functioncall
Rule 7     functioncall -> ID LPAREN expresion RPAREN
Rule 8     functioncall -> ID LPAREN CTEI RPAREN
Rule 9     functioncall -> ID LPAREN CTEF RPAREN
Rule 10    data -> DATA LCURLY asignmany RCURLY
Rule 11    asignmany -> asign SEMIC asignlist
Rule 12    asignmany -> asign
Rule 13    asignlist -> empty
Rule 14    asignlist -> asignmany
Rule 15    optimize -> MIN EQUALS statement
Rule 16    optimize -> MAX EQUALS statement
Rule 17    restrictions -> WHERE restrictions2
Rule 18    restrictions2 -> expresion
Rule 19    restrictions2 -> sum SEMIC forlist
Rule 20    for -> FOR ID IN DOT ID LCURLY block2 RCURLY
Rule 21    forlist -> for SEMIC lfor
Rule 22    lfor -> empty
Rule 23    lfor -> forlist
Rule 24    sum -> SUM LPAREN ID POINTS expresion RPAREN
Rule 25    factor -> PLUS constant
Rule 26    factor -> MINUS constant
Rule 27    factor -> constant
Rule 28    factor -> LPAREN expresion RPAREN
Rule 29    term -> factor
Rule 30    term -> factor STAR term
Rule 31    term -> factor SLASH term
Rule 32    condition -> IF LPAREN expresion RPAREN block SEMIC
Rule 33    condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC
Rule 34    expresiones -> expresion COMMA expresiones
Rule 35    expresiones -> expresion
Rule 36    expresion -> exp
Rule 37    expresion -> exp LESSTHAN exp
Rule 38    expresion -> exp GREATERTHAN exp
Rule 39    expresion -> exp BETWEEN exp
Rule 40    exp -> term
Rule 41    exp -> term PLUS exp
Rule 42    exp -> term MINUS exp
Rule 43    write -> PRINT LPAREN write2 RPAREN SEMIC
Rule 44    write2 -> expresion
Rule 45    write2 -> CTESTRING
Rule 46    write2 -> expresion DOT write2
Rule 47    write2 -> CTESTRING DOT write2
Rule 48    asign -> ID EQUALS expresiones SEMIC
Rule 49    statement -> asign
Rule 50    statement -> condition
Rule 51    statement -> write
Rule 52    statement -> optimize
Rule 53    statement -> for
Rule 54    statement -> return
Rule 55    loop -> for
Rule 56    return -> RETURN asign
Rule 57    function -> FUNC ID LPAREN manyargs RPAREN LCURLY varsdata block2 RCURLY
Rule 58    manyargs -> empty
Rule 59    manyargs -> tipo ID liargs
Rule 60    liargs -> empty
Rule 61    liargs -> COMMA manyargs
Rule 62    block -> block2
Rule 63    block -> LCURLY RCURLY
Rule 64    block2 -> statement block2
Rule 65    block2 -> statement
Rule 66    block2 -> empty
Rule 67    tipo -> TINT
Rule 68    tipo -> TFLOAT
Rule 69    tipo -> TBOOL
Rule 70    vars -> VARS LCURLY listofvars RCURLY
Rule 71    matrix -> LBRACKET expresion RBRACKET LBRACKET expresion RBRACKET
Rule 72    array -> LBRACKET expresion RBRACKET
Rule 73    id -> ID array
Rule 74    id -> ID matrix
Rule 75    id -> ID
Rule 76    declaracion -> tipo array
Rule 77    declaracion -> tipo matrix
Rule 78    declaracion -> tipo
Rule 79    lid -> COMMA listofids
Rule 80    lid -> empty
Rule 81    listofids -> ID lid
Rule 82    lvars -> listofvars
Rule 83    lvars -> empty
Rule 84    listofvars -> declaracion POINTS listofids SEMIC lvars
Rule 85    varsdata -> vars data
Rule 86    varsdata -> empty
Rule 87    varsdata -> vars
Rule 88    declarefunc -> function
Rule 89    declarefunc -> empty
Rule 90    declarevars -> vars
Rule 91    declarevars -> empty
Rule 92    program -> declarevars declarefunc MODEL LCURLY varsdata block2 RCURLY
Rule 93    empty -> <empty>

Terminals, with rules where they appear

BETWEEN              : 39
COMMA                : 34 61 79
CTEBOOL              : 4
CTEF                 : 2 9
CTEI                 : 1 8
CTESTRING            : 3 45 47
DATA                 : 10
DOT                  : 20 46 47
ELSE                 : 33
EQUALS               : 15 16 48
FOR                  : 20
FUNC                 : 57
GREATERTHAN          : 38
ID                   : 7 8 9 20 20 24 48 57 59 73 74 75 81
IF                   : 32 33
IN                   : 20
LBRACKET             : 71 71 72
LCURLY               : 10 20 57 63 70 92
LESSTHAN             : 37
LPAREN               : 7 8 9 24 28 32 33 43 57
MAX                  : 16
MIN                  : 15
MINUS                : 26 42
MODEL                : 92
PLUS                 : 25 41
POINTS               : 24 84
PRINT                : 43
RBRACKET             : 71 71 72
RCURLY               : 10 20 57 63 70 92
RETURN               : 56
RPAREN               : 7 8 9 24 28 32 33 43 57
SEMIC                : 11 19 21 32 33 43 48 84
SLASH                : 31
STAR                 : 30
SUM                  : 24
TBOOL                : 69
TFLOAT               : 68
TINT                 : 67
VARS                 : 70
WHERE                : 17
error                : 

Nonterminals, with rules where they appear

array                : 73 76
asign                : 11 12 49 56
asignlist            : 11
asignmany            : 10 14
block                : 32 33 33
block2               : 20 57 62 64 92
condition            : 50
constant             : 25 26 27
data                 : 85
declaracion          : 84
declarefunc          : 92
declarevars          : 92
empty                : 13 22 58 60 66 80 83 86 89 91
exp                  : 36 37 37 38 38 39 39 41 42
expresion            : 7 18 24 28 32 33 34 35 44 46 71 71 72
expresiones          : 34 48
factor               : 29 30 31
for                  : 21 53 55
forlist              : 19 23
function             : 88
functioncall         : 6
id                   : 5
lfor                 : 21
liargs               : 59
lid                  : 81
listofids            : 79 84
listofvars           : 70 82
loop                 : 
lvars                : 84
manyargs             : 57 61
matrix               : 74 77
optimize             : 52
program              : 0
restrictions         : 
restrictions2        : 17
return               : 54
statement            : 15 16 64 65
sum                  : 19
term                 : 30 31 40 41 42
tipo                 : 59 76 77 78
vars                 : 85 87 90
varsdata             : 57 92
write                : 51
write2               : 43 46 47

Parsing method: LALR

state 0

    (0) S' -> . program
    (92) program -> . declarevars declarefunc MODEL LCURLY varsdata block2 RCURLY
    (90) declarevars -> . vars
    (91) declarevars -> . empty
    (70) vars -> . VARS LCURLY listofvars RCURLY
    (93) empty -> .

    VARS            shift and go to state 4
    FUNC            reduce using rule 93 (empty -> .)
    MODEL           reduce using rule 93 (empty -> .)

    program                        shift and go to state 1
    declarevars                    shift and go to state 2
    vars                           shift and go to state 3
    empty                          shift and go to state 5

state 1

    (0) S' -> program .



state 2

    (92) program -> declarevars . declarefunc MODEL LCURLY varsdata block2 RCURLY
    (88) declarefunc -> . function
    (89) declarefunc -> . empty
    (57) function -> . FUNC ID LPAREN manyargs RPAREN LCURLY varsdata block2 RCURLY
    (93) empty -> .

    FUNC            shift and go to state 8
    MODEL           reduce using rule 93 (empty -> .)

    function                       shift and go to state 6
    declarefunc                    shift and go to state 7
    empty                          shift and go to state 9

state 3

    (90) declarevars -> vars .

    FUNC            reduce using rule 90 (declarevars -> vars .)
    MODEL           reduce using rule 90 (declarevars -> vars .)


state 4

    (70) vars -> VARS . LCURLY listofvars RCURLY

    LCURLY          shift and go to state 10


state 5

    (91) declarevars -> empty .

    FUNC            reduce using rule 91 (declarevars -> empty .)
    MODEL           reduce using rule 91 (declarevars -> empty .)


state 6

    (88) declarefunc -> function .

    MODEL           reduce using rule 88 (declarefunc -> function .)


state 7

    (92) program -> declarevars declarefunc . MODEL LCURLY varsdata block2 RCURLY

    MODEL           shift and go to state 11


state 8

    (57) function -> FUNC . ID LPAREN manyargs RPAREN LCURLY varsdata block2 RCURLY

    ID              shift and go to state 12


state 9

    (89) declarefunc -> empty .

    MODEL           reduce using rule 89 (declarefunc -> empty .)


state 10

    (70) vars -> VARS LCURLY . listofvars RCURLY
    (84) listofvars -> . declaracion POINTS listofids SEMIC lvars
    (76) declaracion -> . tipo array
    (77) declaracion -> . tipo matrix
    (78) declaracion -> . tipo
    (67) tipo -> . TINT
    (68) tipo -> . TFLOAT
    (69) tipo -> . TBOOL

    TINT            shift and go to state 13
    TFLOAT          shift and go to state 17
    TBOOL           shift and go to state 16

    tipo                           shift and go to state 14
    listofvars                     shift and go to state 15
    declaracion                    shift and go to state 18

state 11

    (92) program -> declarevars declarefunc MODEL . LCURLY varsdata block2 RCURLY

    LCURLY          shift and go to state 19


state 12

    (57) function -> FUNC ID . LPAREN manyargs RPAREN LCURLY varsdata block2 RCURLY

    LPAREN          shift and go to state 20


state 13

    (67) tipo -> TINT .

    LBRACKET        reduce using rule 67 (tipo -> TINT .)
    POINTS          reduce using rule 67 (tipo -> TINT .)
    ID              reduce using rule 67 (tipo -> TINT .)


state 14

    (76) declaracion -> tipo . array
    (77) declaracion -> tipo . matrix
    (78) declaracion -> tipo .
    (72) array -> . LBRACKET expresion RBRACKET
    (71) matrix -> . LBRACKET expresion RBRACKET LBRACKET expresion RBRACKET

    POINTS          reduce using rule 78 (declaracion -> tipo .)
    LBRACKET        shift and go to state 22

    array                          shift and go to state 23
    matrix                         shift and go to state 21

state 15

    (70) vars -> VARS LCURLY listofvars . RCURLY

    RCURLY          shift and go to state 24


state 16

    (69) tipo -> TBOOL .

    LBRACKET        reduce using rule 69 (tipo -> TBOOL .)
    POINTS          reduce using rule 69 (tipo -> TBOOL .)
    ID              reduce using rule 69 (tipo -> TBOOL .)


state 17

    (68) tipo -> TFLOAT .

    LBRACKET        reduce using rule 68 (tipo -> TFLOAT .)
    POINTS          reduce using rule 68 (tipo -> TFLOAT .)
    ID              reduce using rule 68 (tipo -> TFLOAT .)


state 18

    (84) listofvars -> declaracion . POINTS listofids SEMIC lvars

    POINTS          shift and go to state 25


state 19

    (92) program -> declarevars declarefunc MODEL LCURLY . varsdata block2 RCURLY
    (85) varsdata -> . vars data
    (86) varsdata -> . empty
    (87) varsdata -> . vars
    (70) vars -> . VARS LCURLY listofvars RCURLY
    (93) empty -> .

    VARS            shift and go to state 4
    ID              reduce using rule 93 (empty -> .)
    IF              reduce using rule 93 (empty -> .)
    PRINT           reduce using rule 93 (empty -> .)
    MIN             reduce using rule 93 (empty -> .)
    MAX             reduce using rule 93 (empty -> .)
    FOR             reduce using rule 93 (empty -> .)
    RETURN          reduce using rule 93 (empty -> .)
    RCURLY          reduce using rule 93 (empty -> .)

    vars                           shift and go to state 26
    varsdata                       shift and go to state 27
    empty                          shift and go to state 28

state 20

    (57) function -> FUNC ID LPAREN . manyargs RPAREN LCURLY varsdata block2 RCURLY
    (58) manyargs -> . empty
    (59) manyargs -> . tipo ID liargs
    (93) empty -> .
    (67) tipo -> . TINT
    (68) tipo -> . TFLOAT
    (69) tipo -> . TBOOL

    RPAREN          reduce using rule 93 (empty -> .)
    TINT            shift and go to state 13
    TFLOAT          shift and go to state 17
    TBOOL           shift and go to state 16

    tipo                           shift and go to state 29
    manyargs                       shift and go to state 30
    empty                          shift and go to state 31

state 21

    (77) declaracion -> tipo matrix .

    POINTS          reduce using rule 77 (declaracion -> tipo matrix .)


state 22

    (72) array -> LBRACKET . expresion RBRACKET
    (71) matrix -> LBRACKET . expresion RBRACKET LBRACKET expresion RBRACKET
    (36) expresion -> . exp
    (37) expresion -> . exp LESSTHAN exp
    (38) expresion -> . exp GREATERTHAN exp
    (39) expresion -> . exp BETWEEN exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . id
    (6) constant -> . functioncall
    (73) id -> . ID array
    (74) id -> . ID matrix
    (75) id -> . ID
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 36
    MINUS           shift and go to state 35
    LPAREN          shift and go to state 32
    CTEI            shift and go to state 45
    CTEF            shift and go to state 43
    CTESTRING       shift and go to state 46
    CTEBOOL         shift and go to state 42
    ID              shift and go to state 39

    expresion                      shift and go to state 40
    term                           shift and go to state 41
    constant                       shift and go to state 33
    functioncall                   shift and go to state 38
    exp                            shift and go to state 44
    factor                         shift and go to state 37
    id                             shift and go to state 34

state 23

    (76) declaracion -> tipo array .

    POINTS          reduce using rule 76 (declaracion -> tipo array .)


state 24

    (70) vars -> VARS LCURLY listofvars RCURLY .

    DATA            reduce using rule 70 (vars -> VARS LCURLY listofvars RCURLY .)
    ID              reduce using rule 70 (vars -> VARS LCURLY listofvars RCURLY .)
    IF              reduce using rule 70 (vars -> VARS LCURLY listofvars RCURLY .)
    PRINT           reduce using rule 70 (vars -> VARS LCURLY listofvars RCURLY .)
    MIN             reduce using rule 70 (vars -> VARS LCURLY listofvars RCURLY .)
    MAX             reduce using rule 70 (vars -> VARS LCURLY listofvars RCURLY .)
    FOR             reduce using rule 70 (vars -> VARS LCURLY listofvars RCURLY .)
    RETURN          reduce using rule 70 (vars -> VARS LCURLY listofvars RCURLY .)
    RCURLY          reduce using rule 70 (vars -> VARS LCURLY listofvars RCURLY .)
    FUNC            reduce using rule 70 (vars -> VARS LCURLY listofvars RCURLY .)
    MODEL           reduce using rule 70 (vars -> VARS LCURLY listofvars RCURLY .)


state 25

    (84) listofvars -> declaracion POINTS . listofids SEMIC lvars
    (81) listofids -> . ID lid

    ID              shift and go to state 47

    listofids                      shift and go to state 48

state 26

    (85) varsdata -> vars . data
    (87) varsdata -> vars .
    (10) data -> . DATA LCURLY asignmany RCURLY

    ID              reduce using rule 87 (varsdata -> vars .)
    IF              reduce using rule 87 (varsdata -> vars .)
    PRINT           reduce using rule 87 (varsdata -> vars .)
    MIN             reduce using rule 87 (varsdata -> vars .)
    MAX             reduce using rule 87 (varsdata -> vars .)
    FOR             reduce using rule 87 (varsdata -> vars .)
    RETURN          reduce using rule 87 (varsdata -> vars .)
    RCURLY          reduce using rule 87 (varsdata -> vars .)
    DATA            shift and go to state 50

    data                           shift and go to state 49

state 27

    (92) program -> declarevars declarefunc MODEL LCURLY varsdata . block2 RCURLY
    (64) block2 -> . statement block2
    (65) block2 -> . statement
    (66) block2 -> . empty
    (49) statement -> . asign
    (50) statement -> . condition
    (51) statement -> . write
    (52) statement -> . optimize
    (53) statement -> . for
    (54) statement -> . return
    (93) empty -> .
    (48) asign -> . ID EQUALS expresiones SEMIC
    (32) condition -> . IF LPAREN expresion RPAREN block SEMIC
    (33) condition -> . IF LPAREN expresion RPAREN block ELSE block SEMIC
    (43) write -> . PRINT LPAREN write2 RPAREN SEMIC
    (15) optimize -> . MIN EQUALS statement
    (16) optimize -> . MAX EQUALS statement
    (20) for -> . FOR ID IN DOT ID LCURLY block2 RCURLY
    (56) return -> . RETURN asign

    RCURLY          reduce using rule 93 (empty -> .)
    ID              shift and go to state 62
    IF              shift and go to state 64
    PRINT           shift and go to state 54
    MIN             shift and go to state 53
    MAX             shift and go to state 65
    FOR             shift and go to state 61
    RETURN          shift and go to state 51

    return                         shift and go to state 60
    block2                         shift and go to state 52
    for                            shift and go to state 55
    asign                          shift and go to state 66
    write                          shift and go to state 57
    condition                      shift and go to state 63
    statement                      shift and go to state 58
    optimize                       shift and go to state 56
    empty                          shift and go to state 59

state 28

    (86) varsdata -> empty .

    ID              reduce using rule 86 (varsdata -> empty .)
    IF              reduce using rule 86 (varsdata -> empty .)
    PRINT           reduce using rule 86 (varsdata -> empty .)
    MIN             reduce using rule 86 (varsdata -> empty .)
    MAX             reduce using rule 86 (varsdata -> empty .)
    FOR             reduce using rule 86 (varsdata -> empty .)
    RETURN          reduce using rule 86 (varsdata -> empty .)
    RCURLY          reduce using rule 86 (varsdata -> empty .)


state 29

    (59) manyargs -> tipo . ID liargs

    ID              shift and go to state 67


state 30

    (57) function -> FUNC ID LPAREN manyargs . RPAREN LCURLY varsdata block2 RCURLY

    RPAREN          shift and go to state 68


state 31

    (58) manyargs -> empty .

    RPAREN          reduce using rule 58 (manyargs -> empty .)


state 32

    (28) factor -> LPAREN . expresion RPAREN
    (36) expresion -> . exp
    (37) expresion -> . exp LESSTHAN exp
    (38) expresion -> . exp GREATERTHAN exp
    (39) expresion -> . exp BETWEEN exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . id
    (6) constant -> . functioncall
    (73) id -> . ID array
    (74) id -> . ID matrix
    (75) id -> . ID
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 36
    MINUS           shift and go to state 35
    LPAREN          shift and go to state 32
    CTEI            shift and go to state 45
    CTEF            shift and go to state 43
    CTESTRING       shift and go to state 46
    CTEBOOL         shift and go to state 42
    ID              shift and go to state 39

    expresion                      shift and go to state 69
    term                           shift and go to state 41
    constant                       shift and go to state 33
    functioncall                   shift and go to state 38
    exp                            shift and go to state 44
    factor                         shift and go to state 37
    id                             shift and go to state 34

state 33

    (27) factor -> constant .

    STAR            reduce using rule 27 (factor -> constant .)
    SLASH           reduce using rule 27 (factor -> constant .)
    PLUS            reduce using rule 27 (factor -> constant .)
    MINUS           reduce using rule 27 (factor -> constant .)
    LESSTHAN        reduce using rule 27 (factor -> constant .)
    GREATERTHAN     reduce using rule 27 (factor -> constant .)
    BETWEEN         reduce using rule 27 (factor -> constant .)
    RBRACKET        reduce using rule 27 (factor -> constant .)
    RPAREN          reduce using rule 27 (factor -> constant .)
    DOT             reduce using rule 27 (factor -> constant .)
    COMMA           reduce using rule 27 (factor -> constant .)
    SEMIC           reduce using rule 27 (factor -> constant .)


state 34

    (5) constant -> id .

    STAR            reduce using rule 5 (constant -> id .)
    SLASH           reduce using rule 5 (constant -> id .)
    PLUS            reduce using rule 5 (constant -> id .)
    MINUS           reduce using rule 5 (constant -> id .)
    LESSTHAN        reduce using rule 5 (constant -> id .)
    GREATERTHAN     reduce using rule 5 (constant -> id .)
    BETWEEN         reduce using rule 5 (constant -> id .)
    RBRACKET        reduce using rule 5 (constant -> id .)
    RPAREN          reduce using rule 5 (constant -> id .)
    DOT             reduce using rule 5 (constant -> id .)
    COMMA           reduce using rule 5 (constant -> id .)
    SEMIC           reduce using rule 5 (constant -> id .)


state 35

    (26) factor -> MINUS . constant
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . id
    (6) constant -> . functioncall
    (73) id -> . ID array
    (74) id -> . ID matrix
    (75) id -> . ID
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    CTEI            shift and go to state 45
    CTEF            shift and go to state 43
    CTESTRING       shift and go to state 46
    CTEBOOL         shift and go to state 42
    ID              shift and go to state 39

    constant                       shift and go to state 70
    functioncall                   shift and go to state 38
    id                             shift and go to state 34

state 36

    (25) factor -> PLUS . constant
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . id
    (6) constant -> . functioncall
    (73) id -> . ID array
    (74) id -> . ID matrix
    (75) id -> . ID
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    CTEI            shift and go to state 45
    CTEF            shift and go to state 43
    CTESTRING       shift and go to state 46
    CTEBOOL         shift and go to state 42
    ID              shift and go to state 39

    constant                       shift and go to state 71
    functioncall                   shift and go to state 38
    id                             shift and go to state 34

state 37

    (29) term -> factor .
    (30) term -> factor . STAR term
    (31) term -> factor . SLASH term

    PLUS            reduce using rule 29 (term -> factor .)
    MINUS           reduce using rule 29 (term -> factor .)
    LESSTHAN        reduce using rule 29 (term -> factor .)
    GREATERTHAN     reduce using rule 29 (term -> factor .)
    BETWEEN         reduce using rule 29 (term -> factor .)
    RBRACKET        reduce using rule 29 (term -> factor .)
    RPAREN          reduce using rule 29 (term -> factor .)
    DOT             reduce using rule 29 (term -> factor .)
    COMMA           reduce using rule 29 (term -> factor .)
    SEMIC           reduce using rule 29 (term -> factor .)
    STAR            shift and go to state 72
    SLASH           shift and go to state 73


state 38

    (6) constant -> functioncall .

    STAR            reduce using rule 6 (constant -> functioncall .)
    SLASH           reduce using rule 6 (constant -> functioncall .)
    PLUS            reduce using rule 6 (constant -> functioncall .)
    MINUS           reduce using rule 6 (constant -> functioncall .)
    LESSTHAN        reduce using rule 6 (constant -> functioncall .)
    GREATERTHAN     reduce using rule 6 (constant -> functioncall .)
    BETWEEN         reduce using rule 6 (constant -> functioncall .)
    RBRACKET        reduce using rule 6 (constant -> functioncall .)
    RPAREN          reduce using rule 6 (constant -> functioncall .)
    DOT             reduce using rule 6 (constant -> functioncall .)
    COMMA           reduce using rule 6 (constant -> functioncall .)
    SEMIC           reduce using rule 6 (constant -> functioncall .)


state 39

    (73) id -> ID . array
    (74) id -> ID . matrix
    (75) id -> ID .
    (7) functioncall -> ID . LPAREN expresion RPAREN
    (8) functioncall -> ID . LPAREN CTEI RPAREN
    (9) functioncall -> ID . LPAREN CTEF RPAREN
    (72) array -> . LBRACKET expresion RBRACKET
    (71) matrix -> . LBRACKET expresion RBRACKET LBRACKET expresion RBRACKET

    STAR            reduce using rule 75 (id -> ID .)
    SLASH           reduce using rule 75 (id -> ID .)
    PLUS            reduce using rule 75 (id -> ID .)
    MINUS           reduce using rule 75 (id -> ID .)
    LESSTHAN        reduce using rule 75 (id -> ID .)
    GREATERTHAN     reduce using rule 75 (id -> ID .)
    BETWEEN         reduce using rule 75 (id -> ID .)
    RBRACKET        reduce using rule 75 (id -> ID .)
    RPAREN          reduce using rule 75 (id -> ID .)
    DOT             reduce using rule 75 (id -> ID .)
    COMMA           reduce using rule 75 (id -> ID .)
    SEMIC           reduce using rule 75 (id -> ID .)
    LPAREN          shift and go to state 75
    LBRACKET        shift and go to state 22

    array                          shift and go to state 76
    matrix                         shift and go to state 74

state 40

    (72) array -> LBRACKET expresion . RBRACKET
    (71) matrix -> LBRACKET expresion . RBRACKET LBRACKET expresion RBRACKET

    RBRACKET        shift and go to state 77


state 41

    (40) exp -> term .
    (41) exp -> term . PLUS exp
    (42) exp -> term . MINUS exp

    LESSTHAN        reduce using rule 40 (exp -> term .)
    GREATERTHAN     reduce using rule 40 (exp -> term .)
    BETWEEN         reduce using rule 40 (exp -> term .)
    RBRACKET        reduce using rule 40 (exp -> term .)
    RPAREN          reduce using rule 40 (exp -> term .)
    DOT             reduce using rule 40 (exp -> term .)
    COMMA           reduce using rule 40 (exp -> term .)
    SEMIC           reduce using rule 40 (exp -> term .)
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79


state 42

    (4) constant -> CTEBOOL .

    STAR            reduce using rule 4 (constant -> CTEBOOL .)
    SLASH           reduce using rule 4 (constant -> CTEBOOL .)
    PLUS            reduce using rule 4 (constant -> CTEBOOL .)
    MINUS           reduce using rule 4 (constant -> CTEBOOL .)
    LESSTHAN        reduce using rule 4 (constant -> CTEBOOL .)
    GREATERTHAN     reduce using rule 4 (constant -> CTEBOOL .)
    BETWEEN         reduce using rule 4 (constant -> CTEBOOL .)
    RBRACKET        reduce using rule 4 (constant -> CTEBOOL .)
    RPAREN          reduce using rule 4 (constant -> CTEBOOL .)
    DOT             reduce using rule 4 (constant -> CTEBOOL .)
    COMMA           reduce using rule 4 (constant -> CTEBOOL .)
    SEMIC           reduce using rule 4 (constant -> CTEBOOL .)


state 43

    (2) constant -> CTEF .

    STAR            reduce using rule 2 (constant -> CTEF .)
    SLASH           reduce using rule 2 (constant -> CTEF .)
    PLUS            reduce using rule 2 (constant -> CTEF .)
    MINUS           reduce using rule 2 (constant -> CTEF .)
    LESSTHAN        reduce using rule 2 (constant -> CTEF .)
    GREATERTHAN     reduce using rule 2 (constant -> CTEF .)
    BETWEEN         reduce using rule 2 (constant -> CTEF .)
    RBRACKET        reduce using rule 2 (constant -> CTEF .)
    RPAREN          reduce using rule 2 (constant -> CTEF .)
    DOT             reduce using rule 2 (constant -> CTEF .)
    COMMA           reduce using rule 2 (constant -> CTEF .)
    SEMIC           reduce using rule 2 (constant -> CTEF .)


state 44

    (36) expresion -> exp .
    (37) expresion -> exp . LESSTHAN exp
    (38) expresion -> exp . GREATERTHAN exp
    (39) expresion -> exp . BETWEEN exp

    COMMA           reduce using rule 36 (expresion -> exp .)
    SEMIC           reduce using rule 36 (expresion -> exp .)
    DOT             reduce using rule 36 (expresion -> exp .)
    RPAREN          reduce using rule 36 (expresion -> exp .)
    RBRACKET        reduce using rule 36 (expresion -> exp .)
    LESSTHAN        shift and go to state 80
    GREATERTHAN     shift and go to state 81
    BETWEEN         shift and go to state 82


state 45

    (1) constant -> CTEI .

    STAR            reduce using rule 1 (constant -> CTEI .)
    SLASH           reduce using rule 1 (constant -> CTEI .)
    PLUS            reduce using rule 1 (constant -> CTEI .)
    MINUS           reduce using rule 1 (constant -> CTEI .)
    LESSTHAN        reduce using rule 1 (constant -> CTEI .)
    GREATERTHAN     reduce using rule 1 (constant -> CTEI .)
    BETWEEN         reduce using rule 1 (constant -> CTEI .)
    RBRACKET        reduce using rule 1 (constant -> CTEI .)
    RPAREN          reduce using rule 1 (constant -> CTEI .)
    DOT             reduce using rule 1 (constant -> CTEI .)
    COMMA           reduce using rule 1 (constant -> CTEI .)
    SEMIC           reduce using rule 1 (constant -> CTEI .)


state 46

    (3) constant -> CTESTRING .

    STAR            reduce using rule 3 (constant -> CTESTRING .)
    SLASH           reduce using rule 3 (constant -> CTESTRING .)
    PLUS            reduce using rule 3 (constant -> CTESTRING .)
    MINUS           reduce using rule 3 (constant -> CTESTRING .)
    LESSTHAN        reduce using rule 3 (constant -> CTESTRING .)
    GREATERTHAN     reduce using rule 3 (constant -> CTESTRING .)
    BETWEEN         reduce using rule 3 (constant -> CTESTRING .)
    RBRACKET        reduce using rule 3 (constant -> CTESTRING .)
    RPAREN          reduce using rule 3 (constant -> CTESTRING .)
    DOT             reduce using rule 3 (constant -> CTESTRING .)
    COMMA           reduce using rule 3 (constant -> CTESTRING .)
    SEMIC           reduce using rule 3 (constant -> CTESTRING .)


state 47

    (81) listofids -> ID . lid
    (79) lid -> . COMMA listofids
    (80) lid -> . empty
    (93) empty -> .

    COMMA           shift and go to state 85
    SEMIC           reduce using rule 93 (empty -> .)

    lid                            shift and go to state 83
    empty                          shift and go to state 84

state 48

    (84) listofvars -> declaracion POINTS listofids . SEMIC lvars

    SEMIC           shift and go to state 86


state 49

    (85) varsdata -> vars data .

    ID              reduce using rule 85 (varsdata -> vars data .)
    IF              reduce using rule 85 (varsdata -> vars data .)
    PRINT           reduce using rule 85 (varsdata -> vars data .)
    MIN             reduce using rule 85 (varsdata -> vars data .)
    MAX             reduce using rule 85 (varsdata -> vars data .)
    FOR             reduce using rule 85 (varsdata -> vars data .)
    RETURN          reduce using rule 85 (varsdata -> vars data .)
    RCURLY          reduce using rule 85 (varsdata -> vars data .)


state 50

    (10) data -> DATA . LCURLY asignmany RCURLY

    LCURLY          shift and go to state 87


state 51

    (56) return -> RETURN . asign
    (48) asign -> . ID EQUALS expresiones SEMIC

    ID              shift and go to state 62

    asign                          shift and go to state 88

state 52

    (92) program -> declarevars declarefunc MODEL LCURLY varsdata block2 . RCURLY

    RCURLY          shift and go to state 89


state 53

    (15) optimize -> MIN . EQUALS statement

    EQUALS          shift and go to state 90


state 54

    (43) write -> PRINT . LPAREN write2 RPAREN SEMIC

    LPAREN          shift and go to state 91


state 55

    (53) statement -> for .

    ID              reduce using rule 53 (statement -> for .)
    IF              reduce using rule 53 (statement -> for .)
    PRINT           reduce using rule 53 (statement -> for .)
    MIN             reduce using rule 53 (statement -> for .)
    MAX             reduce using rule 53 (statement -> for .)
    FOR             reduce using rule 53 (statement -> for .)
    RETURN          reduce using rule 53 (statement -> for .)
    RCURLY          reduce using rule 53 (statement -> for .)
    SEMIC           reduce using rule 53 (statement -> for .)
    ELSE            reduce using rule 53 (statement -> for .)


state 56

    (52) statement -> optimize .

    ID              reduce using rule 52 (statement -> optimize .)
    IF              reduce using rule 52 (statement -> optimize .)
    PRINT           reduce using rule 52 (statement -> optimize .)
    MIN             reduce using rule 52 (statement -> optimize .)
    MAX             reduce using rule 52 (statement -> optimize .)
    FOR             reduce using rule 52 (statement -> optimize .)
    RETURN          reduce using rule 52 (statement -> optimize .)
    RCURLY          reduce using rule 52 (statement -> optimize .)
    SEMIC           reduce using rule 52 (statement -> optimize .)
    ELSE            reduce using rule 52 (statement -> optimize .)


state 57

    (51) statement -> write .

    ID              reduce using rule 51 (statement -> write .)
    IF              reduce using rule 51 (statement -> write .)
    PRINT           reduce using rule 51 (statement -> write .)
    MIN             reduce using rule 51 (statement -> write .)
    MAX             reduce using rule 51 (statement -> write .)
    FOR             reduce using rule 51 (statement -> write .)
    RETURN          reduce using rule 51 (statement -> write .)
    RCURLY          reduce using rule 51 (statement -> write .)
    SEMIC           reduce using rule 51 (statement -> write .)
    ELSE            reduce using rule 51 (statement -> write .)


state 58

    (64) block2 -> statement . block2
    (65) block2 -> statement .
    (64) block2 -> . statement block2
    (65) block2 -> . statement
    (66) block2 -> . empty
    (49) statement -> . asign
    (50) statement -> . condition
    (51) statement -> . write
    (52) statement -> . optimize
    (53) statement -> . for
    (54) statement -> . return
    (93) empty -> .
    (48) asign -> . ID EQUALS expresiones SEMIC
    (32) condition -> . IF LPAREN expresion RPAREN block SEMIC
    (33) condition -> . IF LPAREN expresion RPAREN block ELSE block SEMIC
    (43) write -> . PRINT LPAREN write2 RPAREN SEMIC
    (15) optimize -> . MIN EQUALS statement
    (16) optimize -> . MAX EQUALS statement
    (20) for -> . FOR ID IN DOT ID LCURLY block2 RCURLY
    (56) return -> . RETURN asign

  ! reduce/reduce conflict for RCURLY resolved using rule 65 (block2 -> statement .)
  ! reduce/reduce conflict for SEMIC resolved using rule 65 (block2 -> statement .)
  ! reduce/reduce conflict for ELSE resolved using rule 65 (block2 -> statement .)
    RCURLY          reduce using rule 65 (block2 -> statement .)
    SEMIC           reduce using rule 65 (block2 -> statement .)
    ELSE            reduce using rule 65 (block2 -> statement .)
    ID              shift and go to state 62
    IF              shift and go to state 64
    PRINT           shift and go to state 54
    MIN             shift and go to state 53
    MAX             shift and go to state 65
    FOR             shift and go to state 61
    RETURN          shift and go to state 51

  ! RCURLY          [ reduce using rule 93 (empty -> .) ]
  ! SEMIC           [ reduce using rule 93 (empty -> .) ]
  ! ELSE            [ reduce using rule 93 (empty -> .) ]

    return                         shift and go to state 60
    block2                         shift and go to state 92
    for                            shift and go to state 55
    asign                          shift and go to state 66
    write                          shift and go to state 57
    condition                      shift and go to state 63
    statement                      shift and go to state 58
    optimize                       shift and go to state 56
    empty                          shift and go to state 59

state 59

    (66) block2 -> empty .

    RCURLY          reduce using rule 66 (block2 -> empty .)
    SEMIC           reduce using rule 66 (block2 -> empty .)
    ELSE            reduce using rule 66 (block2 -> empty .)


state 60

    (54) statement -> return .

    ID              reduce using rule 54 (statement -> return .)
    IF              reduce using rule 54 (statement -> return .)
    PRINT           reduce using rule 54 (statement -> return .)
    MIN             reduce using rule 54 (statement -> return .)
    MAX             reduce using rule 54 (statement -> return .)
    FOR             reduce using rule 54 (statement -> return .)
    RETURN          reduce using rule 54 (statement -> return .)
    RCURLY          reduce using rule 54 (statement -> return .)
    SEMIC           reduce using rule 54 (statement -> return .)
    ELSE            reduce using rule 54 (statement -> return .)


state 61

    (20) for -> FOR . ID IN DOT ID LCURLY block2 RCURLY

    ID              shift and go to state 93


state 62

    (48) asign -> ID . EQUALS expresiones SEMIC

    EQUALS          shift and go to state 94


state 63

    (50) statement -> condition .

    ID              reduce using rule 50 (statement -> condition .)
    IF              reduce using rule 50 (statement -> condition .)
    PRINT           reduce using rule 50 (statement -> condition .)
    MIN             reduce using rule 50 (statement -> condition .)
    MAX             reduce using rule 50 (statement -> condition .)
    FOR             reduce using rule 50 (statement -> condition .)
    RETURN          reduce using rule 50 (statement -> condition .)
    RCURLY          reduce using rule 50 (statement -> condition .)
    SEMIC           reduce using rule 50 (statement -> condition .)
    ELSE            reduce using rule 50 (statement -> condition .)


state 64

    (32) condition -> IF . LPAREN expresion RPAREN block SEMIC
    (33) condition -> IF . LPAREN expresion RPAREN block ELSE block SEMIC

    LPAREN          shift and go to state 95


state 65

    (16) optimize -> MAX . EQUALS statement

    EQUALS          shift and go to state 96


state 66

    (49) statement -> asign .

    ID              reduce using rule 49 (statement -> asign .)
    IF              reduce using rule 49 (statement -> asign .)
    PRINT           reduce using rule 49 (statement -> asign .)
    MIN             reduce using rule 49 (statement -> asign .)
    MAX             reduce using rule 49 (statement -> asign .)
    FOR             reduce using rule 49 (statement -> asign .)
    RETURN          reduce using rule 49 (statement -> asign .)
    RCURLY          reduce using rule 49 (statement -> asign .)
    SEMIC           reduce using rule 49 (statement -> asign .)
    ELSE            reduce using rule 49 (statement -> asign .)


state 67

    (59) manyargs -> tipo ID . liargs
    (60) liargs -> . empty
    (61) liargs -> . COMMA manyargs
    (93) empty -> .

    COMMA           shift and go to state 98
    RPAREN          reduce using rule 93 (empty -> .)

    liargs                         shift and go to state 97
    empty                          shift and go to state 99

state 68

    (57) function -> FUNC ID LPAREN manyargs RPAREN . LCURLY varsdata block2 RCURLY

    LCURLY          shift and go to state 100


state 69

    (28) factor -> LPAREN expresion . RPAREN

    RPAREN          shift and go to state 101


state 70

    (26) factor -> MINUS constant .

    STAR            reduce using rule 26 (factor -> MINUS constant .)
    SLASH           reduce using rule 26 (factor -> MINUS constant .)
    PLUS            reduce using rule 26 (factor -> MINUS constant .)
    MINUS           reduce using rule 26 (factor -> MINUS constant .)
    LESSTHAN        reduce using rule 26 (factor -> MINUS constant .)
    GREATERTHAN     reduce using rule 26 (factor -> MINUS constant .)
    BETWEEN         reduce using rule 26 (factor -> MINUS constant .)
    RBRACKET        reduce using rule 26 (factor -> MINUS constant .)
    RPAREN          reduce using rule 26 (factor -> MINUS constant .)
    DOT             reduce using rule 26 (factor -> MINUS constant .)
    COMMA           reduce using rule 26 (factor -> MINUS constant .)
    SEMIC           reduce using rule 26 (factor -> MINUS constant .)


state 71

    (25) factor -> PLUS constant .

    STAR            reduce using rule 25 (factor -> PLUS constant .)
    SLASH           reduce using rule 25 (factor -> PLUS constant .)
    PLUS            reduce using rule 25 (factor -> PLUS constant .)
    MINUS           reduce using rule 25 (factor -> PLUS constant .)
    LESSTHAN        reduce using rule 25 (factor -> PLUS constant .)
    GREATERTHAN     reduce using rule 25 (factor -> PLUS constant .)
    BETWEEN         reduce using rule 25 (factor -> PLUS constant .)
    RBRACKET        reduce using rule 25 (factor -> PLUS constant .)
    RPAREN          reduce using rule 25 (factor -> PLUS constant .)
    DOT             reduce using rule 25 (factor -> PLUS constant .)
    COMMA           reduce using rule 25 (factor -> PLUS constant .)
    SEMIC           reduce using rule 25 (factor -> PLUS constant .)


state 72

    (30) term -> factor STAR . term
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . id
    (6) constant -> . functioncall
    (73) id -> . ID array
    (74) id -> . ID matrix
    (75) id -> . ID
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 36
    MINUS           shift and go to state 35
    LPAREN          shift and go to state 32
    CTEI            shift and go to state 45
    CTEF            shift and go to state 43
    CTESTRING       shift and go to state 46
    CTEBOOL         shift and go to state 42
    ID              shift and go to state 39

    term                           shift and go to state 102
    constant                       shift and go to state 33
    functioncall                   shift and go to state 38
    factor                         shift and go to state 37
    id                             shift and go to state 34

state 73

    (31) term -> factor SLASH . term
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . id
    (6) constant -> . functioncall
    (73) id -> . ID array
    (74) id -> . ID matrix
    (75) id -> . ID
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 36
    MINUS           shift and go to state 35
    LPAREN          shift and go to state 32
    CTEI            shift and go to state 45
    CTEF            shift and go to state 43
    CTESTRING       shift and go to state 46
    CTEBOOL         shift and go to state 42
    ID              shift and go to state 39

    term                           shift and go to state 103
    constant                       shift and go to state 33
    functioncall                   shift and go to state 38
    factor                         shift and go to state 37
    id                             shift and go to state 34

state 74

    (74) id -> ID matrix .

    STAR            reduce using rule 74 (id -> ID matrix .)
    SLASH           reduce using rule 74 (id -> ID matrix .)
    PLUS            reduce using rule 74 (id -> ID matrix .)
    MINUS           reduce using rule 74 (id -> ID matrix .)
    LESSTHAN        reduce using rule 74 (id -> ID matrix .)
    GREATERTHAN     reduce using rule 74 (id -> ID matrix .)
    BETWEEN         reduce using rule 74 (id -> ID matrix .)
    RBRACKET        reduce using rule 74 (id -> ID matrix .)
    RPAREN          reduce using rule 74 (id -> ID matrix .)
    DOT             reduce using rule 74 (id -> ID matrix .)
    COMMA           reduce using rule 74 (id -> ID matrix .)
    SEMIC           reduce using rule 74 (id -> ID matrix .)


state 75

    (7) functioncall -> ID LPAREN . expresion RPAREN
    (8) functioncall -> ID LPAREN . CTEI RPAREN
    (9) functioncall -> ID LPAREN . CTEF RPAREN
    (36) expresion -> . exp
    (37) expresion -> . exp LESSTHAN exp
    (38) expresion -> . exp GREATERTHAN exp
    (39) expresion -> . exp BETWEEN exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . id
    (6) constant -> . functioncall
    (73) id -> . ID array
    (74) id -> . ID matrix
    (75) id -> . ID
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    CTEI            shift and go to state 106
    CTEF            shift and go to state 104
    PLUS            shift and go to state 36
    MINUS           shift and go to state 35
    LPAREN          shift and go to state 32
    CTESTRING       shift and go to state 46
    CTEBOOL         shift and go to state 42
    ID              shift and go to state 39

    expresion                      shift and go to state 105
    term                           shift and go to state 41
    constant                       shift and go to state 33
    functioncall                   shift and go to state 38
    exp                            shift and go to state 44
    factor                         shift and go to state 37
    id                             shift and go to state 34

state 76

    (73) id -> ID array .

    STAR            reduce using rule 73 (id -> ID array .)
    SLASH           reduce using rule 73 (id -> ID array .)
    PLUS            reduce using rule 73 (id -> ID array .)
    MINUS           reduce using rule 73 (id -> ID array .)
    LESSTHAN        reduce using rule 73 (id -> ID array .)
    GREATERTHAN     reduce using rule 73 (id -> ID array .)
    BETWEEN         reduce using rule 73 (id -> ID array .)
    RBRACKET        reduce using rule 73 (id -> ID array .)
    RPAREN          reduce using rule 73 (id -> ID array .)
    DOT             reduce using rule 73 (id -> ID array .)
    COMMA           reduce using rule 73 (id -> ID array .)
    SEMIC           reduce using rule 73 (id -> ID array .)


state 77

    (72) array -> LBRACKET expresion RBRACKET .
    (71) matrix -> LBRACKET expresion RBRACKET . LBRACKET expresion RBRACKET

    STAR            reduce using rule 72 (array -> LBRACKET expresion RBRACKET .)
    SLASH           reduce using rule 72 (array -> LBRACKET expresion RBRACKET .)
    PLUS            reduce using rule 72 (array -> LBRACKET expresion RBRACKET .)
    MINUS           reduce using rule 72 (array -> LBRACKET expresion RBRACKET .)
    LESSTHAN        reduce using rule 72 (array -> LBRACKET expresion RBRACKET .)
    GREATERTHAN     reduce using rule 72 (array -> LBRACKET expresion RBRACKET .)
    BETWEEN         reduce using rule 72 (array -> LBRACKET expresion RBRACKET .)
    RBRACKET        reduce using rule 72 (array -> LBRACKET expresion RBRACKET .)
    RPAREN          reduce using rule 72 (array -> LBRACKET expresion RBRACKET .)
    DOT             reduce using rule 72 (array -> LBRACKET expresion RBRACKET .)
    COMMA           reduce using rule 72 (array -> LBRACKET expresion RBRACKET .)
    SEMIC           reduce using rule 72 (array -> LBRACKET expresion RBRACKET .)
    POINTS          reduce using rule 72 (array -> LBRACKET expresion RBRACKET .)
    LBRACKET        shift and go to state 107


state 78

    (41) exp -> term PLUS . exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . id
    (6) constant -> . functioncall
    (73) id -> . ID array
    (74) id -> . ID matrix
    (75) id -> . ID
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 36
    MINUS           shift and go to state 35
    LPAREN          shift and go to state 32
    CTEI            shift and go to state 45
    CTEF            shift and go to state 43
    CTESTRING       shift and go to state 46
    CTEBOOL         shift and go to state 42
    ID              shift and go to state 39

    term                           shift and go to state 41
    constant                       shift and go to state 33
    functioncall                   shift and go to state 38
    exp                            shift and go to state 108
    factor                         shift and go to state 37
    id                             shift and go to state 34

state 79

    (42) exp -> term MINUS . exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . id
    (6) constant -> . functioncall
    (73) id -> . ID array
    (74) id -> . ID matrix
    (75) id -> . ID
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 36
    MINUS           shift and go to state 35
    LPAREN          shift and go to state 32
    CTEI            shift and go to state 45
    CTEF            shift and go to state 43
    CTESTRING       shift and go to state 46
    CTEBOOL         shift and go to state 42
    ID              shift and go to state 39

    term                           shift and go to state 41
    constant                       shift and go to state 33
    functioncall                   shift and go to state 38
    exp                            shift and go to state 109
    factor                         shift and go to state 37
    id                             shift and go to state 34

state 80

    (37) expresion -> exp LESSTHAN . exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . id
    (6) constant -> . functioncall
    (73) id -> . ID array
    (74) id -> . ID matrix
    (75) id -> . ID
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 36
    MINUS           shift and go to state 35
    LPAREN          shift and go to state 32
    CTEI            shift and go to state 45
    CTEF            shift and go to state 43
    CTESTRING       shift and go to state 46
    CTEBOOL         shift and go to state 42
    ID              shift and go to state 39

    term                           shift and go to state 41
    constant                       shift and go to state 33
    functioncall                   shift and go to state 38
    exp                            shift and go to state 110
    factor                         shift and go to state 37
    id                             shift and go to state 34

state 81

    (38) expresion -> exp GREATERTHAN . exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . id
    (6) constant -> . functioncall
    (73) id -> . ID array
    (74) id -> . ID matrix
    (75) id -> . ID
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 36
    MINUS           shift and go to state 35
    LPAREN          shift and go to state 32
    CTEI            shift and go to state 45
    CTEF            shift and go to state 43
    CTESTRING       shift and go to state 46
    CTEBOOL         shift and go to state 42
    ID              shift and go to state 39

    term                           shift and go to state 41
    constant                       shift and go to state 33
    functioncall                   shift and go to state 38
    exp                            shift and go to state 111
    factor                         shift and go to state 37
    id                             shift and go to state 34

state 82

    (39) expresion -> exp BETWEEN . exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . id
    (6) constant -> . functioncall
    (73) id -> . ID array
    (74) id -> . ID matrix
    (75) id -> . ID
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 36
    MINUS           shift and go to state 35
    LPAREN          shift and go to state 32
    CTEI            shift and go to state 45
    CTEF            shift and go to state 43
    CTESTRING       shift and go to state 46
    CTEBOOL         shift and go to state 42
    ID              shift and go to state 39

    term                           shift and go to state 41
    constant                       shift and go to state 33
    functioncall                   shift and go to state 38
    exp                            shift and go to state 112
    factor                         shift and go to state 37
    id                             shift and go to state 34

state 83

    (81) listofids -> ID lid .

    SEMIC           reduce using rule 81 (listofids -> ID lid .)


state 84

    (80) lid -> empty .

    SEMIC           reduce using rule 80 (lid -> empty .)


state 85

    (79) lid -> COMMA . listofids
    (81) listofids -> . ID lid

    ID              shift and go to state 47

    listofids                      shift and go to state 113

state 86

    (84) listofvars -> declaracion POINTS listofids SEMIC . lvars
    (82) lvars -> . listofvars
    (83) lvars -> . empty
    (84) listofvars -> . declaracion POINTS listofids SEMIC lvars
    (93) empty -> .
    (76) declaracion -> . tipo array
    (77) declaracion -> . tipo matrix
    (78) declaracion -> . tipo
    (67) tipo -> . TINT
    (68) tipo -> . TFLOAT
    (69) tipo -> . TBOOL

    RCURLY          reduce using rule 93 (empty -> .)
    TINT            shift and go to state 13
    TFLOAT          shift and go to state 17
    TBOOL           shift and go to state 16

    tipo                           shift and go to state 14
    listofvars                     shift and go to state 114
    lvars                          shift and go to state 115
    declaracion                    shift and go to state 18
    empty                          shift and go to state 116

state 87

    (10) data -> DATA LCURLY . asignmany RCURLY
    (11) asignmany -> . asign SEMIC asignlist
    (12) asignmany -> . asign
    (48) asign -> . ID EQUALS expresiones SEMIC

    ID              shift and go to state 62

    asignmany                      shift and go to state 117
    asign                          shift and go to state 118

state 88

    (56) return -> RETURN asign .

    ID              reduce using rule 56 (return -> RETURN asign .)
    IF              reduce using rule 56 (return -> RETURN asign .)
    PRINT           reduce using rule 56 (return -> RETURN asign .)
    MIN             reduce using rule 56 (return -> RETURN asign .)
    MAX             reduce using rule 56 (return -> RETURN asign .)
    FOR             reduce using rule 56 (return -> RETURN asign .)
    RETURN          reduce using rule 56 (return -> RETURN asign .)
    RCURLY          reduce using rule 56 (return -> RETURN asign .)
    SEMIC           reduce using rule 56 (return -> RETURN asign .)
    ELSE            reduce using rule 56 (return -> RETURN asign .)


state 89

    (92) program -> declarevars declarefunc MODEL LCURLY varsdata block2 RCURLY .

    $end            reduce using rule 92 (program -> declarevars declarefunc MODEL LCURLY varsdata block2 RCURLY .)


state 90

    (15) optimize -> MIN EQUALS . statement
    (49) statement -> . asign
    (50) statement -> . condition
    (51) statement -> . write
    (52) statement -> . optimize
    (53) statement -> . for
    (54) statement -> . return
    (48) asign -> . ID EQUALS expresiones SEMIC
    (32) condition -> . IF LPAREN expresion RPAREN block SEMIC
    (33) condition -> . IF LPAREN expresion RPAREN block ELSE block SEMIC
    (43) write -> . PRINT LPAREN write2 RPAREN SEMIC
    (15) optimize -> . MIN EQUALS statement
    (16) optimize -> . MAX EQUALS statement
    (20) for -> . FOR ID IN DOT ID LCURLY block2 RCURLY
    (56) return -> . RETURN asign

    ID              shift and go to state 62
    IF              shift and go to state 64
    PRINT           shift and go to state 54
    MIN             shift and go to state 53
    MAX             shift and go to state 65
    FOR             shift and go to state 61
    RETURN          shift and go to state 51

    return                         shift and go to state 60
    for                            shift and go to state 55
    asign                          shift and go to state 66
    write                          shift and go to state 57
    statement                      shift and go to state 119
    optimize                       shift and go to state 56
    condition                      shift and go to state 63

state 91

    (43) write -> PRINT LPAREN . write2 RPAREN SEMIC
    (44) write2 -> . expresion
    (45) write2 -> . CTESTRING
    (46) write2 -> . expresion DOT write2
    (47) write2 -> . CTESTRING DOT write2
    (36) expresion -> . exp
    (37) expresion -> . exp LESSTHAN exp
    (38) expresion -> . exp GREATERTHAN exp
    (39) expresion -> . exp BETWEEN exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . id
    (6) constant -> . functioncall
    (73) id -> . ID array
    (74) id -> . ID matrix
    (75) id -> . ID
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    CTESTRING       shift and go to state 120
    PLUS            shift and go to state 36
    MINUS           shift and go to state 35
    LPAREN          shift and go to state 32
    CTEI            shift and go to state 45
    CTEF            shift and go to state 43
    CTEBOOL         shift and go to state 42
    ID              shift and go to state 39

    expresion                      shift and go to state 121
    term                           shift and go to state 41
    constant                       shift and go to state 33
    write2                         shift and go to state 122
    functioncall                   shift and go to state 38
    exp                            shift and go to state 44
    factor                         shift and go to state 37
    id                             shift and go to state 34

state 92

    (64) block2 -> statement block2 .

    RCURLY          reduce using rule 64 (block2 -> statement block2 .)
    SEMIC           reduce using rule 64 (block2 -> statement block2 .)
    ELSE            reduce using rule 64 (block2 -> statement block2 .)


state 93

    (20) for -> FOR ID . IN DOT ID LCURLY block2 RCURLY

    IN              shift and go to state 123


state 94

    (48) asign -> ID EQUALS . expresiones SEMIC
    (34) expresiones -> . expresion COMMA expresiones
    (35) expresiones -> . expresion
    (36) expresion -> . exp
    (37) expresion -> . exp LESSTHAN exp
    (38) expresion -> . exp GREATERTHAN exp
    (39) expresion -> . exp BETWEEN exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . id
    (6) constant -> . functioncall
    (73) id -> . ID array
    (74) id -> . ID matrix
    (75) id -> . ID
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 36
    MINUS           shift and go to state 35
    LPAREN          shift and go to state 32
    CTEI            shift and go to state 45
    CTEF            shift and go to state 43
    CTESTRING       shift and go to state 46
    CTEBOOL         shift and go to state 42
    ID              shift and go to state 39

    expresion                      shift and go to state 125
    expresiones                    shift and go to state 124
    constant                       shift and go to state 33
    term                           shift and go to state 41
    functioncall                   shift and go to state 38
    exp                            shift and go to state 44
    factor                         shift and go to state 37
    id                             shift and go to state 34

state 95

    (32) condition -> IF LPAREN . expresion RPAREN block SEMIC
    (33) condition -> IF LPAREN . expresion RPAREN block ELSE block SEMIC
    (36) expresion -> . exp
    (37) expresion -> . exp LESSTHAN exp
    (38) expresion -> . exp GREATERTHAN exp
    (39) expresion -> . exp BETWEEN exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . id
    (6) constant -> . functioncall
    (73) id -> . ID array
    (74) id -> . ID matrix
    (75) id -> . ID
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 36
    MINUS           shift and go to state 35
    LPAREN          shift and go to state 32
    CTEI            shift and go to state 45
    CTEF            shift and go to state 43
    CTESTRING       shift and go to state 46
    CTEBOOL         shift and go to state 42
    ID              shift and go to state 39

    expresion                      shift and go to state 126
    term                           shift and go to state 41
    constant                       shift and go to state 33
    functioncall                   shift and go to state 38
    exp                            shift and go to state 44
    factor                         shift and go to state 37
    id                             shift and go to state 34

state 96

    (16) optimize -> MAX EQUALS . statement
    (49) statement -> . asign
    (50) statement -> . condition
    (51) statement -> . write
    (52) statement -> . optimize
    (53) statement -> . for
    (54) statement -> . return
    (48) asign -> . ID EQUALS expresiones SEMIC
    (32) condition -> . IF LPAREN expresion RPAREN block SEMIC
    (33) condition -> . IF LPAREN expresion RPAREN block ELSE block SEMIC
    (43) write -> . PRINT LPAREN write2 RPAREN SEMIC
    (15) optimize -> . MIN EQUALS statement
    (16) optimize -> . MAX EQUALS statement
    (20) for -> . FOR ID IN DOT ID LCURLY block2 RCURLY
    (56) return -> . RETURN asign

    ID              shift and go to state 62
    IF              shift and go to state 64
    PRINT           shift and go to state 54
    MIN             shift and go to state 53
    MAX             shift and go to state 65
    FOR             shift and go to state 61
    RETURN          shift and go to state 51

    return                         shift and go to state 60
    for                            shift and go to state 55
    asign                          shift and go to state 66
    write                          shift and go to state 57
    statement                      shift and go to state 127
    optimize                       shift and go to state 56
    condition                      shift and go to state 63

state 97

    (59) manyargs -> tipo ID liargs .

    RPAREN          reduce using rule 59 (manyargs -> tipo ID liargs .)


state 98

    (61) liargs -> COMMA . manyargs
    (58) manyargs -> . empty
    (59) manyargs -> . tipo ID liargs
    (93) empty -> .
    (67) tipo -> . TINT
    (68) tipo -> . TFLOAT
    (69) tipo -> . TBOOL

    RPAREN          reduce using rule 93 (empty -> .)
    TINT            shift and go to state 13
    TFLOAT          shift and go to state 17
    TBOOL           shift and go to state 16

    empty                          shift and go to state 31
    manyargs                       shift and go to state 128
    tipo                           shift and go to state 29

state 99

    (60) liargs -> empty .

    RPAREN          reduce using rule 60 (liargs -> empty .)


state 100

    (57) function -> FUNC ID LPAREN manyargs RPAREN LCURLY . varsdata block2 RCURLY
    (85) varsdata -> . vars data
    (86) varsdata -> . empty
    (87) varsdata -> . vars
    (70) vars -> . VARS LCURLY listofvars RCURLY
    (93) empty -> .

    VARS            shift and go to state 4
    ID              reduce using rule 93 (empty -> .)
    IF              reduce using rule 93 (empty -> .)
    PRINT           reduce using rule 93 (empty -> .)
    MIN             reduce using rule 93 (empty -> .)
    MAX             reduce using rule 93 (empty -> .)
    FOR             reduce using rule 93 (empty -> .)
    RETURN          reduce using rule 93 (empty -> .)
    RCURLY          reduce using rule 93 (empty -> .)

    vars                           shift and go to state 26
    varsdata                       shift and go to state 129
    empty                          shift and go to state 28

state 101

    (28) factor -> LPAREN expresion RPAREN .

    STAR            reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    SLASH           reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    PLUS            reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    MINUS           reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    LESSTHAN        reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    GREATERTHAN     reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    BETWEEN         reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    RBRACKET        reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    RPAREN          reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    DOT             reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    COMMA           reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    SEMIC           reduce using rule 28 (factor -> LPAREN expresion RPAREN .)


state 102

    (30) term -> factor STAR term .

    PLUS            reduce using rule 30 (term -> factor STAR term .)
    MINUS           reduce using rule 30 (term -> factor STAR term .)
    LESSTHAN        reduce using rule 30 (term -> factor STAR term .)
    GREATERTHAN     reduce using rule 30 (term -> factor STAR term .)
    BETWEEN         reduce using rule 30 (term -> factor STAR term .)
    RBRACKET        reduce using rule 30 (term -> factor STAR term .)
    RPAREN          reduce using rule 30 (term -> factor STAR term .)
    DOT             reduce using rule 30 (term -> factor STAR term .)
    COMMA           reduce using rule 30 (term -> factor STAR term .)
    SEMIC           reduce using rule 30 (term -> factor STAR term .)


state 103

    (31) term -> factor SLASH term .

    PLUS            reduce using rule 31 (term -> factor SLASH term .)
    MINUS           reduce using rule 31 (term -> factor SLASH term .)
    LESSTHAN        reduce using rule 31 (term -> factor SLASH term .)
    GREATERTHAN     reduce using rule 31 (term -> factor SLASH term .)
    BETWEEN         reduce using rule 31 (term -> factor SLASH term .)
    RBRACKET        reduce using rule 31 (term -> factor SLASH term .)
    RPAREN          reduce using rule 31 (term -> factor SLASH term .)
    DOT             reduce using rule 31 (term -> factor SLASH term .)
    COMMA           reduce using rule 31 (term -> factor SLASH term .)
    SEMIC           reduce using rule 31 (term -> factor SLASH term .)


state 104

    (9) functioncall -> ID LPAREN CTEF . RPAREN
    (2) constant -> CTEF .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 130
    STAR            reduce using rule 2 (constant -> CTEF .)
    SLASH           reduce using rule 2 (constant -> CTEF .)
    PLUS            reduce using rule 2 (constant -> CTEF .)
    MINUS           reduce using rule 2 (constant -> CTEF .)
    LESSTHAN        reduce using rule 2 (constant -> CTEF .)
    GREATERTHAN     reduce using rule 2 (constant -> CTEF .)
    BETWEEN         reduce using rule 2 (constant -> CTEF .)

  ! RPAREN          [ reduce using rule 2 (constant -> CTEF .) ]


state 105

    (7) functioncall -> ID LPAREN expresion . RPAREN

    RPAREN          shift and go to state 131


state 106

    (8) functioncall -> ID LPAREN CTEI . RPAREN
    (1) constant -> CTEI .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 132
    STAR            reduce using rule 1 (constant -> CTEI .)
    SLASH           reduce using rule 1 (constant -> CTEI .)
    PLUS            reduce using rule 1 (constant -> CTEI .)
    MINUS           reduce using rule 1 (constant -> CTEI .)
    LESSTHAN        reduce using rule 1 (constant -> CTEI .)
    GREATERTHAN     reduce using rule 1 (constant -> CTEI .)
    BETWEEN         reduce using rule 1 (constant -> CTEI .)

  ! RPAREN          [ reduce using rule 1 (constant -> CTEI .) ]


state 107

    (71) matrix -> LBRACKET expresion RBRACKET LBRACKET . expresion RBRACKET
    (36) expresion -> . exp
    (37) expresion -> . exp LESSTHAN exp
    (38) expresion -> . exp GREATERTHAN exp
    (39) expresion -> . exp BETWEEN exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . id
    (6) constant -> . functioncall
    (73) id -> . ID array
    (74) id -> . ID matrix
    (75) id -> . ID
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 36
    MINUS           shift and go to state 35
    LPAREN          shift and go to state 32
    CTEI            shift and go to state 45
    CTEF            shift and go to state 43
    CTESTRING       shift and go to state 46
    CTEBOOL         shift and go to state 42
    ID              shift and go to state 39

    expresion                      shift and go to state 133
    term                           shift and go to state 41
    constant                       shift and go to state 33
    functioncall                   shift and go to state 38
    exp                            shift and go to state 44
    factor                         shift and go to state 37
    id                             shift and go to state 34

state 108

    (41) exp -> term PLUS exp .

    LESSTHAN        reduce using rule 41 (exp -> term PLUS exp .)
    GREATERTHAN     reduce using rule 41 (exp -> term PLUS exp .)
    BETWEEN         reduce using rule 41 (exp -> term PLUS exp .)
    RBRACKET        reduce using rule 41 (exp -> term PLUS exp .)
    RPAREN          reduce using rule 41 (exp -> term PLUS exp .)
    DOT             reduce using rule 41 (exp -> term PLUS exp .)
    COMMA           reduce using rule 41 (exp -> term PLUS exp .)
    SEMIC           reduce using rule 41 (exp -> term PLUS exp .)


state 109

    (42) exp -> term MINUS exp .

    LESSTHAN        reduce using rule 42 (exp -> term MINUS exp .)
    GREATERTHAN     reduce using rule 42 (exp -> term MINUS exp .)
    BETWEEN         reduce using rule 42 (exp -> term MINUS exp .)
    RBRACKET        reduce using rule 42 (exp -> term MINUS exp .)
    RPAREN          reduce using rule 42 (exp -> term MINUS exp .)
    DOT             reduce using rule 42 (exp -> term MINUS exp .)
    COMMA           reduce using rule 42 (exp -> term MINUS exp .)
    SEMIC           reduce using rule 42 (exp -> term MINUS exp .)


state 110

    (37) expresion -> exp LESSTHAN exp .

    COMMA           reduce using rule 37 (expresion -> exp LESSTHAN exp .)
    SEMIC           reduce using rule 37 (expresion -> exp LESSTHAN exp .)
    DOT             reduce using rule 37 (expresion -> exp LESSTHAN exp .)
    RPAREN          reduce using rule 37 (expresion -> exp LESSTHAN exp .)
    RBRACKET        reduce using rule 37 (expresion -> exp LESSTHAN exp .)


state 111

    (38) expresion -> exp GREATERTHAN exp .

    COMMA           reduce using rule 38 (expresion -> exp GREATERTHAN exp .)
    SEMIC           reduce using rule 38 (expresion -> exp GREATERTHAN exp .)
    DOT             reduce using rule 38 (expresion -> exp GREATERTHAN exp .)
    RPAREN          reduce using rule 38 (expresion -> exp GREATERTHAN exp .)
    RBRACKET        reduce using rule 38 (expresion -> exp GREATERTHAN exp .)


state 112

    (39) expresion -> exp BETWEEN exp .

    COMMA           reduce using rule 39 (expresion -> exp BETWEEN exp .)
    SEMIC           reduce using rule 39 (expresion -> exp BETWEEN exp .)
    DOT             reduce using rule 39 (expresion -> exp BETWEEN exp .)
    RPAREN          reduce using rule 39 (expresion -> exp BETWEEN exp .)
    RBRACKET        reduce using rule 39 (expresion -> exp BETWEEN exp .)


state 113

    (79) lid -> COMMA listofids .

    SEMIC           reduce using rule 79 (lid -> COMMA listofids .)


state 114

    (82) lvars -> listofvars .

    RCURLY          reduce using rule 82 (lvars -> listofvars .)


state 115

    (84) listofvars -> declaracion POINTS listofids SEMIC lvars .

    RCURLY          reduce using rule 84 (listofvars -> declaracion POINTS listofids SEMIC lvars .)


state 116

    (83) lvars -> empty .

    RCURLY          reduce using rule 83 (lvars -> empty .)


state 117

    (10) data -> DATA LCURLY asignmany . RCURLY

    RCURLY          shift and go to state 134


state 118

    (11) asignmany -> asign . SEMIC asignlist
    (12) asignmany -> asign .

    SEMIC           shift and go to state 135
    RCURLY          reduce using rule 12 (asignmany -> asign .)


state 119

    (15) optimize -> MIN EQUALS statement .

    ID              reduce using rule 15 (optimize -> MIN EQUALS statement .)
    IF              reduce using rule 15 (optimize -> MIN EQUALS statement .)
    PRINT           reduce using rule 15 (optimize -> MIN EQUALS statement .)
    MIN             reduce using rule 15 (optimize -> MIN EQUALS statement .)
    MAX             reduce using rule 15 (optimize -> MIN EQUALS statement .)
    FOR             reduce using rule 15 (optimize -> MIN EQUALS statement .)
    RETURN          reduce using rule 15 (optimize -> MIN EQUALS statement .)
    SEMIC           reduce using rule 15 (optimize -> MIN EQUALS statement .)
    ELSE            reduce using rule 15 (optimize -> MIN EQUALS statement .)
    RCURLY          reduce using rule 15 (optimize -> MIN EQUALS statement .)


state 120

    (45) write2 -> CTESTRING .
    (47) write2 -> CTESTRING . DOT write2
    (3) constant -> CTESTRING .

  ! shift/reduce conflict for DOT resolved as shift
  ! reduce/reduce conflict for RPAREN resolved using rule 3 (constant -> CTESTRING .)
    DOT             shift and go to state 136
    STAR            reduce using rule 3 (constant -> CTESTRING .)
    SLASH           reduce using rule 3 (constant -> CTESTRING .)
    PLUS            reduce using rule 3 (constant -> CTESTRING .)
    MINUS           reduce using rule 3 (constant -> CTESTRING .)
    LESSTHAN        reduce using rule 3 (constant -> CTESTRING .)
    GREATERTHAN     reduce using rule 3 (constant -> CTESTRING .)
    BETWEEN         reduce using rule 3 (constant -> CTESTRING .)
    RPAREN          reduce using rule 3 (constant -> CTESTRING .)

  ! RPAREN          [ reduce using rule 45 (write2 -> CTESTRING .) ]
  ! DOT             [ reduce using rule 3 (constant -> CTESTRING .) ]


state 121

    (44) write2 -> expresion .
    (46) write2 -> expresion . DOT write2

    RPAREN          reduce using rule 44 (write2 -> expresion .)
    DOT             shift and go to state 137


state 122

    (43) write -> PRINT LPAREN write2 . RPAREN SEMIC

    RPAREN          shift and go to state 138


state 123

    (20) for -> FOR ID IN . DOT ID LCURLY block2 RCURLY

    DOT             shift and go to state 139


state 124

    (48) asign -> ID EQUALS expresiones . SEMIC

    SEMIC           shift and go to state 140


state 125

    (34) expresiones -> expresion . COMMA expresiones
    (35) expresiones -> expresion .

    COMMA           shift and go to state 141
    SEMIC           reduce using rule 35 (expresiones -> expresion .)


state 126

    (32) condition -> IF LPAREN expresion . RPAREN block SEMIC
    (33) condition -> IF LPAREN expresion . RPAREN block ELSE block SEMIC

    RPAREN          shift and go to state 142


state 127

    (16) optimize -> MAX EQUALS statement .

    ID              reduce using rule 16 (optimize -> MAX EQUALS statement .)
    IF              reduce using rule 16 (optimize -> MAX EQUALS statement .)
    PRINT           reduce using rule 16 (optimize -> MAX EQUALS statement .)
    MIN             reduce using rule 16 (optimize -> MAX EQUALS statement .)
    MAX             reduce using rule 16 (optimize -> MAX EQUALS statement .)
    FOR             reduce using rule 16 (optimize -> MAX EQUALS statement .)
    RETURN          reduce using rule 16 (optimize -> MAX EQUALS statement .)
    SEMIC           reduce using rule 16 (optimize -> MAX EQUALS statement .)
    ELSE            reduce using rule 16 (optimize -> MAX EQUALS statement .)
    RCURLY          reduce using rule 16 (optimize -> MAX EQUALS statement .)


state 128

    (61) liargs -> COMMA manyargs .

    RPAREN          reduce using rule 61 (liargs -> COMMA manyargs .)


state 129

    (57) function -> FUNC ID LPAREN manyargs RPAREN LCURLY varsdata . block2 RCURLY
    (64) block2 -> . statement block2
    (65) block2 -> . statement
    (66) block2 -> . empty
    (49) statement -> . asign
    (50) statement -> . condition
    (51) statement -> . write
    (52) statement -> . optimize
    (53) statement -> . for
    (54) statement -> . return
    (93) empty -> .
    (48) asign -> . ID EQUALS expresiones SEMIC
    (32) condition -> . IF LPAREN expresion RPAREN block SEMIC
    (33) condition -> . IF LPAREN expresion RPAREN block ELSE block SEMIC
    (43) write -> . PRINT LPAREN write2 RPAREN SEMIC
    (15) optimize -> . MIN EQUALS statement
    (16) optimize -> . MAX EQUALS statement
    (20) for -> . FOR ID IN DOT ID LCURLY block2 RCURLY
    (56) return -> . RETURN asign

    RCURLY          reduce using rule 93 (empty -> .)
    ID              shift and go to state 62
    IF              shift and go to state 64
    PRINT           shift and go to state 54
    MIN             shift and go to state 53
    MAX             shift and go to state 65
    FOR             shift and go to state 61
    RETURN          shift and go to state 51

    return                         shift and go to state 60
    block2                         shift and go to state 143
    for                            shift and go to state 55
    asign                          shift and go to state 66
    write                          shift and go to state 57
    condition                      shift and go to state 63
    statement                      shift and go to state 58
    optimize                       shift and go to state 56
    empty                          shift and go to state 59

state 130

    (9) functioncall -> ID LPAREN CTEF RPAREN .

    STAR            reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    SLASH           reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    PLUS            reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    MINUS           reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    LESSTHAN        reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    GREATERTHAN     reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    BETWEEN         reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    RBRACKET        reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    DOT             reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    RPAREN          reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    COMMA           reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    SEMIC           reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)


state 131

    (7) functioncall -> ID LPAREN expresion RPAREN .

    STAR            reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    SLASH           reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    PLUS            reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    MINUS           reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    LESSTHAN        reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    GREATERTHAN     reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    BETWEEN         reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    RBRACKET        reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    DOT             reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    RPAREN          reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    COMMA           reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    SEMIC           reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)


state 132

    (8) functioncall -> ID LPAREN CTEI RPAREN .

    STAR            reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    SLASH           reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    PLUS            reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    MINUS           reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    LESSTHAN        reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    GREATERTHAN     reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    BETWEEN         reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    RBRACKET        reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    DOT             reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    RPAREN          reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    COMMA           reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    SEMIC           reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)


state 133

    (71) matrix -> LBRACKET expresion RBRACKET LBRACKET expresion . RBRACKET

    RBRACKET        shift and go to state 144


state 134

    (10) data -> DATA LCURLY asignmany RCURLY .

    ID              reduce using rule 10 (data -> DATA LCURLY asignmany RCURLY .)
    IF              reduce using rule 10 (data -> DATA LCURLY asignmany RCURLY .)
    PRINT           reduce using rule 10 (data -> DATA LCURLY asignmany RCURLY .)
    MIN             reduce using rule 10 (data -> DATA LCURLY asignmany RCURLY .)
    MAX             reduce using rule 10 (data -> DATA LCURLY asignmany RCURLY .)
    FOR             reduce using rule 10 (data -> DATA LCURLY asignmany RCURLY .)
    RETURN          reduce using rule 10 (data -> DATA LCURLY asignmany RCURLY .)
    RCURLY          reduce using rule 10 (data -> DATA LCURLY asignmany RCURLY .)


state 135

    (11) asignmany -> asign SEMIC . asignlist
    (13) asignlist -> . empty
    (14) asignlist -> . asignmany
    (93) empty -> .
    (11) asignmany -> . asign SEMIC asignlist
    (12) asignmany -> . asign
    (48) asign -> . ID EQUALS expresiones SEMIC

    RCURLY          reduce using rule 93 (empty -> .)
    ID              shift and go to state 62

    asignmany                      shift and go to state 145
    asignlist                      shift and go to state 146
    empty                          shift and go to state 147
    asign                          shift and go to state 118

state 136

    (47) write2 -> CTESTRING DOT . write2
    (44) write2 -> . expresion
    (45) write2 -> . CTESTRING
    (46) write2 -> . expresion DOT write2
    (47) write2 -> . CTESTRING DOT write2
    (36) expresion -> . exp
    (37) expresion -> . exp LESSTHAN exp
    (38) expresion -> . exp GREATERTHAN exp
    (39) expresion -> . exp BETWEEN exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . id
    (6) constant -> . functioncall
    (73) id -> . ID array
    (74) id -> . ID matrix
    (75) id -> . ID
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    CTESTRING       shift and go to state 120
    PLUS            shift and go to state 36
    MINUS           shift and go to state 35
    LPAREN          shift and go to state 32
    CTEI            shift and go to state 45
    CTEF            shift and go to state 43
    CTEBOOL         shift and go to state 42
    ID              shift and go to state 39

    expresion                      shift and go to state 121
    term                           shift and go to state 41
    constant                       shift and go to state 33
    write2                         shift and go to state 148
    functioncall                   shift and go to state 38
    exp                            shift and go to state 44
    factor                         shift and go to state 37
    id                             shift and go to state 34

state 137

    (46) write2 -> expresion DOT . write2
    (44) write2 -> . expresion
    (45) write2 -> . CTESTRING
    (46) write2 -> . expresion DOT write2
    (47) write2 -> . CTESTRING DOT write2
    (36) expresion -> . exp
    (37) expresion -> . exp LESSTHAN exp
    (38) expresion -> . exp GREATERTHAN exp
    (39) expresion -> . exp BETWEEN exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . id
    (6) constant -> . functioncall
    (73) id -> . ID array
    (74) id -> . ID matrix
    (75) id -> . ID
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    CTESTRING       shift and go to state 120
    PLUS            shift and go to state 36
    MINUS           shift and go to state 35
    LPAREN          shift and go to state 32
    CTEI            shift and go to state 45
    CTEF            shift and go to state 43
    CTEBOOL         shift and go to state 42
    ID              shift and go to state 39

    expresion                      shift and go to state 121
    term                           shift and go to state 41
    constant                       shift and go to state 33
    write2                         shift and go to state 149
    functioncall                   shift and go to state 38
    exp                            shift and go to state 44
    factor                         shift and go to state 37
    id                             shift and go to state 34

state 138

    (43) write -> PRINT LPAREN write2 RPAREN . SEMIC

    SEMIC           shift and go to state 150


state 139

    (20) for -> FOR ID IN DOT . ID LCURLY block2 RCURLY

    ID              shift and go to state 151


state 140

    (48) asign -> ID EQUALS expresiones SEMIC .

    ID              reduce using rule 48 (asign -> ID EQUALS expresiones SEMIC .)
    IF              reduce using rule 48 (asign -> ID EQUALS expresiones SEMIC .)
    PRINT           reduce using rule 48 (asign -> ID EQUALS expresiones SEMIC .)
    MIN             reduce using rule 48 (asign -> ID EQUALS expresiones SEMIC .)
    MAX             reduce using rule 48 (asign -> ID EQUALS expresiones SEMIC .)
    FOR             reduce using rule 48 (asign -> ID EQUALS expresiones SEMIC .)
    RETURN          reduce using rule 48 (asign -> ID EQUALS expresiones SEMIC .)
    RCURLY          reduce using rule 48 (asign -> ID EQUALS expresiones SEMIC .)
    SEMIC           reduce using rule 48 (asign -> ID EQUALS expresiones SEMIC .)
    ELSE            reduce using rule 48 (asign -> ID EQUALS expresiones SEMIC .)


state 141

    (34) expresiones -> expresion COMMA . expresiones
    (34) expresiones -> . expresion COMMA expresiones
    (35) expresiones -> . expresion
    (36) expresion -> . exp
    (37) expresion -> . exp LESSTHAN exp
    (38) expresion -> . exp GREATERTHAN exp
    (39) expresion -> . exp BETWEEN exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . id
    (6) constant -> . functioncall
    (73) id -> . ID array
    (74) id -> . ID matrix
    (75) id -> . ID
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 36
    MINUS           shift and go to state 35
    LPAREN          shift and go to state 32
    CTEI            shift and go to state 45
    CTEF            shift and go to state 43
    CTESTRING       shift and go to state 46
    CTEBOOL         shift and go to state 42
    ID              shift and go to state 39

    expresion                      shift and go to state 125
    expresiones                    shift and go to state 152
    constant                       shift and go to state 33
    term                           shift and go to state 41
    functioncall                   shift and go to state 38
    exp                            shift and go to state 44
    factor                         shift and go to state 37
    id                             shift and go to state 34

state 142

    (32) condition -> IF LPAREN expresion RPAREN . block SEMIC
    (33) condition -> IF LPAREN expresion RPAREN . block ELSE block SEMIC
    (62) block -> . block2
    (63) block -> . LCURLY RCURLY
    (64) block2 -> . statement block2
    (65) block2 -> . statement
    (66) block2 -> . empty
    (49) statement -> . asign
    (50) statement -> . condition
    (51) statement -> . write
    (52) statement -> . optimize
    (53) statement -> . for
    (54) statement -> . return
    (93) empty -> .
    (48) asign -> . ID EQUALS expresiones SEMIC
    (32) condition -> . IF LPAREN expresion RPAREN block SEMIC
    (33) condition -> . IF LPAREN expresion RPAREN block ELSE block SEMIC
    (43) write -> . PRINT LPAREN write2 RPAREN SEMIC
    (15) optimize -> . MIN EQUALS statement
    (16) optimize -> . MAX EQUALS statement
    (20) for -> . FOR ID IN DOT ID LCURLY block2 RCURLY
    (56) return -> . RETURN asign

    LCURLY          shift and go to state 154
    SEMIC           reduce using rule 93 (empty -> .)
    ELSE            reduce using rule 93 (empty -> .)
    ID              shift and go to state 62
    IF              shift and go to state 64
    PRINT           shift and go to state 54
    MIN             shift and go to state 53
    MAX             shift and go to state 65
    FOR             shift and go to state 61
    RETURN          shift and go to state 51

    return                         shift and go to state 60
    block2                         shift and go to state 153
    for                            shift and go to state 55
    condition                      shift and go to state 63
    asign                          shift and go to state 66
    write                          shift and go to state 57
    block                          shift and go to state 155
    statement                      shift and go to state 58
    optimize                       shift and go to state 56
    empty                          shift and go to state 59

state 143

    (57) function -> FUNC ID LPAREN manyargs RPAREN LCURLY varsdata block2 . RCURLY

    RCURLY          shift and go to state 156


state 144

    (71) matrix -> LBRACKET expresion RBRACKET LBRACKET expresion RBRACKET .

    POINTS          reduce using rule 71 (matrix -> LBRACKET expresion RBRACKET LBRACKET expresion RBRACKET .)
    STAR            reduce using rule 71 (matrix -> LBRACKET expresion RBRACKET LBRACKET expresion RBRACKET .)
    SLASH           reduce using rule 71 (matrix -> LBRACKET expresion RBRACKET LBRACKET expresion RBRACKET .)
    PLUS            reduce using rule 71 (matrix -> LBRACKET expresion RBRACKET LBRACKET expresion RBRACKET .)
    MINUS           reduce using rule 71 (matrix -> LBRACKET expresion RBRACKET LBRACKET expresion RBRACKET .)
    LESSTHAN        reduce using rule 71 (matrix -> LBRACKET expresion RBRACKET LBRACKET expresion RBRACKET .)
    GREATERTHAN     reduce using rule 71 (matrix -> LBRACKET expresion RBRACKET LBRACKET expresion RBRACKET .)
    BETWEEN         reduce using rule 71 (matrix -> LBRACKET expresion RBRACKET LBRACKET expresion RBRACKET .)
    RBRACKET        reduce using rule 71 (matrix -> LBRACKET expresion RBRACKET LBRACKET expresion RBRACKET .)
    RPAREN          reduce using rule 71 (matrix -> LBRACKET expresion RBRACKET LBRACKET expresion RBRACKET .)
    DOT             reduce using rule 71 (matrix -> LBRACKET expresion RBRACKET LBRACKET expresion RBRACKET .)
    COMMA           reduce using rule 71 (matrix -> LBRACKET expresion RBRACKET LBRACKET expresion RBRACKET .)
    SEMIC           reduce using rule 71 (matrix -> LBRACKET expresion RBRACKET LBRACKET expresion RBRACKET .)


state 145

    (14) asignlist -> asignmany .

    RCURLY          reduce using rule 14 (asignlist -> asignmany .)


state 146

    (11) asignmany -> asign SEMIC asignlist .

    RCURLY          reduce using rule 11 (asignmany -> asign SEMIC asignlist .)


state 147

    (13) asignlist -> empty .

    RCURLY          reduce using rule 13 (asignlist -> empty .)


state 148

    (47) write2 -> CTESTRING DOT write2 .

    RPAREN          reduce using rule 47 (write2 -> CTESTRING DOT write2 .)


state 149

    (46) write2 -> expresion DOT write2 .

    RPAREN          reduce using rule 46 (write2 -> expresion DOT write2 .)


state 150

    (43) write -> PRINT LPAREN write2 RPAREN SEMIC .

    ID              reduce using rule 43 (write -> PRINT LPAREN write2 RPAREN SEMIC .)
    IF              reduce using rule 43 (write -> PRINT LPAREN write2 RPAREN SEMIC .)
    PRINT           reduce using rule 43 (write -> PRINT LPAREN write2 RPAREN SEMIC .)
    MIN             reduce using rule 43 (write -> PRINT LPAREN write2 RPAREN SEMIC .)
    MAX             reduce using rule 43 (write -> PRINT LPAREN write2 RPAREN SEMIC .)
    FOR             reduce using rule 43 (write -> PRINT LPAREN write2 RPAREN SEMIC .)
    RETURN          reduce using rule 43 (write -> PRINT LPAREN write2 RPAREN SEMIC .)
    RCURLY          reduce using rule 43 (write -> PRINT LPAREN write2 RPAREN SEMIC .)
    SEMIC           reduce using rule 43 (write -> PRINT LPAREN write2 RPAREN SEMIC .)
    ELSE            reduce using rule 43 (write -> PRINT LPAREN write2 RPAREN SEMIC .)


state 151

    (20) for -> FOR ID IN DOT ID . LCURLY block2 RCURLY

    LCURLY          shift and go to state 157


state 152

    (34) expresiones -> expresion COMMA expresiones .

    SEMIC           reduce using rule 34 (expresiones -> expresion COMMA expresiones .)


state 153

    (62) block -> block2 .

    SEMIC           reduce using rule 62 (block -> block2 .)
    ELSE            reduce using rule 62 (block -> block2 .)


state 154

    (63) block -> LCURLY . RCURLY

    RCURLY          shift and go to state 158


state 155

    (32) condition -> IF LPAREN expresion RPAREN block . SEMIC
    (33) condition -> IF LPAREN expresion RPAREN block . ELSE block SEMIC

    SEMIC           shift and go to state 159
    ELSE            shift and go to state 160


state 156

    (57) function -> FUNC ID LPAREN manyargs RPAREN LCURLY varsdata block2 RCURLY .

    MODEL           reduce using rule 57 (function -> FUNC ID LPAREN manyargs RPAREN LCURLY varsdata block2 RCURLY .)


state 157

    (20) for -> FOR ID IN DOT ID LCURLY . block2 RCURLY
    (64) block2 -> . statement block2
    (65) block2 -> . statement
    (66) block2 -> . empty
    (49) statement -> . asign
    (50) statement -> . condition
    (51) statement -> . write
    (52) statement -> . optimize
    (53) statement -> . for
    (54) statement -> . return
    (93) empty -> .
    (48) asign -> . ID EQUALS expresiones SEMIC
    (32) condition -> . IF LPAREN expresion RPAREN block SEMIC
    (33) condition -> . IF LPAREN expresion RPAREN block ELSE block SEMIC
    (43) write -> . PRINT LPAREN write2 RPAREN SEMIC
    (15) optimize -> . MIN EQUALS statement
    (16) optimize -> . MAX EQUALS statement
    (20) for -> . FOR ID IN DOT ID LCURLY block2 RCURLY
    (56) return -> . RETURN asign

    RCURLY          reduce using rule 93 (empty -> .)
    ID              shift and go to state 62
    IF              shift and go to state 64
    PRINT           shift and go to state 54
    MIN             shift and go to state 53
    MAX             shift and go to state 65
    FOR             shift and go to state 61
    RETURN          shift and go to state 51

    return                         shift and go to state 60
    block2                         shift and go to state 161
    for                            shift and go to state 55
    asign                          shift and go to state 66
    write                          shift and go to state 57
    condition                      shift and go to state 63
    statement                      shift and go to state 58
    optimize                       shift and go to state 56
    empty                          shift and go to state 59

state 158

    (63) block -> LCURLY RCURLY .

    SEMIC           reduce using rule 63 (block -> LCURLY RCURLY .)
    ELSE            reduce using rule 63 (block -> LCURLY RCURLY .)


state 159

    (32) condition -> IF LPAREN expresion RPAREN block SEMIC .

    ID              reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)
    IF              reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)
    PRINT           reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)
    MIN             reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)
    MAX             reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)
    FOR             reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)
    RETURN          reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)
    RCURLY          reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)
    SEMIC           reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)
    ELSE            reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)


state 160

    (33) condition -> IF LPAREN expresion RPAREN block ELSE . block SEMIC
    (62) block -> . block2
    (63) block -> . LCURLY RCURLY
    (64) block2 -> . statement block2
    (65) block2 -> . statement
    (66) block2 -> . empty
    (49) statement -> . asign
    (50) statement -> . condition
    (51) statement -> . write
    (52) statement -> . optimize
    (53) statement -> . for
    (54) statement -> . return
    (93) empty -> .
    (48) asign -> . ID EQUALS expresiones SEMIC
    (32) condition -> . IF LPAREN expresion RPAREN block SEMIC
    (33) condition -> . IF LPAREN expresion RPAREN block ELSE block SEMIC
    (43) write -> . PRINT LPAREN write2 RPAREN SEMIC
    (15) optimize -> . MIN EQUALS statement
    (16) optimize -> . MAX EQUALS statement
    (20) for -> . FOR ID IN DOT ID LCURLY block2 RCURLY
    (56) return -> . RETURN asign

    LCURLY          shift and go to state 154
    SEMIC           reduce using rule 93 (empty -> .)
    ID              shift and go to state 62
    IF              shift and go to state 64
    PRINT           shift and go to state 54
    MIN             shift and go to state 53
    MAX             shift and go to state 65
    FOR             shift and go to state 61
    RETURN          shift and go to state 51

    return                         shift and go to state 60
    block2                         shift and go to state 153
    for                            shift and go to state 55
    condition                      shift and go to state 63
    asign                          shift and go to state 66
    write                          shift and go to state 57
    block                          shift and go to state 162
    statement                      shift and go to state 58
    optimize                       shift and go to state 56
    empty                          shift and go to state 59

state 161

    (20) for -> FOR ID IN DOT ID LCURLY block2 . RCURLY

    RCURLY          shift and go to state 163


state 162

    (33) condition -> IF LPAREN expresion RPAREN block ELSE block . SEMIC

    SEMIC           shift and go to state 164


state 163

    (20) for -> FOR ID IN DOT ID LCURLY block2 RCURLY .

    ID              reduce using rule 20 (for -> FOR ID IN DOT ID LCURLY block2 RCURLY .)
    IF              reduce using rule 20 (for -> FOR ID IN DOT ID LCURLY block2 RCURLY .)
    PRINT           reduce using rule 20 (for -> FOR ID IN DOT ID LCURLY block2 RCURLY .)
    MIN             reduce using rule 20 (for -> FOR ID IN DOT ID LCURLY block2 RCURLY .)
    MAX             reduce using rule 20 (for -> FOR ID IN DOT ID LCURLY block2 RCURLY .)
    FOR             reduce using rule 20 (for -> FOR ID IN DOT ID LCURLY block2 RCURLY .)
    RETURN          reduce using rule 20 (for -> FOR ID IN DOT ID LCURLY block2 RCURLY .)
    RCURLY          reduce using rule 20 (for -> FOR ID IN DOT ID LCURLY block2 RCURLY .)
    SEMIC           reduce using rule 20 (for -> FOR ID IN DOT ID LCURLY block2 RCURLY .)
    ELSE            reduce using rule 20 (for -> FOR ID IN DOT ID LCURLY block2 RCURLY .)


state 164

    (33) condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .

    ID              reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)
    IF              reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)
    PRINT           reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)
    MIN             reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)
    MAX             reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)
    FOR             reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)
    RETURN          reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)
    RCURLY          reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)
    SEMIC           reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)
    ELSE            reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for RPAREN in state 104 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 106 resolved as shift
WARNING: shift/reduce conflict for DOT in state 120 resolved as shift
WARNING: reduce/reduce conflict in state 58 resolved using rule (block2 -> statement)
WARNING: rejected rule (empty -> <empty>) in state 58
WARNING: reduce/reduce conflict in state 120 resolved using rule (constant -> CTESTRING)
WARNING: rejected rule (write2 -> CTESTRING) in state 120
WARNING: Rule (write2 -> CTESTRING) is never reduced
