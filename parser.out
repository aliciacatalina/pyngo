Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     constant -> CTEI
Rule 2     constant -> CTEF
Rule 3     constant -> CTESTRING
Rule 4     constant -> CTEBOOL
Rule 5     constant -> id
Rule 6     constant -> functioncall
Rule 7     functioncall -> ID LPAREN expresion RPAREN
Rule 8     functioncall -> ID LPAREN CTEI RPAREN
Rule 9     functioncall -> ID LPAREN CTEF RPAREN
Rule 10    data -> DATA LCURLY asignmany RCURLY
Rule 11    asignmany -> asign SEMIC asignlist
Rule 12    asignmany -> asign
Rule 13    asignlist -> empty
Rule 14    asignlist -> asignmany
Rule 15    optimize -> MIN EQUALS statement
Rule 16    optimize -> MAX EQUALS statement
Rule 17    restrictions -> WHERE restrictions2
Rule 18    restrictions2 -> expresion
Rule 19    restrictions2 -> sum SEMIC forlist
Rule 20    for -> FOR ID IN DOT ID LCURLY block2 RCURLY
Rule 21    forlist -> for SEMIC lfor
Rule 22    lfor -> empty
Rule 23    lfor -> forlist
Rule 24    sum -> SUM LPAREN ID POINTS expresion RPAREN
Rule 25    factor -> PLUS constant
Rule 26    factor -> MINUS constant
Rule 27    factor -> constant
Rule 28    factor -> LPAREN expresion RPAREN
Rule 29    term -> factor
Rule 30    term -> factor STAR term
Rule 31    term -> factor SLASH term
Rule 32    condition -> IF LPAREN expresion RPAREN block SEMIC
Rule 33    condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC
Rule 34    expresiones -> expresion COMMA expresiones
Rule 35    expresiones -> expresion
Rule 36    expresion -> exp
Rule 37    expresion -> exp LESSTHAN exp
Rule 38    expresion -> exp GREATERTHAN exp
Rule 39    expresion -> exp BETWEEN exp
Rule 40    exp -> term
Rule 41    exp -> term PLUS exp
Rule 42    exp -> term MINUS exp
Rule 43    write -> PRINT LPAREN write2 RPAREN SEMIC
Rule 44    write2 -> expresion
Rule 45    write2 -> CTESTRING
Rule 46    write2 -> expresion DOT write2
Rule 47    write2 -> CTESTRING DOT write2
Rule 48    asign -> ID EQUALS expresiones SEMIC
Rule 49    statement -> asign
Rule 50    statement -> condition
Rule 51    statement -> write
Rule 52    statement -> optimize
Rule 53    statement -> for
Rule 54    statement -> return
Rule 55    loop -> for
Rule 56    return -> RETURN asign
Rule 57    function -> FUNC ID LPAREN manyargs RPAREN LCURLY varsdata block2 RCURLY
Rule 58    manyargs -> empty
Rule 59    manyargs -> tipo ID liargs
Rule 60    liargs -> empty
Rule 61    liargs -> COMMA manyargs
Rule 62    block -> block2
Rule 63    block -> LCURLY RCURLY
Rule 64    block2 -> statement block2
Rule 65    block2 -> statement
Rule 66    block2 -> empty
Rule 67    tipo -> TINT
Rule 68    tipo -> TFLOAT
Rule 69    tipo -> TBOOL
Rule 70    vars -> VARS LCURLY lvars RCURLY
Rule 71    matrix -> LBRACKET expresion RBRACKET LBRACKET expresion RBRACKET
Rule 72    array -> LBRACKET expresion RBRACKET
Rule 73    id -> ID array
Rule 74    id -> ID matrix
Rule 75    id -> ID
Rule 76    declaracion -> tipo array
Rule 77    declaracion -> tipo matrix
Rule 78    declaracion -> tipo
Rule 79    lid -> COMMA listofids
Rule 80    lid -> empty
Rule 81    listofids -> ID lid
Rule 82    lvars -> listofvars lvars
Rule 83    lvars -> listofvars
Rule 84    lvars -> empty
Rule 85    listofvars -> declaracion POINTS listofids SEMIC
Rule 86    varsdata -> vars data
Rule 87    varsdata -> empty
Rule 88    varsdata -> vars
Rule 89    declarefunc -> function
Rule 90    declarefunc -> empty
Rule 91    declarevars -> vars
Rule 92    declarevars -> empty
Rule 93    program -> declarevars declarefunc MODEL LCURLY varsdata block2 RCURLY
Rule 94    empty -> <empty>

Terminals, with rules where they appear

BETWEEN              : 39
COMMA                : 34 61 79
CTEBOOL              : 4
CTEF                 : 2 9
CTEI                 : 1 8
CTESTRING            : 3 45 47
DATA                 : 10
DOT                  : 20 46 47
ELSE                 : 33
EQUALS               : 15 16 48
FOR                  : 20
FUNC                 : 57
GREATERTHAN          : 38
ID                   : 7 8 9 20 20 24 48 57 59 73 74 75 81
IF                   : 32 33
IN                   : 20
LBRACKET             : 71 71 72
LCURLY               : 10 20 57 63 70 93
LESSTHAN             : 37
LPAREN               : 7 8 9 24 28 32 33 43 57
MAX                  : 16
MIN                  : 15
MINUS                : 26 42
MODEL                : 93
PLUS                 : 25 41
POINTS               : 24 85
PRINT                : 43
RBRACKET             : 71 71 72
RCURLY               : 10 20 57 63 70 93
RETURN               : 56
RPAREN               : 7 8 9 24 28 32 33 43 57
SEMIC                : 11 19 21 32 33 43 48 85
SLASH                : 31
STAR                 : 30
SUM                  : 24
TBOOL                : 69
TFLOAT               : 68
TINT                 : 67
VARS                 : 70
WHERE                : 17
error                : 

Nonterminals, with rules where they appear

array                : 73 76
asign                : 11 12 49 56
asignlist            : 11
asignmany            : 10 14
block                : 32 33 33
block2               : 20 57 62 64 93
condition            : 50
constant             : 25 26 27
data                 : 86
declaracion          : 85
declarefunc          : 93
declarevars          : 93
empty                : 13 22 58 60 66 80 84 87 90 92
exp                  : 36 37 37 38 38 39 39 41 42
expresion            : 7 18 24 28 32 33 34 35 44 46 71 71 72
expresiones          : 34 48
factor               : 29 30 31
for                  : 21 53 55
forlist              : 19 23
function             : 89
functioncall         : 6
id                   : 5
lfor                 : 21
liargs               : 59
lid                  : 81
listofids            : 79 85
listofvars           : 82 83
loop                 : 
lvars                : 70 82
manyargs             : 57 61
matrix               : 74 77
optimize             : 52
program              : 0
restrictions         : 
restrictions2        : 17
return               : 54
statement            : 15 16 64 65
sum                  : 19
term                 : 30 31 40 41 42
tipo                 : 59 76 77 78
vars                 : 86 88 91
varsdata             : 57 93
write                : 51
write2               : 43 46 47

Parsing method: LALR

state 0

    (0) S' -> . program
    (93) program -> . declarevars declarefunc MODEL LCURLY varsdata block2 RCURLY
    (91) declarevars -> . vars
    (92) declarevars -> . empty
    (70) vars -> . VARS LCURLY lvars RCURLY
    (94) empty -> .

    VARS            shift and go to state 4
    FUNC            reduce using rule 94 (empty -> .)
    MODEL           reduce using rule 94 (empty -> .)

    program                        shift and go to state 1
    declarevars                    shift and go to state 2
    vars                           shift and go to state 3
    empty                          shift and go to state 5

state 1

    (0) S' -> program .



state 2

    (93) program -> declarevars . declarefunc MODEL LCURLY varsdata block2 RCURLY
    (89) declarefunc -> . function
    (90) declarefunc -> . empty
    (57) function -> . FUNC ID LPAREN manyargs RPAREN LCURLY varsdata block2 RCURLY
    (94) empty -> .

    FUNC            shift and go to state 8
    MODEL           reduce using rule 94 (empty -> .)

    function                       shift and go to state 6
    declarefunc                    shift and go to state 7
    empty                          shift and go to state 9

state 3

    (91) declarevars -> vars .

    FUNC            reduce using rule 91 (declarevars -> vars .)
    MODEL           reduce using rule 91 (declarevars -> vars .)


state 4

    (70) vars -> VARS . LCURLY lvars RCURLY

    LCURLY          shift and go to state 10


state 5

    (92) declarevars -> empty .

    FUNC            reduce using rule 92 (declarevars -> empty .)
    MODEL           reduce using rule 92 (declarevars -> empty .)


state 6

    (89) declarefunc -> function .

    MODEL           reduce using rule 89 (declarefunc -> function .)


state 7

    (93) program -> declarevars declarefunc . MODEL LCURLY varsdata block2 RCURLY

    MODEL           shift and go to state 11


state 8

    (57) function -> FUNC . ID LPAREN manyargs RPAREN LCURLY varsdata block2 RCURLY

    ID              shift and go to state 12


state 9

    (90) declarefunc -> empty .

    MODEL           reduce using rule 90 (declarefunc -> empty .)


state 10

    (70) vars -> VARS LCURLY . lvars RCURLY
    (82) lvars -> . listofvars lvars
    (83) lvars -> . listofvars
    (84) lvars -> . empty
    (85) listofvars -> . declaracion POINTS listofids SEMIC
    (94) empty -> .
    (76) declaracion -> . tipo array
    (77) declaracion -> . tipo matrix
    (78) declaracion -> . tipo
    (67) tipo -> . TINT
    (68) tipo -> . TFLOAT
    (69) tipo -> . TBOOL

    RCURLY          reduce using rule 94 (empty -> .)
    TINT            shift and go to state 13
    TFLOAT          shift and go to state 19
    TBOOL           shift and go to state 18

    tipo                           shift and go to state 14
    listofvars                     shift and go to state 15
    lvars                          shift and go to state 16
    empty                          shift and go to state 20
    declaracion                    shift and go to state 17

state 11

    (93) program -> declarevars declarefunc MODEL . LCURLY varsdata block2 RCURLY

    LCURLY          shift and go to state 21


state 12

    (57) function -> FUNC ID . LPAREN manyargs RPAREN LCURLY varsdata block2 RCURLY

    LPAREN          shift and go to state 22


state 13

    (67) tipo -> TINT .

    ID              reduce using rule 67 (tipo -> TINT .)
    LBRACKET        reduce using rule 67 (tipo -> TINT .)
    POINTS          reduce using rule 67 (tipo -> TINT .)


state 14

    (76) declaracion -> tipo . array
    (77) declaracion -> tipo . matrix
    (78) declaracion -> tipo .
    (72) array -> . LBRACKET expresion RBRACKET
    (71) matrix -> . LBRACKET expresion RBRACKET LBRACKET expresion RBRACKET

    POINTS          reduce using rule 78 (declaracion -> tipo .)
    LBRACKET        shift and go to state 24

    array                          shift and go to state 25
    matrix                         shift and go to state 23

state 15

    (82) lvars -> listofvars . lvars
    (83) lvars -> listofvars .
    (82) lvars -> . listofvars lvars
    (83) lvars -> . listofvars
    (84) lvars -> . empty
    (85) listofvars -> . declaracion POINTS listofids SEMIC
    (94) empty -> .
    (76) declaracion -> . tipo array
    (77) declaracion -> . tipo matrix
    (78) declaracion -> . tipo
    (67) tipo -> . TINT
    (68) tipo -> . TFLOAT
    (69) tipo -> . TBOOL

  ! reduce/reduce conflict for RCURLY resolved using rule 83 (lvars -> listofvars .)
    RCURLY          reduce using rule 83 (lvars -> listofvars .)
    TINT            shift and go to state 13
    TFLOAT          shift and go to state 19
    TBOOL           shift and go to state 18

  ! RCURLY          [ reduce using rule 94 (empty -> .) ]

    tipo                           shift and go to state 14
    listofvars                     shift and go to state 15
    lvars                          shift and go to state 26
    empty                          shift and go to state 20
    declaracion                    shift and go to state 17

state 16

    (70) vars -> VARS LCURLY lvars . RCURLY

    RCURLY          shift and go to state 27


state 17

    (85) listofvars -> declaracion . POINTS listofids SEMIC

    POINTS          shift and go to state 28


state 18

    (69) tipo -> TBOOL .

    ID              reduce using rule 69 (tipo -> TBOOL .)
    LBRACKET        reduce using rule 69 (tipo -> TBOOL .)
    POINTS          reduce using rule 69 (tipo -> TBOOL .)


state 19

    (68) tipo -> TFLOAT .

    ID              reduce using rule 68 (tipo -> TFLOAT .)
    LBRACKET        reduce using rule 68 (tipo -> TFLOAT .)
    POINTS          reduce using rule 68 (tipo -> TFLOAT .)


state 20

    (84) lvars -> empty .

    RCURLY          reduce using rule 84 (lvars -> empty .)


state 21

    (93) program -> declarevars declarefunc MODEL LCURLY . varsdata block2 RCURLY
    (86) varsdata -> . vars data
    (87) varsdata -> . empty
    (88) varsdata -> . vars
    (70) vars -> . VARS LCURLY lvars RCURLY
    (94) empty -> .

    VARS            shift and go to state 4
    ID              reduce using rule 94 (empty -> .)
    IF              reduce using rule 94 (empty -> .)
    PRINT           reduce using rule 94 (empty -> .)
    MIN             reduce using rule 94 (empty -> .)
    MAX             reduce using rule 94 (empty -> .)
    FOR             reduce using rule 94 (empty -> .)
    RETURN          reduce using rule 94 (empty -> .)
    RCURLY          reduce using rule 94 (empty -> .)

    vars                           shift and go to state 29
    varsdata                       shift and go to state 30
    empty                          shift and go to state 31

state 22

    (57) function -> FUNC ID LPAREN . manyargs RPAREN LCURLY varsdata block2 RCURLY
    (58) manyargs -> . empty
    (59) manyargs -> . tipo ID liargs
    (94) empty -> .
    (67) tipo -> . TINT
    (68) tipo -> . TFLOAT
    (69) tipo -> . TBOOL

    RPAREN          reduce using rule 94 (empty -> .)
    TINT            shift and go to state 13
    TFLOAT          shift and go to state 19
    TBOOL           shift and go to state 18

    tipo                           shift and go to state 32
    manyargs                       shift and go to state 33
    empty                          shift and go to state 34

state 23

    (77) declaracion -> tipo matrix .

    POINTS          reduce using rule 77 (declaracion -> tipo matrix .)


state 24

    (72) array -> LBRACKET . expresion RBRACKET
    (71) matrix -> LBRACKET . expresion RBRACKET LBRACKET expresion RBRACKET
    (36) expresion -> . exp
    (37) expresion -> . exp LESSTHAN exp
    (38) expresion -> . exp GREATERTHAN exp
    (39) expresion -> . exp BETWEEN exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . id
    (6) constant -> . functioncall
    (73) id -> . ID array
    (74) id -> . ID matrix
    (75) id -> . ID
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 39
    MINUS           shift and go to state 38
    LPAREN          shift and go to state 35
    CTEI            shift and go to state 48
    CTEF            shift and go to state 46
    CTESTRING       shift and go to state 49
    CTEBOOL         shift and go to state 45
    ID              shift and go to state 42

    expresion                      shift and go to state 43
    term                           shift and go to state 44
    constant                       shift and go to state 36
    functioncall                   shift and go to state 41
    exp                            shift and go to state 47
    factor                         shift and go to state 40
    id                             shift and go to state 37

state 25

    (76) declaracion -> tipo array .

    POINTS          reduce using rule 76 (declaracion -> tipo array .)


state 26

    (82) lvars -> listofvars lvars .

    RCURLY          reduce using rule 82 (lvars -> listofvars lvars .)


state 27

    (70) vars -> VARS LCURLY lvars RCURLY .

    DATA            reduce using rule 70 (vars -> VARS LCURLY lvars RCURLY .)
    ID              reduce using rule 70 (vars -> VARS LCURLY lvars RCURLY .)
    IF              reduce using rule 70 (vars -> VARS LCURLY lvars RCURLY .)
    PRINT           reduce using rule 70 (vars -> VARS LCURLY lvars RCURLY .)
    MIN             reduce using rule 70 (vars -> VARS LCURLY lvars RCURLY .)
    MAX             reduce using rule 70 (vars -> VARS LCURLY lvars RCURLY .)
    FOR             reduce using rule 70 (vars -> VARS LCURLY lvars RCURLY .)
    RETURN          reduce using rule 70 (vars -> VARS LCURLY lvars RCURLY .)
    RCURLY          reduce using rule 70 (vars -> VARS LCURLY lvars RCURLY .)
    FUNC            reduce using rule 70 (vars -> VARS LCURLY lvars RCURLY .)
    MODEL           reduce using rule 70 (vars -> VARS LCURLY lvars RCURLY .)


state 28

    (85) listofvars -> declaracion POINTS . listofids SEMIC
    (81) listofids -> . ID lid

    ID              shift and go to state 51

    listofids                      shift and go to state 50

state 29

    (86) varsdata -> vars . data
    (88) varsdata -> vars .
    (10) data -> . DATA LCURLY asignmany RCURLY

    ID              reduce using rule 88 (varsdata -> vars .)
    IF              reduce using rule 88 (varsdata -> vars .)
    PRINT           reduce using rule 88 (varsdata -> vars .)
    MIN             reduce using rule 88 (varsdata -> vars .)
    MAX             reduce using rule 88 (varsdata -> vars .)
    FOR             reduce using rule 88 (varsdata -> vars .)
    RETURN          reduce using rule 88 (varsdata -> vars .)
    RCURLY          reduce using rule 88 (varsdata -> vars .)
    DATA            shift and go to state 53

    data                           shift and go to state 52

state 30

    (93) program -> declarevars declarefunc MODEL LCURLY varsdata . block2 RCURLY
    (64) block2 -> . statement block2
    (65) block2 -> . statement
    (66) block2 -> . empty
    (49) statement -> . asign
    (50) statement -> . condition
    (51) statement -> . write
    (52) statement -> . optimize
    (53) statement -> . for
    (54) statement -> . return
    (94) empty -> .
    (48) asign -> . ID EQUALS expresiones SEMIC
    (32) condition -> . IF LPAREN expresion RPAREN block SEMIC
    (33) condition -> . IF LPAREN expresion RPAREN block ELSE block SEMIC
    (43) write -> . PRINT LPAREN write2 RPAREN SEMIC
    (15) optimize -> . MIN EQUALS statement
    (16) optimize -> . MAX EQUALS statement
    (20) for -> . FOR ID IN DOT ID LCURLY block2 RCURLY
    (56) return -> . RETURN asign

    RCURLY          reduce using rule 94 (empty -> .)
    ID              shift and go to state 65
    IF              shift and go to state 67
    PRINT           shift and go to state 57
    MIN             shift and go to state 56
    MAX             shift and go to state 68
    FOR             shift and go to state 64
    RETURN          shift and go to state 54

    return                         shift and go to state 63
    block2                         shift and go to state 55
    for                            shift and go to state 58
    asign                          shift and go to state 69
    write                          shift and go to state 60
    condition                      shift and go to state 66
    statement                      shift and go to state 61
    optimize                       shift and go to state 59
    empty                          shift and go to state 62

state 31

    (87) varsdata -> empty .

    ID              reduce using rule 87 (varsdata -> empty .)
    IF              reduce using rule 87 (varsdata -> empty .)
    PRINT           reduce using rule 87 (varsdata -> empty .)
    MIN             reduce using rule 87 (varsdata -> empty .)
    MAX             reduce using rule 87 (varsdata -> empty .)
    FOR             reduce using rule 87 (varsdata -> empty .)
    RETURN          reduce using rule 87 (varsdata -> empty .)
    RCURLY          reduce using rule 87 (varsdata -> empty .)


state 32

    (59) manyargs -> tipo . ID liargs

    ID              shift and go to state 70


state 33

    (57) function -> FUNC ID LPAREN manyargs . RPAREN LCURLY varsdata block2 RCURLY

    RPAREN          shift and go to state 71


state 34

    (58) manyargs -> empty .

    RPAREN          reduce using rule 58 (manyargs -> empty .)


state 35

    (28) factor -> LPAREN . expresion RPAREN
    (36) expresion -> . exp
    (37) expresion -> . exp LESSTHAN exp
    (38) expresion -> . exp GREATERTHAN exp
    (39) expresion -> . exp BETWEEN exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . id
    (6) constant -> . functioncall
    (73) id -> . ID array
    (74) id -> . ID matrix
    (75) id -> . ID
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 39
    MINUS           shift and go to state 38
    LPAREN          shift and go to state 35
    CTEI            shift and go to state 48
    CTEF            shift and go to state 46
    CTESTRING       shift and go to state 49
    CTEBOOL         shift and go to state 45
    ID              shift and go to state 42

    expresion                      shift and go to state 72
    term                           shift and go to state 44
    constant                       shift and go to state 36
    functioncall                   shift and go to state 41
    exp                            shift and go to state 47
    factor                         shift and go to state 40
    id                             shift and go to state 37

state 36

    (27) factor -> constant .

    STAR            reduce using rule 27 (factor -> constant .)
    SLASH           reduce using rule 27 (factor -> constant .)
    PLUS            reduce using rule 27 (factor -> constant .)
    MINUS           reduce using rule 27 (factor -> constant .)
    LESSTHAN        reduce using rule 27 (factor -> constant .)
    GREATERTHAN     reduce using rule 27 (factor -> constant .)
    BETWEEN         reduce using rule 27 (factor -> constant .)
    RBRACKET        reduce using rule 27 (factor -> constant .)
    RPAREN          reduce using rule 27 (factor -> constant .)
    DOT             reduce using rule 27 (factor -> constant .)
    COMMA           reduce using rule 27 (factor -> constant .)
    SEMIC           reduce using rule 27 (factor -> constant .)


state 37

    (5) constant -> id .

    STAR            reduce using rule 5 (constant -> id .)
    SLASH           reduce using rule 5 (constant -> id .)
    PLUS            reduce using rule 5 (constant -> id .)
    MINUS           reduce using rule 5 (constant -> id .)
    RBRACKET        reduce using rule 5 (constant -> id .)
    RPAREN          reduce using rule 5 (constant -> id .)
    DOT             reduce using rule 5 (constant -> id .)
    COMMA           reduce using rule 5 (constant -> id .)
    SEMIC           reduce using rule 5 (constant -> id .)
    LESSTHAN        reduce using rule 5 (constant -> id .)
    GREATERTHAN     reduce using rule 5 (constant -> id .)
    BETWEEN         reduce using rule 5 (constant -> id .)


state 38

    (26) factor -> MINUS . constant
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . id
    (6) constant -> . functioncall
    (73) id -> . ID array
    (74) id -> . ID matrix
    (75) id -> . ID
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    CTEI            shift and go to state 48
    CTEF            shift and go to state 46
    CTESTRING       shift and go to state 49
    CTEBOOL         shift and go to state 45
    ID              shift and go to state 42

    constant                       shift and go to state 73
    functioncall                   shift and go to state 41
    id                             shift and go to state 37

state 39

    (25) factor -> PLUS . constant
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . id
    (6) constant -> . functioncall
    (73) id -> . ID array
    (74) id -> . ID matrix
    (75) id -> . ID
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    CTEI            shift and go to state 48
    CTEF            shift and go to state 46
    CTESTRING       shift and go to state 49
    CTEBOOL         shift and go to state 45
    ID              shift and go to state 42

    constant                       shift and go to state 74
    functioncall                   shift and go to state 41
    id                             shift and go to state 37

state 40

    (29) term -> factor .
    (30) term -> factor . STAR term
    (31) term -> factor . SLASH term

    PLUS            reduce using rule 29 (term -> factor .)
    MINUS           reduce using rule 29 (term -> factor .)
    LESSTHAN        reduce using rule 29 (term -> factor .)
    GREATERTHAN     reduce using rule 29 (term -> factor .)
    BETWEEN         reduce using rule 29 (term -> factor .)
    RBRACKET        reduce using rule 29 (term -> factor .)
    RPAREN          reduce using rule 29 (term -> factor .)
    DOT             reduce using rule 29 (term -> factor .)
    COMMA           reduce using rule 29 (term -> factor .)
    SEMIC           reduce using rule 29 (term -> factor .)
    STAR            shift and go to state 75
    SLASH           shift and go to state 76


state 41

    (6) constant -> functioncall .

    STAR            reduce using rule 6 (constant -> functioncall .)
    SLASH           reduce using rule 6 (constant -> functioncall .)
    PLUS            reduce using rule 6 (constant -> functioncall .)
    MINUS           reduce using rule 6 (constant -> functioncall .)
    RBRACKET        reduce using rule 6 (constant -> functioncall .)
    RPAREN          reduce using rule 6 (constant -> functioncall .)
    DOT             reduce using rule 6 (constant -> functioncall .)
    COMMA           reduce using rule 6 (constant -> functioncall .)
    SEMIC           reduce using rule 6 (constant -> functioncall .)
    LESSTHAN        reduce using rule 6 (constant -> functioncall .)
    GREATERTHAN     reduce using rule 6 (constant -> functioncall .)
    BETWEEN         reduce using rule 6 (constant -> functioncall .)


state 42

    (73) id -> ID . array
    (74) id -> ID . matrix
    (75) id -> ID .
    (7) functioncall -> ID . LPAREN expresion RPAREN
    (8) functioncall -> ID . LPAREN CTEI RPAREN
    (9) functioncall -> ID . LPAREN CTEF RPAREN
    (72) array -> . LBRACKET expresion RBRACKET
    (71) matrix -> . LBRACKET expresion RBRACKET LBRACKET expresion RBRACKET

    STAR            reduce using rule 75 (id -> ID .)
    SLASH           reduce using rule 75 (id -> ID .)
    PLUS            reduce using rule 75 (id -> ID .)
    MINUS           reduce using rule 75 (id -> ID .)
    RBRACKET        reduce using rule 75 (id -> ID .)
    RPAREN          reduce using rule 75 (id -> ID .)
    DOT             reduce using rule 75 (id -> ID .)
    COMMA           reduce using rule 75 (id -> ID .)
    SEMIC           reduce using rule 75 (id -> ID .)
    LESSTHAN        reduce using rule 75 (id -> ID .)
    GREATERTHAN     reduce using rule 75 (id -> ID .)
    BETWEEN         reduce using rule 75 (id -> ID .)
    LPAREN          shift and go to state 78
    LBRACKET        shift and go to state 24

    array                          shift and go to state 79
    matrix                         shift and go to state 77

state 43

    (72) array -> LBRACKET expresion . RBRACKET
    (71) matrix -> LBRACKET expresion . RBRACKET LBRACKET expresion RBRACKET

    RBRACKET        shift and go to state 80


state 44

    (40) exp -> term .
    (41) exp -> term . PLUS exp
    (42) exp -> term . MINUS exp

    LESSTHAN        reduce using rule 40 (exp -> term .)
    GREATERTHAN     reduce using rule 40 (exp -> term .)
    BETWEEN         reduce using rule 40 (exp -> term .)
    DOT             reduce using rule 40 (exp -> term .)
    RPAREN          reduce using rule 40 (exp -> term .)
    RBRACKET        reduce using rule 40 (exp -> term .)
    COMMA           reduce using rule 40 (exp -> term .)
    SEMIC           reduce using rule 40 (exp -> term .)
    PLUS            shift and go to state 81
    MINUS           shift and go to state 82


state 45

    (4) constant -> CTEBOOL .

    STAR            reduce using rule 4 (constant -> CTEBOOL .)
    SLASH           reduce using rule 4 (constant -> CTEBOOL .)
    PLUS            reduce using rule 4 (constant -> CTEBOOL .)
    MINUS           reduce using rule 4 (constant -> CTEBOOL .)
    RBRACKET        reduce using rule 4 (constant -> CTEBOOL .)
    RPAREN          reduce using rule 4 (constant -> CTEBOOL .)
    DOT             reduce using rule 4 (constant -> CTEBOOL .)
    COMMA           reduce using rule 4 (constant -> CTEBOOL .)
    SEMIC           reduce using rule 4 (constant -> CTEBOOL .)
    LESSTHAN        reduce using rule 4 (constant -> CTEBOOL .)
    GREATERTHAN     reduce using rule 4 (constant -> CTEBOOL .)
    BETWEEN         reduce using rule 4 (constant -> CTEBOOL .)


state 46

    (2) constant -> CTEF .

    STAR            reduce using rule 2 (constant -> CTEF .)
    SLASH           reduce using rule 2 (constant -> CTEF .)
    PLUS            reduce using rule 2 (constant -> CTEF .)
    MINUS           reduce using rule 2 (constant -> CTEF .)
    RBRACKET        reduce using rule 2 (constant -> CTEF .)
    RPAREN          reduce using rule 2 (constant -> CTEF .)
    DOT             reduce using rule 2 (constant -> CTEF .)
    COMMA           reduce using rule 2 (constant -> CTEF .)
    SEMIC           reduce using rule 2 (constant -> CTEF .)
    LESSTHAN        reduce using rule 2 (constant -> CTEF .)
    GREATERTHAN     reduce using rule 2 (constant -> CTEF .)
    BETWEEN         reduce using rule 2 (constant -> CTEF .)


state 47

    (36) expresion -> exp .
    (37) expresion -> exp . LESSTHAN exp
    (38) expresion -> exp . GREATERTHAN exp
    (39) expresion -> exp . BETWEEN exp

    RPAREN          reduce using rule 36 (expresion -> exp .)
    COMMA           reduce using rule 36 (expresion -> exp .)
    SEMIC           reduce using rule 36 (expresion -> exp .)
    DOT             reduce using rule 36 (expresion -> exp .)
    RBRACKET        reduce using rule 36 (expresion -> exp .)
    LESSTHAN        shift and go to state 83
    GREATERTHAN     shift and go to state 84
    BETWEEN         shift and go to state 85


state 48

    (1) constant -> CTEI .

    STAR            reduce using rule 1 (constant -> CTEI .)
    SLASH           reduce using rule 1 (constant -> CTEI .)
    PLUS            reduce using rule 1 (constant -> CTEI .)
    MINUS           reduce using rule 1 (constant -> CTEI .)
    RBRACKET        reduce using rule 1 (constant -> CTEI .)
    RPAREN          reduce using rule 1 (constant -> CTEI .)
    DOT             reduce using rule 1 (constant -> CTEI .)
    COMMA           reduce using rule 1 (constant -> CTEI .)
    SEMIC           reduce using rule 1 (constant -> CTEI .)
    LESSTHAN        reduce using rule 1 (constant -> CTEI .)
    GREATERTHAN     reduce using rule 1 (constant -> CTEI .)
    BETWEEN         reduce using rule 1 (constant -> CTEI .)


state 49

    (3) constant -> CTESTRING .

    STAR            reduce using rule 3 (constant -> CTESTRING .)
    SLASH           reduce using rule 3 (constant -> CTESTRING .)
    PLUS            reduce using rule 3 (constant -> CTESTRING .)
    MINUS           reduce using rule 3 (constant -> CTESTRING .)
    RBRACKET        reduce using rule 3 (constant -> CTESTRING .)
    RPAREN          reduce using rule 3 (constant -> CTESTRING .)
    DOT             reduce using rule 3 (constant -> CTESTRING .)
    COMMA           reduce using rule 3 (constant -> CTESTRING .)
    SEMIC           reduce using rule 3 (constant -> CTESTRING .)
    LESSTHAN        reduce using rule 3 (constant -> CTESTRING .)
    GREATERTHAN     reduce using rule 3 (constant -> CTESTRING .)
    BETWEEN         reduce using rule 3 (constant -> CTESTRING .)


state 50

    (85) listofvars -> declaracion POINTS listofids . SEMIC

    SEMIC           shift and go to state 86


state 51

    (81) listofids -> ID . lid
    (79) lid -> . COMMA listofids
    (80) lid -> . empty
    (94) empty -> .

    COMMA           shift and go to state 89
    SEMIC           reduce using rule 94 (empty -> .)

    lid                            shift and go to state 87
    empty                          shift and go to state 88

state 52

    (86) varsdata -> vars data .

    ID              reduce using rule 86 (varsdata -> vars data .)
    IF              reduce using rule 86 (varsdata -> vars data .)
    PRINT           reduce using rule 86 (varsdata -> vars data .)
    MIN             reduce using rule 86 (varsdata -> vars data .)
    MAX             reduce using rule 86 (varsdata -> vars data .)
    FOR             reduce using rule 86 (varsdata -> vars data .)
    RETURN          reduce using rule 86 (varsdata -> vars data .)
    RCURLY          reduce using rule 86 (varsdata -> vars data .)


state 53

    (10) data -> DATA . LCURLY asignmany RCURLY

    LCURLY          shift and go to state 90


state 54

    (56) return -> RETURN . asign
    (48) asign -> . ID EQUALS expresiones SEMIC

    ID              shift and go to state 65

    asign                          shift and go to state 91

state 55

    (93) program -> declarevars declarefunc MODEL LCURLY varsdata block2 . RCURLY

    RCURLY          shift and go to state 92


state 56

    (15) optimize -> MIN . EQUALS statement

    EQUALS          shift and go to state 93


state 57

    (43) write -> PRINT . LPAREN write2 RPAREN SEMIC

    LPAREN          shift and go to state 94


state 58

    (53) statement -> for .

    ID              reduce using rule 53 (statement -> for .)
    IF              reduce using rule 53 (statement -> for .)
    PRINT           reduce using rule 53 (statement -> for .)
    MIN             reduce using rule 53 (statement -> for .)
    MAX             reduce using rule 53 (statement -> for .)
    FOR             reduce using rule 53 (statement -> for .)
    RETURN          reduce using rule 53 (statement -> for .)
    SEMIC           reduce using rule 53 (statement -> for .)
    ELSE            reduce using rule 53 (statement -> for .)
    RCURLY          reduce using rule 53 (statement -> for .)


state 59

    (52) statement -> optimize .

    ID              reduce using rule 52 (statement -> optimize .)
    IF              reduce using rule 52 (statement -> optimize .)
    PRINT           reduce using rule 52 (statement -> optimize .)
    MIN             reduce using rule 52 (statement -> optimize .)
    MAX             reduce using rule 52 (statement -> optimize .)
    FOR             reduce using rule 52 (statement -> optimize .)
    RETURN          reduce using rule 52 (statement -> optimize .)
    SEMIC           reduce using rule 52 (statement -> optimize .)
    ELSE            reduce using rule 52 (statement -> optimize .)
    RCURLY          reduce using rule 52 (statement -> optimize .)


state 60

    (51) statement -> write .

    ID              reduce using rule 51 (statement -> write .)
    IF              reduce using rule 51 (statement -> write .)
    PRINT           reduce using rule 51 (statement -> write .)
    MIN             reduce using rule 51 (statement -> write .)
    MAX             reduce using rule 51 (statement -> write .)
    FOR             reduce using rule 51 (statement -> write .)
    RETURN          reduce using rule 51 (statement -> write .)
    SEMIC           reduce using rule 51 (statement -> write .)
    ELSE            reduce using rule 51 (statement -> write .)
    RCURLY          reduce using rule 51 (statement -> write .)


state 61

    (64) block2 -> statement . block2
    (65) block2 -> statement .
    (64) block2 -> . statement block2
    (65) block2 -> . statement
    (66) block2 -> . empty
    (49) statement -> . asign
    (50) statement -> . condition
    (51) statement -> . write
    (52) statement -> . optimize
    (53) statement -> . for
    (54) statement -> . return
    (94) empty -> .
    (48) asign -> . ID EQUALS expresiones SEMIC
    (32) condition -> . IF LPAREN expresion RPAREN block SEMIC
    (33) condition -> . IF LPAREN expresion RPAREN block ELSE block SEMIC
    (43) write -> . PRINT LPAREN write2 RPAREN SEMIC
    (15) optimize -> . MIN EQUALS statement
    (16) optimize -> . MAX EQUALS statement
    (20) for -> . FOR ID IN DOT ID LCURLY block2 RCURLY
    (56) return -> . RETURN asign

  ! reduce/reduce conflict for RCURLY resolved using rule 65 (block2 -> statement .)
  ! reduce/reduce conflict for SEMIC resolved using rule 65 (block2 -> statement .)
  ! reduce/reduce conflict for ELSE resolved using rule 65 (block2 -> statement .)
    RCURLY          reduce using rule 65 (block2 -> statement .)
    SEMIC           reduce using rule 65 (block2 -> statement .)
    ELSE            reduce using rule 65 (block2 -> statement .)
    ID              shift and go to state 65
    IF              shift and go to state 67
    PRINT           shift and go to state 57
    MIN             shift and go to state 56
    MAX             shift and go to state 68
    FOR             shift and go to state 64
    RETURN          shift and go to state 54

  ! RCURLY          [ reduce using rule 94 (empty -> .) ]
  ! SEMIC           [ reduce using rule 94 (empty -> .) ]
  ! ELSE            [ reduce using rule 94 (empty -> .) ]

    return                         shift and go to state 63
    block2                         shift and go to state 95
    for                            shift and go to state 58
    asign                          shift and go to state 69
    write                          shift and go to state 60
    condition                      shift and go to state 66
    statement                      shift and go to state 61
    optimize                       shift and go to state 59
    empty                          shift and go to state 62

state 62

    (66) block2 -> empty .

    RCURLY          reduce using rule 66 (block2 -> empty .)
    SEMIC           reduce using rule 66 (block2 -> empty .)
    ELSE            reduce using rule 66 (block2 -> empty .)


state 63

    (54) statement -> return .

    ID              reduce using rule 54 (statement -> return .)
    IF              reduce using rule 54 (statement -> return .)
    PRINT           reduce using rule 54 (statement -> return .)
    MIN             reduce using rule 54 (statement -> return .)
    MAX             reduce using rule 54 (statement -> return .)
    FOR             reduce using rule 54 (statement -> return .)
    RETURN          reduce using rule 54 (statement -> return .)
    SEMIC           reduce using rule 54 (statement -> return .)
    ELSE            reduce using rule 54 (statement -> return .)
    RCURLY          reduce using rule 54 (statement -> return .)


state 64

    (20) for -> FOR . ID IN DOT ID LCURLY block2 RCURLY

    ID              shift and go to state 96


state 65

    (48) asign -> ID . EQUALS expresiones SEMIC

    EQUALS          shift and go to state 97


state 66

    (50) statement -> condition .

    ID              reduce using rule 50 (statement -> condition .)
    IF              reduce using rule 50 (statement -> condition .)
    PRINT           reduce using rule 50 (statement -> condition .)
    MIN             reduce using rule 50 (statement -> condition .)
    MAX             reduce using rule 50 (statement -> condition .)
    FOR             reduce using rule 50 (statement -> condition .)
    RETURN          reduce using rule 50 (statement -> condition .)
    SEMIC           reduce using rule 50 (statement -> condition .)
    ELSE            reduce using rule 50 (statement -> condition .)
    RCURLY          reduce using rule 50 (statement -> condition .)


state 67

    (32) condition -> IF . LPAREN expresion RPAREN block SEMIC
    (33) condition -> IF . LPAREN expresion RPAREN block ELSE block SEMIC

    LPAREN          shift and go to state 98


state 68

    (16) optimize -> MAX . EQUALS statement

    EQUALS          shift and go to state 99


state 69

    (49) statement -> asign .

    ID              reduce using rule 49 (statement -> asign .)
    IF              reduce using rule 49 (statement -> asign .)
    PRINT           reduce using rule 49 (statement -> asign .)
    MIN             reduce using rule 49 (statement -> asign .)
    MAX             reduce using rule 49 (statement -> asign .)
    FOR             reduce using rule 49 (statement -> asign .)
    RETURN          reduce using rule 49 (statement -> asign .)
    SEMIC           reduce using rule 49 (statement -> asign .)
    ELSE            reduce using rule 49 (statement -> asign .)
    RCURLY          reduce using rule 49 (statement -> asign .)


state 70

    (59) manyargs -> tipo ID . liargs
    (60) liargs -> . empty
    (61) liargs -> . COMMA manyargs
    (94) empty -> .

    COMMA           shift and go to state 101
    RPAREN          reduce using rule 94 (empty -> .)

    liargs                         shift and go to state 100
    empty                          shift and go to state 102

state 71

    (57) function -> FUNC ID LPAREN manyargs RPAREN . LCURLY varsdata block2 RCURLY

    LCURLY          shift and go to state 103


state 72

    (28) factor -> LPAREN expresion . RPAREN

    RPAREN          shift and go to state 104


state 73

    (26) factor -> MINUS constant .

    STAR            reduce using rule 26 (factor -> MINUS constant .)
    SLASH           reduce using rule 26 (factor -> MINUS constant .)
    PLUS            reduce using rule 26 (factor -> MINUS constant .)
    MINUS           reduce using rule 26 (factor -> MINUS constant .)
    LESSTHAN        reduce using rule 26 (factor -> MINUS constant .)
    GREATERTHAN     reduce using rule 26 (factor -> MINUS constant .)
    BETWEEN         reduce using rule 26 (factor -> MINUS constant .)
    RBRACKET        reduce using rule 26 (factor -> MINUS constant .)
    RPAREN          reduce using rule 26 (factor -> MINUS constant .)
    DOT             reduce using rule 26 (factor -> MINUS constant .)
    COMMA           reduce using rule 26 (factor -> MINUS constant .)
    SEMIC           reduce using rule 26 (factor -> MINUS constant .)


state 74

    (25) factor -> PLUS constant .

    STAR            reduce using rule 25 (factor -> PLUS constant .)
    SLASH           reduce using rule 25 (factor -> PLUS constant .)
    PLUS            reduce using rule 25 (factor -> PLUS constant .)
    MINUS           reduce using rule 25 (factor -> PLUS constant .)
    LESSTHAN        reduce using rule 25 (factor -> PLUS constant .)
    GREATERTHAN     reduce using rule 25 (factor -> PLUS constant .)
    BETWEEN         reduce using rule 25 (factor -> PLUS constant .)
    RBRACKET        reduce using rule 25 (factor -> PLUS constant .)
    RPAREN          reduce using rule 25 (factor -> PLUS constant .)
    DOT             reduce using rule 25 (factor -> PLUS constant .)
    COMMA           reduce using rule 25 (factor -> PLUS constant .)
    SEMIC           reduce using rule 25 (factor -> PLUS constant .)


state 75

    (30) term -> factor STAR . term
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . id
    (6) constant -> . functioncall
    (73) id -> . ID array
    (74) id -> . ID matrix
    (75) id -> . ID
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 39
    MINUS           shift and go to state 38
    LPAREN          shift and go to state 35
    CTEI            shift and go to state 48
    CTEF            shift and go to state 46
    CTESTRING       shift and go to state 49
    CTEBOOL         shift and go to state 45
    ID              shift and go to state 42

    term                           shift and go to state 105
    constant                       shift and go to state 36
    functioncall                   shift and go to state 41
    factor                         shift and go to state 40
    id                             shift and go to state 37

state 76

    (31) term -> factor SLASH . term
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . id
    (6) constant -> . functioncall
    (73) id -> . ID array
    (74) id -> . ID matrix
    (75) id -> . ID
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 39
    MINUS           shift and go to state 38
    LPAREN          shift and go to state 35
    CTEI            shift and go to state 48
    CTEF            shift and go to state 46
    CTESTRING       shift and go to state 49
    CTEBOOL         shift and go to state 45
    ID              shift and go to state 42

    term                           shift and go to state 106
    constant                       shift and go to state 36
    functioncall                   shift and go to state 41
    factor                         shift and go to state 40
    id                             shift and go to state 37

state 77

    (74) id -> ID matrix .

    STAR            reduce using rule 74 (id -> ID matrix .)
    SLASH           reduce using rule 74 (id -> ID matrix .)
    PLUS            reduce using rule 74 (id -> ID matrix .)
    MINUS           reduce using rule 74 (id -> ID matrix .)
    RBRACKET        reduce using rule 74 (id -> ID matrix .)
    RPAREN          reduce using rule 74 (id -> ID matrix .)
    DOT             reduce using rule 74 (id -> ID matrix .)
    COMMA           reduce using rule 74 (id -> ID matrix .)
    SEMIC           reduce using rule 74 (id -> ID matrix .)
    LESSTHAN        reduce using rule 74 (id -> ID matrix .)
    GREATERTHAN     reduce using rule 74 (id -> ID matrix .)
    BETWEEN         reduce using rule 74 (id -> ID matrix .)


state 78

    (7) functioncall -> ID LPAREN . expresion RPAREN
    (8) functioncall -> ID LPAREN . CTEI RPAREN
    (9) functioncall -> ID LPAREN . CTEF RPAREN
    (36) expresion -> . exp
    (37) expresion -> . exp LESSTHAN exp
    (38) expresion -> . exp GREATERTHAN exp
    (39) expresion -> . exp BETWEEN exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . id
    (6) constant -> . functioncall
    (73) id -> . ID array
    (74) id -> . ID matrix
    (75) id -> . ID
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    CTEI            shift and go to state 109
    CTEF            shift and go to state 107
    PLUS            shift and go to state 39
    MINUS           shift and go to state 38
    LPAREN          shift and go to state 35
    CTESTRING       shift and go to state 49
    CTEBOOL         shift and go to state 45
    ID              shift and go to state 42

    expresion                      shift and go to state 108
    term                           shift and go to state 44
    constant                       shift and go to state 36
    functioncall                   shift and go to state 41
    exp                            shift and go to state 47
    factor                         shift and go to state 40
    id                             shift and go to state 37

state 79

    (73) id -> ID array .

    STAR            reduce using rule 73 (id -> ID array .)
    SLASH           reduce using rule 73 (id -> ID array .)
    PLUS            reduce using rule 73 (id -> ID array .)
    MINUS           reduce using rule 73 (id -> ID array .)
    RBRACKET        reduce using rule 73 (id -> ID array .)
    RPAREN          reduce using rule 73 (id -> ID array .)
    DOT             reduce using rule 73 (id -> ID array .)
    COMMA           reduce using rule 73 (id -> ID array .)
    SEMIC           reduce using rule 73 (id -> ID array .)
    LESSTHAN        reduce using rule 73 (id -> ID array .)
    GREATERTHAN     reduce using rule 73 (id -> ID array .)
    BETWEEN         reduce using rule 73 (id -> ID array .)


state 80

    (72) array -> LBRACKET expresion RBRACKET .
    (71) matrix -> LBRACKET expresion RBRACKET . LBRACKET expresion RBRACKET

    POINTS          reduce using rule 72 (array -> LBRACKET expresion RBRACKET .)
    STAR            reduce using rule 72 (array -> LBRACKET expresion RBRACKET .)
    SLASH           reduce using rule 72 (array -> LBRACKET expresion RBRACKET .)
    PLUS            reduce using rule 72 (array -> LBRACKET expresion RBRACKET .)
    MINUS           reduce using rule 72 (array -> LBRACKET expresion RBRACKET .)
    LESSTHAN        reduce using rule 72 (array -> LBRACKET expresion RBRACKET .)
    GREATERTHAN     reduce using rule 72 (array -> LBRACKET expresion RBRACKET .)
    BETWEEN         reduce using rule 72 (array -> LBRACKET expresion RBRACKET .)
    RBRACKET        reduce using rule 72 (array -> LBRACKET expresion RBRACKET .)
    RPAREN          reduce using rule 72 (array -> LBRACKET expresion RBRACKET .)
    DOT             reduce using rule 72 (array -> LBRACKET expresion RBRACKET .)
    COMMA           reduce using rule 72 (array -> LBRACKET expresion RBRACKET .)
    SEMIC           reduce using rule 72 (array -> LBRACKET expresion RBRACKET .)
    LBRACKET        shift and go to state 110


state 81

    (41) exp -> term PLUS . exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . id
    (6) constant -> . functioncall
    (73) id -> . ID array
    (74) id -> . ID matrix
    (75) id -> . ID
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 39
    MINUS           shift and go to state 38
    LPAREN          shift and go to state 35
    CTEI            shift and go to state 48
    CTEF            shift and go to state 46
    CTESTRING       shift and go to state 49
    CTEBOOL         shift and go to state 45
    ID              shift and go to state 42

    term                           shift and go to state 44
    constant                       shift and go to state 36
    functioncall                   shift and go to state 41
    exp                            shift and go to state 111
    factor                         shift and go to state 40
    id                             shift and go to state 37

state 82

    (42) exp -> term MINUS . exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . id
    (6) constant -> . functioncall
    (73) id -> . ID array
    (74) id -> . ID matrix
    (75) id -> . ID
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 39
    MINUS           shift and go to state 38
    LPAREN          shift and go to state 35
    CTEI            shift and go to state 48
    CTEF            shift and go to state 46
    CTESTRING       shift and go to state 49
    CTEBOOL         shift and go to state 45
    ID              shift and go to state 42

    term                           shift and go to state 44
    constant                       shift and go to state 36
    functioncall                   shift and go to state 41
    exp                            shift and go to state 112
    factor                         shift and go to state 40
    id                             shift and go to state 37

state 83

    (37) expresion -> exp LESSTHAN . exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . id
    (6) constant -> . functioncall
    (73) id -> . ID array
    (74) id -> . ID matrix
    (75) id -> . ID
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 39
    MINUS           shift and go to state 38
    LPAREN          shift and go to state 35
    CTEI            shift and go to state 48
    CTEF            shift and go to state 46
    CTESTRING       shift and go to state 49
    CTEBOOL         shift and go to state 45
    ID              shift and go to state 42

    term                           shift and go to state 44
    constant                       shift and go to state 36
    functioncall                   shift and go to state 41
    exp                            shift and go to state 113
    factor                         shift and go to state 40
    id                             shift and go to state 37

state 84

    (38) expresion -> exp GREATERTHAN . exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . id
    (6) constant -> . functioncall
    (73) id -> . ID array
    (74) id -> . ID matrix
    (75) id -> . ID
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 39
    MINUS           shift and go to state 38
    LPAREN          shift and go to state 35
    CTEI            shift and go to state 48
    CTEF            shift and go to state 46
    CTESTRING       shift and go to state 49
    CTEBOOL         shift and go to state 45
    ID              shift and go to state 42

    term                           shift and go to state 44
    constant                       shift and go to state 36
    functioncall                   shift and go to state 41
    exp                            shift and go to state 114
    factor                         shift and go to state 40
    id                             shift and go to state 37

state 85

    (39) expresion -> exp BETWEEN . exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . id
    (6) constant -> . functioncall
    (73) id -> . ID array
    (74) id -> . ID matrix
    (75) id -> . ID
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 39
    MINUS           shift and go to state 38
    LPAREN          shift and go to state 35
    CTEI            shift and go to state 48
    CTEF            shift and go to state 46
    CTESTRING       shift and go to state 49
    CTEBOOL         shift and go to state 45
    ID              shift and go to state 42

    term                           shift and go to state 44
    constant                       shift and go to state 36
    functioncall                   shift and go to state 41
    exp                            shift and go to state 115
    factor                         shift and go to state 40
    id                             shift and go to state 37

state 86

    (85) listofvars -> declaracion POINTS listofids SEMIC .

    TINT            reduce using rule 85 (listofvars -> declaracion POINTS listofids SEMIC .)
    TFLOAT          reduce using rule 85 (listofvars -> declaracion POINTS listofids SEMIC .)
    TBOOL           reduce using rule 85 (listofvars -> declaracion POINTS listofids SEMIC .)
    RCURLY          reduce using rule 85 (listofvars -> declaracion POINTS listofids SEMIC .)


state 87

    (81) listofids -> ID lid .

    SEMIC           reduce using rule 81 (listofids -> ID lid .)


state 88

    (80) lid -> empty .

    SEMIC           reduce using rule 80 (lid -> empty .)


state 89

    (79) lid -> COMMA . listofids
    (81) listofids -> . ID lid

    ID              shift and go to state 51

    listofids                      shift and go to state 116

state 90

    (10) data -> DATA LCURLY . asignmany RCURLY
    (11) asignmany -> . asign SEMIC asignlist
    (12) asignmany -> . asign
    (48) asign -> . ID EQUALS expresiones SEMIC

    ID              shift and go to state 65

    asignmany                      shift and go to state 117
    asign                          shift and go to state 118

state 91

    (56) return -> RETURN asign .

    ID              reduce using rule 56 (return -> RETURN asign .)
    IF              reduce using rule 56 (return -> RETURN asign .)
    PRINT           reduce using rule 56 (return -> RETURN asign .)
    MIN             reduce using rule 56 (return -> RETURN asign .)
    MAX             reduce using rule 56 (return -> RETURN asign .)
    FOR             reduce using rule 56 (return -> RETURN asign .)
    RETURN          reduce using rule 56 (return -> RETURN asign .)
    RCURLY          reduce using rule 56 (return -> RETURN asign .)
    SEMIC           reduce using rule 56 (return -> RETURN asign .)
    ELSE            reduce using rule 56 (return -> RETURN asign .)


state 92

    (93) program -> declarevars declarefunc MODEL LCURLY varsdata block2 RCURLY .

    $end            reduce using rule 93 (program -> declarevars declarefunc MODEL LCURLY varsdata block2 RCURLY .)


state 93

    (15) optimize -> MIN EQUALS . statement
    (49) statement -> . asign
    (50) statement -> . condition
    (51) statement -> . write
    (52) statement -> . optimize
    (53) statement -> . for
    (54) statement -> . return
    (48) asign -> . ID EQUALS expresiones SEMIC
    (32) condition -> . IF LPAREN expresion RPAREN block SEMIC
    (33) condition -> . IF LPAREN expresion RPAREN block ELSE block SEMIC
    (43) write -> . PRINT LPAREN write2 RPAREN SEMIC
    (15) optimize -> . MIN EQUALS statement
    (16) optimize -> . MAX EQUALS statement
    (20) for -> . FOR ID IN DOT ID LCURLY block2 RCURLY
    (56) return -> . RETURN asign

    ID              shift and go to state 65
    IF              shift and go to state 67
    PRINT           shift and go to state 57
    MIN             shift and go to state 56
    MAX             shift and go to state 68
    FOR             shift and go to state 64
    RETURN          shift and go to state 54

    return                         shift and go to state 63
    for                            shift and go to state 58
    asign                          shift and go to state 69
    write                          shift and go to state 60
    statement                      shift and go to state 119
    optimize                       shift and go to state 59
    condition                      shift and go to state 66

state 94

    (43) write -> PRINT LPAREN . write2 RPAREN SEMIC
    (44) write2 -> . expresion
    (45) write2 -> . CTESTRING
    (46) write2 -> . expresion DOT write2
    (47) write2 -> . CTESTRING DOT write2
    (36) expresion -> . exp
    (37) expresion -> . exp LESSTHAN exp
    (38) expresion -> . exp GREATERTHAN exp
    (39) expresion -> . exp BETWEEN exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . id
    (6) constant -> . functioncall
    (73) id -> . ID array
    (74) id -> . ID matrix
    (75) id -> . ID
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    CTESTRING       shift and go to state 120
    PLUS            shift and go to state 39
    MINUS           shift and go to state 38
    LPAREN          shift and go to state 35
    CTEI            shift and go to state 48
    CTEF            shift and go to state 46
    CTEBOOL         shift and go to state 45
    ID              shift and go to state 42

    expresion                      shift and go to state 121
    term                           shift and go to state 44
    constant                       shift and go to state 36
    write2                         shift and go to state 122
    functioncall                   shift and go to state 41
    exp                            shift and go to state 47
    factor                         shift and go to state 40
    id                             shift and go to state 37

state 95

    (64) block2 -> statement block2 .

    RCURLY          reduce using rule 64 (block2 -> statement block2 .)
    SEMIC           reduce using rule 64 (block2 -> statement block2 .)
    ELSE            reduce using rule 64 (block2 -> statement block2 .)


state 96

    (20) for -> FOR ID . IN DOT ID LCURLY block2 RCURLY

    IN              shift and go to state 123


state 97

    (48) asign -> ID EQUALS . expresiones SEMIC
    (34) expresiones -> . expresion COMMA expresiones
    (35) expresiones -> . expresion
    (36) expresion -> . exp
    (37) expresion -> . exp LESSTHAN exp
    (38) expresion -> . exp GREATERTHAN exp
    (39) expresion -> . exp BETWEEN exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . id
    (6) constant -> . functioncall
    (73) id -> . ID array
    (74) id -> . ID matrix
    (75) id -> . ID
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 39
    MINUS           shift and go to state 38
    LPAREN          shift and go to state 35
    CTEI            shift and go to state 48
    CTEF            shift and go to state 46
    CTESTRING       shift and go to state 49
    CTEBOOL         shift and go to state 45
    ID              shift and go to state 42

    expresion                      shift and go to state 125
    expresiones                    shift and go to state 124
    constant                       shift and go to state 36
    term                           shift and go to state 44
    functioncall                   shift and go to state 41
    exp                            shift and go to state 47
    factor                         shift and go to state 40
    id                             shift and go to state 37

state 98

    (32) condition -> IF LPAREN . expresion RPAREN block SEMIC
    (33) condition -> IF LPAREN . expresion RPAREN block ELSE block SEMIC
    (36) expresion -> . exp
    (37) expresion -> . exp LESSTHAN exp
    (38) expresion -> . exp GREATERTHAN exp
    (39) expresion -> . exp BETWEEN exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . id
    (6) constant -> . functioncall
    (73) id -> . ID array
    (74) id -> . ID matrix
    (75) id -> . ID
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 39
    MINUS           shift and go to state 38
    LPAREN          shift and go to state 35
    CTEI            shift and go to state 48
    CTEF            shift and go to state 46
    CTESTRING       shift and go to state 49
    CTEBOOL         shift and go to state 45
    ID              shift and go to state 42

    expresion                      shift and go to state 126
    term                           shift and go to state 44
    constant                       shift and go to state 36
    functioncall                   shift and go to state 41
    exp                            shift and go to state 47
    factor                         shift and go to state 40
    id                             shift and go to state 37

state 99

    (16) optimize -> MAX EQUALS . statement
    (49) statement -> . asign
    (50) statement -> . condition
    (51) statement -> . write
    (52) statement -> . optimize
    (53) statement -> . for
    (54) statement -> . return
    (48) asign -> . ID EQUALS expresiones SEMIC
    (32) condition -> . IF LPAREN expresion RPAREN block SEMIC
    (33) condition -> . IF LPAREN expresion RPAREN block ELSE block SEMIC
    (43) write -> . PRINT LPAREN write2 RPAREN SEMIC
    (15) optimize -> . MIN EQUALS statement
    (16) optimize -> . MAX EQUALS statement
    (20) for -> . FOR ID IN DOT ID LCURLY block2 RCURLY
    (56) return -> . RETURN asign

    ID              shift and go to state 65
    IF              shift and go to state 67
    PRINT           shift and go to state 57
    MIN             shift and go to state 56
    MAX             shift and go to state 68
    FOR             shift and go to state 64
    RETURN          shift and go to state 54

    return                         shift and go to state 63
    for                            shift and go to state 58
    asign                          shift and go to state 69
    write                          shift and go to state 60
    statement                      shift and go to state 127
    optimize                       shift and go to state 59
    condition                      shift and go to state 66

state 100

    (59) manyargs -> tipo ID liargs .

    RPAREN          reduce using rule 59 (manyargs -> tipo ID liargs .)


state 101

    (61) liargs -> COMMA . manyargs
    (58) manyargs -> . empty
    (59) manyargs -> . tipo ID liargs
    (94) empty -> .
    (67) tipo -> . TINT
    (68) tipo -> . TFLOAT
    (69) tipo -> . TBOOL

    RPAREN          reduce using rule 94 (empty -> .)
    TINT            shift and go to state 13
    TFLOAT          shift and go to state 19
    TBOOL           shift and go to state 18

    empty                          shift and go to state 34
    manyargs                       shift and go to state 128
    tipo                           shift and go to state 32

state 102

    (60) liargs -> empty .

    RPAREN          reduce using rule 60 (liargs -> empty .)


state 103

    (57) function -> FUNC ID LPAREN manyargs RPAREN LCURLY . varsdata block2 RCURLY
    (86) varsdata -> . vars data
    (87) varsdata -> . empty
    (88) varsdata -> . vars
    (70) vars -> . VARS LCURLY lvars RCURLY
    (94) empty -> .

    VARS            shift and go to state 4
    ID              reduce using rule 94 (empty -> .)
    IF              reduce using rule 94 (empty -> .)
    PRINT           reduce using rule 94 (empty -> .)
    MIN             reduce using rule 94 (empty -> .)
    MAX             reduce using rule 94 (empty -> .)
    FOR             reduce using rule 94 (empty -> .)
    RETURN          reduce using rule 94 (empty -> .)
    RCURLY          reduce using rule 94 (empty -> .)

    vars                           shift and go to state 29
    varsdata                       shift and go to state 129
    empty                          shift and go to state 31

state 104

    (28) factor -> LPAREN expresion RPAREN .

    STAR            reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    SLASH           reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    PLUS            reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    MINUS           reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    LESSTHAN        reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    GREATERTHAN     reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    BETWEEN         reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    RBRACKET        reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    RPAREN          reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    DOT             reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    COMMA           reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    SEMIC           reduce using rule 28 (factor -> LPAREN expresion RPAREN .)


state 105

    (30) term -> factor STAR term .

    PLUS            reduce using rule 30 (term -> factor STAR term .)
    MINUS           reduce using rule 30 (term -> factor STAR term .)
    LESSTHAN        reduce using rule 30 (term -> factor STAR term .)
    GREATERTHAN     reduce using rule 30 (term -> factor STAR term .)
    BETWEEN         reduce using rule 30 (term -> factor STAR term .)
    RBRACKET        reduce using rule 30 (term -> factor STAR term .)
    RPAREN          reduce using rule 30 (term -> factor STAR term .)
    DOT             reduce using rule 30 (term -> factor STAR term .)
    COMMA           reduce using rule 30 (term -> factor STAR term .)
    SEMIC           reduce using rule 30 (term -> factor STAR term .)


state 106

    (31) term -> factor SLASH term .

    PLUS            reduce using rule 31 (term -> factor SLASH term .)
    MINUS           reduce using rule 31 (term -> factor SLASH term .)
    LESSTHAN        reduce using rule 31 (term -> factor SLASH term .)
    GREATERTHAN     reduce using rule 31 (term -> factor SLASH term .)
    BETWEEN         reduce using rule 31 (term -> factor SLASH term .)
    RBRACKET        reduce using rule 31 (term -> factor SLASH term .)
    RPAREN          reduce using rule 31 (term -> factor SLASH term .)
    DOT             reduce using rule 31 (term -> factor SLASH term .)
    COMMA           reduce using rule 31 (term -> factor SLASH term .)
    SEMIC           reduce using rule 31 (term -> factor SLASH term .)


state 107

    (9) functioncall -> ID LPAREN CTEF . RPAREN
    (2) constant -> CTEF .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 130
    STAR            reduce using rule 2 (constant -> CTEF .)
    SLASH           reduce using rule 2 (constant -> CTEF .)
    PLUS            reduce using rule 2 (constant -> CTEF .)
    MINUS           reduce using rule 2 (constant -> CTEF .)
    LESSTHAN        reduce using rule 2 (constant -> CTEF .)
    GREATERTHAN     reduce using rule 2 (constant -> CTEF .)
    BETWEEN         reduce using rule 2 (constant -> CTEF .)

  ! RPAREN          [ reduce using rule 2 (constant -> CTEF .) ]


state 108

    (7) functioncall -> ID LPAREN expresion . RPAREN

    RPAREN          shift and go to state 131


state 109

    (8) functioncall -> ID LPAREN CTEI . RPAREN
    (1) constant -> CTEI .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 132
    STAR            reduce using rule 1 (constant -> CTEI .)
    SLASH           reduce using rule 1 (constant -> CTEI .)
    PLUS            reduce using rule 1 (constant -> CTEI .)
    MINUS           reduce using rule 1 (constant -> CTEI .)
    LESSTHAN        reduce using rule 1 (constant -> CTEI .)
    GREATERTHAN     reduce using rule 1 (constant -> CTEI .)
    BETWEEN         reduce using rule 1 (constant -> CTEI .)

  ! RPAREN          [ reduce using rule 1 (constant -> CTEI .) ]


state 110

    (71) matrix -> LBRACKET expresion RBRACKET LBRACKET . expresion RBRACKET
    (36) expresion -> . exp
    (37) expresion -> . exp LESSTHAN exp
    (38) expresion -> . exp GREATERTHAN exp
    (39) expresion -> . exp BETWEEN exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . id
    (6) constant -> . functioncall
    (73) id -> . ID array
    (74) id -> . ID matrix
    (75) id -> . ID
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 39
    MINUS           shift and go to state 38
    LPAREN          shift and go to state 35
    CTEI            shift and go to state 48
    CTEF            shift and go to state 46
    CTESTRING       shift and go to state 49
    CTEBOOL         shift and go to state 45
    ID              shift and go to state 42

    expresion                      shift and go to state 133
    term                           shift and go to state 44
    constant                       shift and go to state 36
    functioncall                   shift and go to state 41
    exp                            shift and go to state 47
    factor                         shift and go to state 40
    id                             shift and go to state 37

state 111

    (41) exp -> term PLUS exp .

    LESSTHAN        reduce using rule 41 (exp -> term PLUS exp .)
    GREATERTHAN     reduce using rule 41 (exp -> term PLUS exp .)
    BETWEEN         reduce using rule 41 (exp -> term PLUS exp .)
    DOT             reduce using rule 41 (exp -> term PLUS exp .)
    RPAREN          reduce using rule 41 (exp -> term PLUS exp .)
    RBRACKET        reduce using rule 41 (exp -> term PLUS exp .)
    COMMA           reduce using rule 41 (exp -> term PLUS exp .)
    SEMIC           reduce using rule 41 (exp -> term PLUS exp .)


state 112

    (42) exp -> term MINUS exp .

    LESSTHAN        reduce using rule 42 (exp -> term MINUS exp .)
    GREATERTHAN     reduce using rule 42 (exp -> term MINUS exp .)
    BETWEEN         reduce using rule 42 (exp -> term MINUS exp .)
    DOT             reduce using rule 42 (exp -> term MINUS exp .)
    RPAREN          reduce using rule 42 (exp -> term MINUS exp .)
    RBRACKET        reduce using rule 42 (exp -> term MINUS exp .)
    COMMA           reduce using rule 42 (exp -> term MINUS exp .)
    SEMIC           reduce using rule 42 (exp -> term MINUS exp .)


state 113

    (37) expresion -> exp LESSTHAN exp .

    RPAREN          reduce using rule 37 (expresion -> exp LESSTHAN exp .)
    COMMA           reduce using rule 37 (expresion -> exp LESSTHAN exp .)
    SEMIC           reduce using rule 37 (expresion -> exp LESSTHAN exp .)
    DOT             reduce using rule 37 (expresion -> exp LESSTHAN exp .)
    RBRACKET        reduce using rule 37 (expresion -> exp LESSTHAN exp .)


state 114

    (38) expresion -> exp GREATERTHAN exp .

    RPAREN          reduce using rule 38 (expresion -> exp GREATERTHAN exp .)
    COMMA           reduce using rule 38 (expresion -> exp GREATERTHAN exp .)
    SEMIC           reduce using rule 38 (expresion -> exp GREATERTHAN exp .)
    DOT             reduce using rule 38 (expresion -> exp GREATERTHAN exp .)
    RBRACKET        reduce using rule 38 (expresion -> exp GREATERTHAN exp .)


state 115

    (39) expresion -> exp BETWEEN exp .

    RPAREN          reduce using rule 39 (expresion -> exp BETWEEN exp .)
    COMMA           reduce using rule 39 (expresion -> exp BETWEEN exp .)
    SEMIC           reduce using rule 39 (expresion -> exp BETWEEN exp .)
    DOT             reduce using rule 39 (expresion -> exp BETWEEN exp .)
    RBRACKET        reduce using rule 39 (expresion -> exp BETWEEN exp .)


state 116

    (79) lid -> COMMA listofids .

    SEMIC           reduce using rule 79 (lid -> COMMA listofids .)


state 117

    (10) data -> DATA LCURLY asignmany . RCURLY

    RCURLY          shift and go to state 134


state 118

    (11) asignmany -> asign . SEMIC asignlist
    (12) asignmany -> asign .

    SEMIC           shift and go to state 135
    RCURLY          reduce using rule 12 (asignmany -> asign .)


state 119

    (15) optimize -> MIN EQUALS statement .

    ID              reduce using rule 15 (optimize -> MIN EQUALS statement .)
    IF              reduce using rule 15 (optimize -> MIN EQUALS statement .)
    PRINT           reduce using rule 15 (optimize -> MIN EQUALS statement .)
    MIN             reduce using rule 15 (optimize -> MIN EQUALS statement .)
    MAX             reduce using rule 15 (optimize -> MIN EQUALS statement .)
    FOR             reduce using rule 15 (optimize -> MIN EQUALS statement .)
    RETURN          reduce using rule 15 (optimize -> MIN EQUALS statement .)
    SEMIC           reduce using rule 15 (optimize -> MIN EQUALS statement .)
    ELSE            reduce using rule 15 (optimize -> MIN EQUALS statement .)
    RCURLY          reduce using rule 15 (optimize -> MIN EQUALS statement .)


state 120

    (45) write2 -> CTESTRING .
    (47) write2 -> CTESTRING . DOT write2
    (3) constant -> CTESTRING .

  ! shift/reduce conflict for DOT resolved as shift
  ! reduce/reduce conflict for RPAREN resolved using rule 3 (constant -> CTESTRING .)
    DOT             shift and go to state 136
    STAR            reduce using rule 3 (constant -> CTESTRING .)
    SLASH           reduce using rule 3 (constant -> CTESTRING .)
    PLUS            reduce using rule 3 (constant -> CTESTRING .)
    MINUS           reduce using rule 3 (constant -> CTESTRING .)
    LESSTHAN        reduce using rule 3 (constant -> CTESTRING .)
    GREATERTHAN     reduce using rule 3 (constant -> CTESTRING .)
    BETWEEN         reduce using rule 3 (constant -> CTESTRING .)
    RPAREN          reduce using rule 3 (constant -> CTESTRING .)

  ! RPAREN          [ reduce using rule 45 (write2 -> CTESTRING .) ]
  ! DOT             [ reduce using rule 3 (constant -> CTESTRING .) ]


state 121

    (44) write2 -> expresion .
    (46) write2 -> expresion . DOT write2

    RPAREN          reduce using rule 44 (write2 -> expresion .)
    DOT             shift and go to state 137


state 122

    (43) write -> PRINT LPAREN write2 . RPAREN SEMIC

    RPAREN          shift and go to state 138


state 123

    (20) for -> FOR ID IN . DOT ID LCURLY block2 RCURLY

    DOT             shift and go to state 139


state 124

    (48) asign -> ID EQUALS expresiones . SEMIC

    SEMIC           shift and go to state 140


state 125

    (34) expresiones -> expresion . COMMA expresiones
    (35) expresiones -> expresion .

    COMMA           shift and go to state 141
    SEMIC           reduce using rule 35 (expresiones -> expresion .)


state 126

    (32) condition -> IF LPAREN expresion . RPAREN block SEMIC
    (33) condition -> IF LPAREN expresion . RPAREN block ELSE block SEMIC

    RPAREN          shift and go to state 142


state 127

    (16) optimize -> MAX EQUALS statement .

    ID              reduce using rule 16 (optimize -> MAX EQUALS statement .)
    IF              reduce using rule 16 (optimize -> MAX EQUALS statement .)
    PRINT           reduce using rule 16 (optimize -> MAX EQUALS statement .)
    MIN             reduce using rule 16 (optimize -> MAX EQUALS statement .)
    MAX             reduce using rule 16 (optimize -> MAX EQUALS statement .)
    FOR             reduce using rule 16 (optimize -> MAX EQUALS statement .)
    RETURN          reduce using rule 16 (optimize -> MAX EQUALS statement .)
    SEMIC           reduce using rule 16 (optimize -> MAX EQUALS statement .)
    ELSE            reduce using rule 16 (optimize -> MAX EQUALS statement .)
    RCURLY          reduce using rule 16 (optimize -> MAX EQUALS statement .)


state 128

    (61) liargs -> COMMA manyargs .

    RPAREN          reduce using rule 61 (liargs -> COMMA manyargs .)


state 129

    (57) function -> FUNC ID LPAREN manyargs RPAREN LCURLY varsdata . block2 RCURLY
    (64) block2 -> . statement block2
    (65) block2 -> . statement
    (66) block2 -> . empty
    (49) statement -> . asign
    (50) statement -> . condition
    (51) statement -> . write
    (52) statement -> . optimize
    (53) statement -> . for
    (54) statement -> . return
    (94) empty -> .
    (48) asign -> . ID EQUALS expresiones SEMIC
    (32) condition -> . IF LPAREN expresion RPAREN block SEMIC
    (33) condition -> . IF LPAREN expresion RPAREN block ELSE block SEMIC
    (43) write -> . PRINT LPAREN write2 RPAREN SEMIC
    (15) optimize -> . MIN EQUALS statement
    (16) optimize -> . MAX EQUALS statement
    (20) for -> . FOR ID IN DOT ID LCURLY block2 RCURLY
    (56) return -> . RETURN asign

    RCURLY          reduce using rule 94 (empty -> .)
    ID              shift and go to state 65
    IF              shift and go to state 67
    PRINT           shift and go to state 57
    MIN             shift and go to state 56
    MAX             shift and go to state 68
    FOR             shift and go to state 64
    RETURN          shift and go to state 54

    return                         shift and go to state 63
    block2                         shift and go to state 143
    for                            shift and go to state 58
    asign                          shift and go to state 69
    write                          shift and go to state 60
    condition                      shift and go to state 66
    statement                      shift and go to state 61
    optimize                       shift and go to state 59
    empty                          shift and go to state 62

state 130

    (9) functioncall -> ID LPAREN CTEF RPAREN .

    STAR            reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    SLASH           reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    PLUS            reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    MINUS           reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    LESSTHAN        reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    GREATERTHAN     reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    BETWEEN         reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    DOT             reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    RPAREN          reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    RBRACKET        reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    COMMA           reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    SEMIC           reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)


state 131

    (7) functioncall -> ID LPAREN expresion RPAREN .

    STAR            reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    SLASH           reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    PLUS            reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    MINUS           reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    LESSTHAN        reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    GREATERTHAN     reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    BETWEEN         reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    DOT             reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    RPAREN          reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    RBRACKET        reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    COMMA           reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    SEMIC           reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)


state 132

    (8) functioncall -> ID LPAREN CTEI RPAREN .

    STAR            reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    SLASH           reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    PLUS            reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    MINUS           reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    LESSTHAN        reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    GREATERTHAN     reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    BETWEEN         reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    DOT             reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    RPAREN          reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    RBRACKET        reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    COMMA           reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    SEMIC           reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)


state 133

    (71) matrix -> LBRACKET expresion RBRACKET LBRACKET expresion . RBRACKET

    RBRACKET        shift and go to state 144


state 134

    (10) data -> DATA LCURLY asignmany RCURLY .

    ID              reduce using rule 10 (data -> DATA LCURLY asignmany RCURLY .)
    IF              reduce using rule 10 (data -> DATA LCURLY asignmany RCURLY .)
    PRINT           reduce using rule 10 (data -> DATA LCURLY asignmany RCURLY .)
    MIN             reduce using rule 10 (data -> DATA LCURLY asignmany RCURLY .)
    MAX             reduce using rule 10 (data -> DATA LCURLY asignmany RCURLY .)
    FOR             reduce using rule 10 (data -> DATA LCURLY asignmany RCURLY .)
    RETURN          reduce using rule 10 (data -> DATA LCURLY asignmany RCURLY .)
    RCURLY          reduce using rule 10 (data -> DATA LCURLY asignmany RCURLY .)


state 135

    (11) asignmany -> asign SEMIC . asignlist
    (13) asignlist -> . empty
    (14) asignlist -> . asignmany
    (94) empty -> .
    (11) asignmany -> . asign SEMIC asignlist
    (12) asignmany -> . asign
    (48) asign -> . ID EQUALS expresiones SEMIC

    RCURLY          reduce using rule 94 (empty -> .)
    ID              shift and go to state 65

    asignmany                      shift and go to state 145
    asignlist                      shift and go to state 146
    empty                          shift and go to state 147
    asign                          shift and go to state 118

state 136

    (47) write2 -> CTESTRING DOT . write2
    (44) write2 -> . expresion
    (45) write2 -> . CTESTRING
    (46) write2 -> . expresion DOT write2
    (47) write2 -> . CTESTRING DOT write2
    (36) expresion -> . exp
    (37) expresion -> . exp LESSTHAN exp
    (38) expresion -> . exp GREATERTHAN exp
    (39) expresion -> . exp BETWEEN exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . id
    (6) constant -> . functioncall
    (73) id -> . ID array
    (74) id -> . ID matrix
    (75) id -> . ID
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    CTESTRING       shift and go to state 120
    PLUS            shift and go to state 39
    MINUS           shift and go to state 38
    LPAREN          shift and go to state 35
    CTEI            shift and go to state 48
    CTEF            shift and go to state 46
    CTEBOOL         shift and go to state 45
    ID              shift and go to state 42

    expresion                      shift and go to state 121
    term                           shift and go to state 44
    constant                       shift and go to state 36
    write2                         shift and go to state 148
    functioncall                   shift and go to state 41
    exp                            shift and go to state 47
    factor                         shift and go to state 40
    id                             shift and go to state 37

state 137

    (46) write2 -> expresion DOT . write2
    (44) write2 -> . expresion
    (45) write2 -> . CTESTRING
    (46) write2 -> . expresion DOT write2
    (47) write2 -> . CTESTRING DOT write2
    (36) expresion -> . exp
    (37) expresion -> . exp LESSTHAN exp
    (38) expresion -> . exp GREATERTHAN exp
    (39) expresion -> . exp BETWEEN exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . id
    (6) constant -> . functioncall
    (73) id -> . ID array
    (74) id -> . ID matrix
    (75) id -> . ID
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    CTESTRING       shift and go to state 120
    PLUS            shift and go to state 39
    MINUS           shift and go to state 38
    LPAREN          shift and go to state 35
    CTEI            shift and go to state 48
    CTEF            shift and go to state 46
    CTEBOOL         shift and go to state 45
    ID              shift and go to state 42

    expresion                      shift and go to state 121
    term                           shift and go to state 44
    constant                       shift and go to state 36
    write2                         shift and go to state 149
    functioncall                   shift and go to state 41
    exp                            shift and go to state 47
    factor                         shift and go to state 40
    id                             shift and go to state 37

state 138

    (43) write -> PRINT LPAREN write2 RPAREN . SEMIC

    SEMIC           shift and go to state 150


state 139

    (20) for -> FOR ID IN DOT . ID LCURLY block2 RCURLY

    ID              shift and go to state 151


state 140

    (48) asign -> ID EQUALS expresiones SEMIC .

    SEMIC           reduce using rule 48 (asign -> ID EQUALS expresiones SEMIC .)
    RCURLY          reduce using rule 48 (asign -> ID EQUALS expresiones SEMIC .)
    ID              reduce using rule 48 (asign -> ID EQUALS expresiones SEMIC .)
    IF              reduce using rule 48 (asign -> ID EQUALS expresiones SEMIC .)
    PRINT           reduce using rule 48 (asign -> ID EQUALS expresiones SEMIC .)
    MIN             reduce using rule 48 (asign -> ID EQUALS expresiones SEMIC .)
    MAX             reduce using rule 48 (asign -> ID EQUALS expresiones SEMIC .)
    FOR             reduce using rule 48 (asign -> ID EQUALS expresiones SEMIC .)
    RETURN          reduce using rule 48 (asign -> ID EQUALS expresiones SEMIC .)
    ELSE            reduce using rule 48 (asign -> ID EQUALS expresiones SEMIC .)


state 141

    (34) expresiones -> expresion COMMA . expresiones
    (34) expresiones -> . expresion COMMA expresiones
    (35) expresiones -> . expresion
    (36) expresion -> . exp
    (37) expresion -> . exp LESSTHAN exp
    (38) expresion -> . exp GREATERTHAN exp
    (39) expresion -> . exp BETWEEN exp
    (40) exp -> . term
    (41) exp -> . term PLUS exp
    (42) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . id
    (6) constant -> . functioncall
    (73) id -> . ID array
    (74) id -> . ID matrix
    (75) id -> . ID
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 39
    MINUS           shift and go to state 38
    LPAREN          shift and go to state 35
    CTEI            shift and go to state 48
    CTEF            shift and go to state 46
    CTESTRING       shift and go to state 49
    CTEBOOL         shift and go to state 45
    ID              shift and go to state 42

    expresion                      shift and go to state 125
    expresiones                    shift and go to state 152
    constant                       shift and go to state 36
    term                           shift and go to state 44
    functioncall                   shift and go to state 41
    exp                            shift and go to state 47
    factor                         shift and go to state 40
    id                             shift and go to state 37

state 142

    (32) condition -> IF LPAREN expresion RPAREN . block SEMIC
    (33) condition -> IF LPAREN expresion RPAREN . block ELSE block SEMIC
    (62) block -> . block2
    (63) block -> . LCURLY RCURLY
    (64) block2 -> . statement block2
    (65) block2 -> . statement
    (66) block2 -> . empty
    (49) statement -> . asign
    (50) statement -> . condition
    (51) statement -> . write
    (52) statement -> . optimize
    (53) statement -> . for
    (54) statement -> . return
    (94) empty -> .
    (48) asign -> . ID EQUALS expresiones SEMIC
    (32) condition -> . IF LPAREN expresion RPAREN block SEMIC
    (33) condition -> . IF LPAREN expresion RPAREN block ELSE block SEMIC
    (43) write -> . PRINT LPAREN write2 RPAREN SEMIC
    (15) optimize -> . MIN EQUALS statement
    (16) optimize -> . MAX EQUALS statement
    (20) for -> . FOR ID IN DOT ID LCURLY block2 RCURLY
    (56) return -> . RETURN asign

    LCURLY          shift and go to state 154
    SEMIC           reduce using rule 94 (empty -> .)
    ELSE            reduce using rule 94 (empty -> .)
    ID              shift and go to state 65
    IF              shift and go to state 67
    PRINT           shift and go to state 57
    MIN             shift and go to state 56
    MAX             shift and go to state 68
    FOR             shift and go to state 64
    RETURN          shift and go to state 54

    return                         shift and go to state 63
    block2                         shift and go to state 153
    for                            shift and go to state 58
    condition                      shift and go to state 66
    asign                          shift and go to state 69
    write                          shift and go to state 60
    block                          shift and go to state 155
    statement                      shift and go to state 61
    optimize                       shift and go to state 59
    empty                          shift and go to state 62

state 143

    (57) function -> FUNC ID LPAREN manyargs RPAREN LCURLY varsdata block2 . RCURLY

    RCURLY          shift and go to state 156


state 144

    (71) matrix -> LBRACKET expresion RBRACKET LBRACKET expresion RBRACKET .

    POINTS          reduce using rule 71 (matrix -> LBRACKET expresion RBRACKET LBRACKET expresion RBRACKET .)
    STAR            reduce using rule 71 (matrix -> LBRACKET expresion RBRACKET LBRACKET expresion RBRACKET .)
    SLASH           reduce using rule 71 (matrix -> LBRACKET expresion RBRACKET LBRACKET expresion RBRACKET .)
    PLUS            reduce using rule 71 (matrix -> LBRACKET expresion RBRACKET LBRACKET expresion RBRACKET .)
    MINUS           reduce using rule 71 (matrix -> LBRACKET expresion RBRACKET LBRACKET expresion RBRACKET .)
    LESSTHAN        reduce using rule 71 (matrix -> LBRACKET expresion RBRACKET LBRACKET expresion RBRACKET .)
    GREATERTHAN     reduce using rule 71 (matrix -> LBRACKET expresion RBRACKET LBRACKET expresion RBRACKET .)
    BETWEEN         reduce using rule 71 (matrix -> LBRACKET expresion RBRACKET LBRACKET expresion RBRACKET .)
    RBRACKET        reduce using rule 71 (matrix -> LBRACKET expresion RBRACKET LBRACKET expresion RBRACKET .)
    RPAREN          reduce using rule 71 (matrix -> LBRACKET expresion RBRACKET LBRACKET expresion RBRACKET .)
    DOT             reduce using rule 71 (matrix -> LBRACKET expresion RBRACKET LBRACKET expresion RBRACKET .)
    COMMA           reduce using rule 71 (matrix -> LBRACKET expresion RBRACKET LBRACKET expresion RBRACKET .)
    SEMIC           reduce using rule 71 (matrix -> LBRACKET expresion RBRACKET LBRACKET expresion RBRACKET .)


state 145

    (14) asignlist -> asignmany .

    RCURLY          reduce using rule 14 (asignlist -> asignmany .)


state 146

    (11) asignmany -> asign SEMIC asignlist .

    RCURLY          reduce using rule 11 (asignmany -> asign SEMIC asignlist .)


state 147

    (13) asignlist -> empty .

    RCURLY          reduce using rule 13 (asignlist -> empty .)


state 148

    (47) write2 -> CTESTRING DOT write2 .

    RPAREN          reduce using rule 47 (write2 -> CTESTRING DOT write2 .)


state 149

    (46) write2 -> expresion DOT write2 .

    RPAREN          reduce using rule 46 (write2 -> expresion DOT write2 .)


state 150

    (43) write -> PRINT LPAREN write2 RPAREN SEMIC .

    ID              reduce using rule 43 (write -> PRINT LPAREN write2 RPAREN SEMIC .)
    IF              reduce using rule 43 (write -> PRINT LPAREN write2 RPAREN SEMIC .)
    PRINT           reduce using rule 43 (write -> PRINT LPAREN write2 RPAREN SEMIC .)
    MIN             reduce using rule 43 (write -> PRINT LPAREN write2 RPAREN SEMIC .)
    MAX             reduce using rule 43 (write -> PRINT LPAREN write2 RPAREN SEMIC .)
    FOR             reduce using rule 43 (write -> PRINT LPAREN write2 RPAREN SEMIC .)
    RETURN          reduce using rule 43 (write -> PRINT LPAREN write2 RPAREN SEMIC .)
    RCURLY          reduce using rule 43 (write -> PRINT LPAREN write2 RPAREN SEMIC .)
    SEMIC           reduce using rule 43 (write -> PRINT LPAREN write2 RPAREN SEMIC .)
    ELSE            reduce using rule 43 (write -> PRINT LPAREN write2 RPAREN SEMIC .)


state 151

    (20) for -> FOR ID IN DOT ID . LCURLY block2 RCURLY

    LCURLY          shift and go to state 157


state 152

    (34) expresiones -> expresion COMMA expresiones .

    SEMIC           reduce using rule 34 (expresiones -> expresion COMMA expresiones .)


state 153

    (62) block -> block2 .

    SEMIC           reduce using rule 62 (block -> block2 .)
    ELSE            reduce using rule 62 (block -> block2 .)


state 154

    (63) block -> LCURLY . RCURLY

    RCURLY          shift and go to state 158


state 155

    (32) condition -> IF LPAREN expresion RPAREN block . SEMIC
    (33) condition -> IF LPAREN expresion RPAREN block . ELSE block SEMIC

    SEMIC           shift and go to state 159
    ELSE            shift and go to state 160


state 156

    (57) function -> FUNC ID LPAREN manyargs RPAREN LCURLY varsdata block2 RCURLY .

    MODEL           reduce using rule 57 (function -> FUNC ID LPAREN manyargs RPAREN LCURLY varsdata block2 RCURLY .)


state 157

    (20) for -> FOR ID IN DOT ID LCURLY . block2 RCURLY
    (64) block2 -> . statement block2
    (65) block2 -> . statement
    (66) block2 -> . empty
    (49) statement -> . asign
    (50) statement -> . condition
    (51) statement -> . write
    (52) statement -> . optimize
    (53) statement -> . for
    (54) statement -> . return
    (94) empty -> .
    (48) asign -> . ID EQUALS expresiones SEMIC
    (32) condition -> . IF LPAREN expresion RPAREN block SEMIC
    (33) condition -> . IF LPAREN expresion RPAREN block ELSE block SEMIC
    (43) write -> . PRINT LPAREN write2 RPAREN SEMIC
    (15) optimize -> . MIN EQUALS statement
    (16) optimize -> . MAX EQUALS statement
    (20) for -> . FOR ID IN DOT ID LCURLY block2 RCURLY
    (56) return -> . RETURN asign

    RCURLY          reduce using rule 94 (empty -> .)
    ID              shift and go to state 65
    IF              shift and go to state 67
    PRINT           shift and go to state 57
    MIN             shift and go to state 56
    MAX             shift and go to state 68
    FOR             shift and go to state 64
    RETURN          shift and go to state 54

    return                         shift and go to state 63
    block2                         shift and go to state 161
    for                            shift and go to state 58
    asign                          shift and go to state 69
    write                          shift and go to state 60
    condition                      shift and go to state 66
    statement                      shift and go to state 61
    optimize                       shift and go to state 59
    empty                          shift and go to state 62

state 158

    (63) block -> LCURLY RCURLY .

    SEMIC           reduce using rule 63 (block -> LCURLY RCURLY .)
    ELSE            reduce using rule 63 (block -> LCURLY RCURLY .)


state 159

    (32) condition -> IF LPAREN expresion RPAREN block SEMIC .

    ID              reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)
    IF              reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)
    PRINT           reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)
    MIN             reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)
    MAX             reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)
    FOR             reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)
    RETURN          reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)
    RCURLY          reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)
    SEMIC           reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)
    ELSE            reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)


state 160

    (33) condition -> IF LPAREN expresion RPAREN block ELSE . block SEMIC
    (62) block -> . block2
    (63) block -> . LCURLY RCURLY
    (64) block2 -> . statement block2
    (65) block2 -> . statement
    (66) block2 -> . empty
    (49) statement -> . asign
    (50) statement -> . condition
    (51) statement -> . write
    (52) statement -> . optimize
    (53) statement -> . for
    (54) statement -> . return
    (94) empty -> .
    (48) asign -> . ID EQUALS expresiones SEMIC
    (32) condition -> . IF LPAREN expresion RPAREN block SEMIC
    (33) condition -> . IF LPAREN expresion RPAREN block ELSE block SEMIC
    (43) write -> . PRINT LPAREN write2 RPAREN SEMIC
    (15) optimize -> . MIN EQUALS statement
    (16) optimize -> . MAX EQUALS statement
    (20) for -> . FOR ID IN DOT ID LCURLY block2 RCURLY
    (56) return -> . RETURN asign

    LCURLY          shift and go to state 154
    SEMIC           reduce using rule 94 (empty -> .)
    ID              shift and go to state 65
    IF              shift and go to state 67
    PRINT           shift and go to state 57
    MIN             shift and go to state 56
    MAX             shift and go to state 68
    FOR             shift and go to state 64
    RETURN          shift and go to state 54

    return                         shift and go to state 63
    block2                         shift and go to state 153
    for                            shift and go to state 58
    condition                      shift and go to state 66
    asign                          shift and go to state 69
    write                          shift and go to state 60
    block                          shift and go to state 162
    statement                      shift and go to state 61
    optimize                       shift and go to state 59
    empty                          shift and go to state 62

state 161

    (20) for -> FOR ID IN DOT ID LCURLY block2 . RCURLY

    RCURLY          shift and go to state 163


state 162

    (33) condition -> IF LPAREN expresion RPAREN block ELSE block . SEMIC

    SEMIC           shift and go to state 164


state 163

    (20) for -> FOR ID IN DOT ID LCURLY block2 RCURLY .

    ID              reduce using rule 20 (for -> FOR ID IN DOT ID LCURLY block2 RCURLY .)
    IF              reduce using rule 20 (for -> FOR ID IN DOT ID LCURLY block2 RCURLY .)
    PRINT           reduce using rule 20 (for -> FOR ID IN DOT ID LCURLY block2 RCURLY .)
    MIN             reduce using rule 20 (for -> FOR ID IN DOT ID LCURLY block2 RCURLY .)
    MAX             reduce using rule 20 (for -> FOR ID IN DOT ID LCURLY block2 RCURLY .)
    FOR             reduce using rule 20 (for -> FOR ID IN DOT ID LCURLY block2 RCURLY .)
    RETURN          reduce using rule 20 (for -> FOR ID IN DOT ID LCURLY block2 RCURLY .)
    RCURLY          reduce using rule 20 (for -> FOR ID IN DOT ID LCURLY block2 RCURLY .)
    SEMIC           reduce using rule 20 (for -> FOR ID IN DOT ID LCURLY block2 RCURLY .)
    ELSE            reduce using rule 20 (for -> FOR ID IN DOT ID LCURLY block2 RCURLY .)


state 164

    (33) condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .

    ID              reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)
    IF              reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)
    PRINT           reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)
    MIN             reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)
    MAX             reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)
    FOR             reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)
    RETURN          reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)
    RCURLY          reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)
    SEMIC           reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)
    ELSE            reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for RPAREN in state 107 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 109 resolved as shift
WARNING: shift/reduce conflict for DOT in state 120 resolved as shift
WARNING: reduce/reduce conflict in state 15 resolved using rule (lvars -> listofvars)
WARNING: rejected rule (empty -> <empty>) in state 15
WARNING: reduce/reduce conflict in state 61 resolved using rule (block2 -> statement)
WARNING: rejected rule (empty -> <empty>) in state 61
WARNING: reduce/reduce conflict in state 120 resolved using rule (constant -> CTESTRING)
WARNING: rejected rule (write2 -> CTESTRING) in state 120
WARNING: Rule (write2 -> CTESTRING) is never reduced
