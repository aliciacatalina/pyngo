Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     constant -> CTEI
Rule 2     constant -> CTEF
Rule 3     constant -> CTESTRING
Rule 4     constant -> CTEBOOL
Rule 5     constant -> ID
Rule 6     constant -> functioncall
Rule 7     functioncall -> ID LPAREN expresion RPAREN
Rule 8     functioncall -> ID LPAREN CTEI RPAREN
Rule 9     functioncall -> ID LPAREN CTEF RPAREN
Rule 10    data -> DATA LCURLY asignmany RCURLY
Rule 11    asignmany -> asign SEMIC asignlist
Rule 12    asignmany -> asign
Rule 13    asignlist -> empty
Rule 14    asignlist -> asignmany
Rule 15    optimize -> MIN EQUALS restrictions
Rule 16    optimize -> MAX EQUALS restrictions
Rule 17    restrictions -> WHERE restrictions2
Rule 18    restrictions2 -> expresion
Rule 19    restrictions2 -> sum SEMIC forlist
Rule 20    for -> FOR ID IN DOT ID LBRACKET statement RBRACKET
Rule 21    forlist -> for SEMIC lfor
Rule 22    lfor -> empty
Rule 23    lfor -> forlist
Rule 24    sum -> SUM LPAREN ID POINTS expresion RPAREN
Rule 25    factor -> PLUS constant
Rule 26    factor -> MINUS constant
Rule 27    factor -> constant
Rule 28    factor -> LPAREN expresion RPAREN
Rule 29    term -> factor
Rule 30    term -> factor STAR term
Rule 31    term -> factor SLASH term
Rule 32    condition -> IF LPAREN expresion RPAREN block SEMIC
Rule 33    condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC
Rule 34    expresion -> exp
Rule 35    expresion -> exp LESSTHAN exp
Rule 36    expresion -> exp GREATERTHAN exp
Rule 37    expresion -> exp BETWEEN exp
Rule 38    exp -> term
Rule 39    exp -> term PLUS exp
Rule 40    exp -> term MINUS exp
Rule 41    write -> PRINT LPAREN write2 RPAREN SEMIC
Rule 42    write2 -> expresion
Rule 43    write2 -> CTESTRING
Rule 44    write2 -> expresion DOT write2
Rule 45    write2 -> CTESTRING DOT write2
Rule 46    asign -> ID EQUALS expresion SEMIC
Rule 47    statement -> asign
Rule 48    statement -> condition
Rule 49    statement -> write
Rule 50    statement -> optimize
Rule 51    statement -> loop
Rule 52    statement -> return
Rule 53    loop -> for
Rule 54    return -> RETURN asign
Rule 55    function -> FUNC ID LPAREN manyargs RPAREN LCURLY varsdata block2 RCURLY
Rule 56    manyargs -> empty
Rule 57    manyargs -> tipo ID liargs
Rule 58    liargs -> empty
Rule 59    liargs -> COMMA manyargs
Rule 60    block -> block2
Rule 61    block -> LCURLY RCURLY
Rule 62    block2 -> statement block2
Rule 63    block2 -> statement
Rule 64    block2 -> empty
Rule 65    tipo -> TINT
Rule 66    tipo -> TFLOAT
Rule 67    tipo -> TBOOL
Rule 68    vars -> VARS LCURLY listofvars RCURLY
Rule 69    matrix -> LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET
Rule 70    array -> LBRACKET CTEI RBRACKET
Rule 71    declaracion -> array
Rule 72    declaracion -> matrix
Rule 73    declaracion -> tipo
Rule 74    lid -> COMMA listofids
Rule 75    lid -> empty
Rule 76    listofids -> ID lid
Rule 77    lvars -> listofvars
Rule 78    lvars -> empty
Rule 79    listofvars -> declaracion POINTS listofids SEMIC
Rule 80    varsdata -> vars data
Rule 81    varsdata -> empty
Rule 82    varsdata -> vars
Rule 83    declarefunc -> function
Rule 84    declarefunc -> empty
Rule 85    declarevars -> vars
Rule 86    declarevars -> empty
Rule 87    program -> declarevars declarefunc MODEL LCURLY varsdata block2 RCURLY
Rule 88    empty -> <empty>

Terminals, with rules where they appear

BETWEEN              : 37
COMMA                : 59 74
CTEBOOL              : 4
CTEF                 : 2 9
CTEI                 : 1 8 69 69 70
CTESTRING            : 3 43 45
DATA                 : 10
DOT                  : 20 44 45
ELSE                 : 33
EQUALS               : 15 16 46
FOR                  : 20
FUNC                 : 55
GREATERTHAN          : 36
ID                   : 5 7 8 9 20 20 24 46 55 57 76
IF                   : 32 33
IN                   : 20
LBRACKET             : 20 69 69 70
LCURLY               : 10 55 61 68 87
LESSTHAN             : 35
LPAREN               : 7 8 9 24 28 32 33 41 55
MAX                  : 16
MIN                  : 15
MINUS                : 26 40
MODEL                : 87
PLUS                 : 25 39
POINTS               : 24 79
PRINT                : 41
RBRACKET             : 20 69 69 70
RCURLY               : 10 55 61 68 87
RETURN               : 54
RPAREN               : 7 8 9 24 28 32 33 41 55
SEMIC                : 11 19 21 32 33 41 46 79
SLASH                : 31
STAR                 : 30
SUM                  : 24
TBOOL                : 67
TFLOAT               : 66
TINT                 : 65
VARS                 : 68
WHERE                : 17
error                : 

Nonterminals, with rules where they appear

array                : 71
asign                : 11 12 47 54
asignlist            : 11
asignmany            : 10 14
block                : 32 33 33
block2               : 55 60 62 87
condition            : 48
constant             : 25 26 27
data                 : 80
declaracion          : 79
declarefunc          : 87
declarevars          : 87
empty                : 13 22 56 58 64 75 78 81 84 86
exp                  : 34 35 35 36 36 37 37 39 40
expresion            : 7 18 24 28 32 33 42 44 46
factor               : 29 30 31
for                  : 21 53
forlist              : 19 23
function             : 83
functioncall         : 6
lfor                 : 21
liargs               : 57
lid                  : 76
listofids            : 74 79
listofvars           : 68 77
loop                 : 51
lvars                : 
manyargs             : 55 59
matrix               : 72
optimize             : 50
program              : 0
restrictions         : 15 16
restrictions2        : 17
return               : 52
statement            : 20 62 63
sum                  : 19
term                 : 30 31 38 39 40
tipo                 : 57 73
vars                 : 80 82 85
varsdata             : 55 87
write                : 49
write2               : 41 44 45

Parsing method: LALR

state 0

    (0) S' -> . program
    (87) program -> . declarevars declarefunc MODEL LCURLY varsdata block2 RCURLY
    (85) declarevars -> . vars
    (86) declarevars -> . empty
    (68) vars -> . VARS LCURLY listofvars RCURLY
    (88) empty -> .

    VARS            shift and go to state 4
    FUNC            reduce using rule 88 (empty -> .)
    MODEL           reduce using rule 88 (empty -> .)

    program                        shift and go to state 1
    declarevars                    shift and go to state 2
    vars                           shift and go to state 3
    empty                          shift and go to state 5

state 1

    (0) S' -> program .



state 2

    (87) program -> declarevars . declarefunc MODEL LCURLY varsdata block2 RCURLY
    (83) declarefunc -> . function
    (84) declarefunc -> . empty
    (55) function -> . FUNC ID LPAREN manyargs RPAREN LCURLY varsdata block2 RCURLY
    (88) empty -> .

    FUNC            shift and go to state 8
    MODEL           reduce using rule 88 (empty -> .)

    function                       shift and go to state 6
    declarefunc                    shift and go to state 7
    empty                          shift and go to state 9

state 3

    (85) declarevars -> vars .

    FUNC            reduce using rule 85 (declarevars -> vars .)
    MODEL           reduce using rule 85 (declarevars -> vars .)


state 4

    (68) vars -> VARS . LCURLY listofvars RCURLY

    LCURLY          shift and go to state 10


state 5

    (86) declarevars -> empty .

    FUNC            reduce using rule 86 (declarevars -> empty .)
    MODEL           reduce using rule 86 (declarevars -> empty .)


state 6

    (83) declarefunc -> function .

    MODEL           reduce using rule 83 (declarefunc -> function .)


state 7

    (87) program -> declarevars declarefunc . MODEL LCURLY varsdata block2 RCURLY

    MODEL           shift and go to state 11


state 8

    (55) function -> FUNC . ID LPAREN manyargs RPAREN LCURLY varsdata block2 RCURLY

    ID              shift and go to state 12


state 9

    (84) declarefunc -> empty .

    MODEL           reduce using rule 84 (declarefunc -> empty .)


state 10

    (68) vars -> VARS LCURLY . listofvars RCURLY
    (79) listofvars -> . declaracion POINTS listofids SEMIC
    (71) declaracion -> . array
    (72) declaracion -> . matrix
    (73) declaracion -> . tipo
    (70) array -> . LBRACKET CTEI RBRACKET
    (69) matrix -> . LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET
    (65) tipo -> . TINT
    (66) tipo -> . TFLOAT
    (67) tipo -> . TBOOL

    LBRACKET        shift and go to state 16
    TINT            shift and go to state 13
    TFLOAT          shift and go to state 19
    TBOOL           shift and go to state 17

    matrix                         shift and go to state 14
    tipo                           shift and go to state 21
    listofvars                     shift and go to state 15
    array                          shift and go to state 18
    declaracion                    shift and go to state 20

state 11

    (87) program -> declarevars declarefunc MODEL . LCURLY varsdata block2 RCURLY

    LCURLY          shift and go to state 22


state 12

    (55) function -> FUNC ID . LPAREN manyargs RPAREN LCURLY varsdata block2 RCURLY

    LPAREN          shift and go to state 23


state 13

    (65) tipo -> TINT .

    POINTS          reduce using rule 65 (tipo -> TINT .)
    ID              reduce using rule 65 (tipo -> TINT .)


state 14

    (72) declaracion -> matrix .

    POINTS          reduce using rule 72 (declaracion -> matrix .)


state 15

    (68) vars -> VARS LCURLY listofvars . RCURLY

    RCURLY          shift and go to state 24


state 16

    (70) array -> LBRACKET . CTEI RBRACKET
    (69) matrix -> LBRACKET . CTEI RBRACKET LBRACKET CTEI RBRACKET

    CTEI            shift and go to state 25


state 17

    (67) tipo -> TBOOL .

    POINTS          reduce using rule 67 (tipo -> TBOOL .)
    ID              reduce using rule 67 (tipo -> TBOOL .)


state 18

    (71) declaracion -> array .

    POINTS          reduce using rule 71 (declaracion -> array .)


state 19

    (66) tipo -> TFLOAT .

    POINTS          reduce using rule 66 (tipo -> TFLOAT .)
    ID              reduce using rule 66 (tipo -> TFLOAT .)


state 20

    (79) listofvars -> declaracion . POINTS listofids SEMIC

    POINTS          shift and go to state 26


state 21

    (73) declaracion -> tipo .

    POINTS          reduce using rule 73 (declaracion -> tipo .)


state 22

    (87) program -> declarevars declarefunc MODEL LCURLY . varsdata block2 RCURLY
    (80) varsdata -> . vars data
    (81) varsdata -> . empty
    (82) varsdata -> . vars
    (68) vars -> . VARS LCURLY listofvars RCURLY
    (88) empty -> .

    VARS            shift and go to state 4
    ID              reduce using rule 88 (empty -> .)
    IF              reduce using rule 88 (empty -> .)
    PRINT           reduce using rule 88 (empty -> .)
    MIN             reduce using rule 88 (empty -> .)
    MAX             reduce using rule 88 (empty -> .)
    RETURN          reduce using rule 88 (empty -> .)
    FOR             reduce using rule 88 (empty -> .)
    RCURLY          reduce using rule 88 (empty -> .)

    vars                           shift and go to state 27
    varsdata                       shift and go to state 28
    empty                          shift and go to state 29

state 23

    (55) function -> FUNC ID LPAREN . manyargs RPAREN LCURLY varsdata block2 RCURLY
    (56) manyargs -> . empty
    (57) manyargs -> . tipo ID liargs
    (88) empty -> .
    (65) tipo -> . TINT
    (66) tipo -> . TFLOAT
    (67) tipo -> . TBOOL

    RPAREN          reduce using rule 88 (empty -> .)
    TINT            shift and go to state 13
    TFLOAT          shift and go to state 19
    TBOOL           shift and go to state 17

    tipo                           shift and go to state 30
    manyargs                       shift and go to state 31
    empty                          shift and go to state 32

state 24

    (68) vars -> VARS LCURLY listofvars RCURLY .

    DATA            reduce using rule 68 (vars -> VARS LCURLY listofvars RCURLY .)
    ID              reduce using rule 68 (vars -> VARS LCURLY listofvars RCURLY .)
    IF              reduce using rule 68 (vars -> VARS LCURLY listofvars RCURLY .)
    PRINT           reduce using rule 68 (vars -> VARS LCURLY listofvars RCURLY .)
    MIN             reduce using rule 68 (vars -> VARS LCURLY listofvars RCURLY .)
    MAX             reduce using rule 68 (vars -> VARS LCURLY listofvars RCURLY .)
    RETURN          reduce using rule 68 (vars -> VARS LCURLY listofvars RCURLY .)
    FOR             reduce using rule 68 (vars -> VARS LCURLY listofvars RCURLY .)
    RCURLY          reduce using rule 68 (vars -> VARS LCURLY listofvars RCURLY .)
    FUNC            reduce using rule 68 (vars -> VARS LCURLY listofvars RCURLY .)
    MODEL           reduce using rule 68 (vars -> VARS LCURLY listofvars RCURLY .)


state 25

    (70) array -> LBRACKET CTEI . RBRACKET
    (69) matrix -> LBRACKET CTEI . RBRACKET LBRACKET CTEI RBRACKET

    RBRACKET        shift and go to state 33


state 26

    (79) listofvars -> declaracion POINTS . listofids SEMIC
    (76) listofids -> . ID lid

    ID              shift and go to state 35

    listofids                      shift and go to state 34

state 27

    (80) varsdata -> vars . data
    (82) varsdata -> vars .
    (10) data -> . DATA LCURLY asignmany RCURLY

    ID              reduce using rule 82 (varsdata -> vars .)
    IF              reduce using rule 82 (varsdata -> vars .)
    PRINT           reduce using rule 82 (varsdata -> vars .)
    MIN             reduce using rule 82 (varsdata -> vars .)
    MAX             reduce using rule 82 (varsdata -> vars .)
    RETURN          reduce using rule 82 (varsdata -> vars .)
    FOR             reduce using rule 82 (varsdata -> vars .)
    RCURLY          reduce using rule 82 (varsdata -> vars .)
    DATA            shift and go to state 37

    data                           shift and go to state 36

state 28

    (87) program -> declarevars declarefunc MODEL LCURLY varsdata . block2 RCURLY
    (62) block2 -> . statement block2
    (63) block2 -> . statement
    (64) block2 -> . empty
    (47) statement -> . asign
    (48) statement -> . condition
    (49) statement -> . write
    (50) statement -> . optimize
    (51) statement -> . loop
    (52) statement -> . return
    (88) empty -> .
    (46) asign -> . ID EQUALS expresion SEMIC
    (32) condition -> . IF LPAREN expresion RPAREN block SEMIC
    (33) condition -> . IF LPAREN expresion RPAREN block ELSE block SEMIC
    (41) write -> . PRINT LPAREN write2 RPAREN SEMIC
    (15) optimize -> . MIN EQUALS restrictions
    (16) optimize -> . MAX EQUALS restrictions
    (53) loop -> . for
    (54) return -> . RETURN asign
    (20) for -> . FOR ID IN DOT ID LBRACKET statement RBRACKET

    RCURLY          reduce using rule 88 (empty -> .)
    ID              shift and go to state 49
    IF              shift and go to state 51
    PRINT           shift and go to state 41
    MIN             shift and go to state 40
    MAX             shift and go to state 52
    RETURN          shift and go to state 38
    FOR             shift and go to state 48

    return                         shift and go to state 47
    block2                         shift and go to state 39
    for                            shift and go to state 42
    asign                          shift and go to state 53
    write                          shift and go to state 44
    condition                      shift and go to state 50
    statement                      shift and go to state 45
    loop                           shift and go to state 54
    optimize                       shift and go to state 43
    empty                          shift and go to state 46

state 29

    (81) varsdata -> empty .

    ID              reduce using rule 81 (varsdata -> empty .)
    IF              reduce using rule 81 (varsdata -> empty .)
    PRINT           reduce using rule 81 (varsdata -> empty .)
    MIN             reduce using rule 81 (varsdata -> empty .)
    MAX             reduce using rule 81 (varsdata -> empty .)
    RETURN          reduce using rule 81 (varsdata -> empty .)
    FOR             reduce using rule 81 (varsdata -> empty .)
    RCURLY          reduce using rule 81 (varsdata -> empty .)


state 30

    (57) manyargs -> tipo . ID liargs

    ID              shift and go to state 55


state 31

    (55) function -> FUNC ID LPAREN manyargs . RPAREN LCURLY varsdata block2 RCURLY

    RPAREN          shift and go to state 56


state 32

    (56) manyargs -> empty .

    RPAREN          reduce using rule 56 (manyargs -> empty .)


state 33

    (70) array -> LBRACKET CTEI RBRACKET .
    (69) matrix -> LBRACKET CTEI RBRACKET . LBRACKET CTEI RBRACKET

    POINTS          reduce using rule 70 (array -> LBRACKET CTEI RBRACKET .)
    LBRACKET        shift and go to state 57


state 34

    (79) listofvars -> declaracion POINTS listofids . SEMIC

    SEMIC           shift and go to state 58


state 35

    (76) listofids -> ID . lid
    (74) lid -> . COMMA listofids
    (75) lid -> . empty
    (88) empty -> .

    COMMA           shift and go to state 61
    SEMIC           reduce using rule 88 (empty -> .)

    lid                            shift and go to state 59
    empty                          shift and go to state 60

state 36

    (80) varsdata -> vars data .

    ID              reduce using rule 80 (varsdata -> vars data .)
    IF              reduce using rule 80 (varsdata -> vars data .)
    PRINT           reduce using rule 80 (varsdata -> vars data .)
    MIN             reduce using rule 80 (varsdata -> vars data .)
    MAX             reduce using rule 80 (varsdata -> vars data .)
    RETURN          reduce using rule 80 (varsdata -> vars data .)
    FOR             reduce using rule 80 (varsdata -> vars data .)
    RCURLY          reduce using rule 80 (varsdata -> vars data .)


state 37

    (10) data -> DATA . LCURLY asignmany RCURLY

    LCURLY          shift and go to state 62


state 38

    (54) return -> RETURN . asign
    (46) asign -> . ID EQUALS expresion SEMIC

    ID              shift and go to state 49

    asign                          shift and go to state 63

state 39

    (87) program -> declarevars declarefunc MODEL LCURLY varsdata block2 . RCURLY

    RCURLY          shift and go to state 64


state 40

    (15) optimize -> MIN . EQUALS restrictions

    EQUALS          shift and go to state 65


state 41

    (41) write -> PRINT . LPAREN write2 RPAREN SEMIC

    LPAREN          shift and go to state 66


state 42

    (53) loop -> for .

    ID              reduce using rule 53 (loop -> for .)
    IF              reduce using rule 53 (loop -> for .)
    PRINT           reduce using rule 53 (loop -> for .)
    MIN             reduce using rule 53 (loop -> for .)
    MAX             reduce using rule 53 (loop -> for .)
    RETURN          reduce using rule 53 (loop -> for .)
    FOR             reduce using rule 53 (loop -> for .)
    RCURLY          reduce using rule 53 (loop -> for .)
    RBRACKET        reduce using rule 53 (loop -> for .)
    SEMIC           reduce using rule 53 (loop -> for .)
    ELSE            reduce using rule 53 (loop -> for .)


state 43

    (50) statement -> optimize .

    ID              reduce using rule 50 (statement -> optimize .)
    IF              reduce using rule 50 (statement -> optimize .)
    PRINT           reduce using rule 50 (statement -> optimize .)
    MIN             reduce using rule 50 (statement -> optimize .)
    MAX             reduce using rule 50 (statement -> optimize .)
    RETURN          reduce using rule 50 (statement -> optimize .)
    FOR             reduce using rule 50 (statement -> optimize .)
    RCURLY          reduce using rule 50 (statement -> optimize .)
    RBRACKET        reduce using rule 50 (statement -> optimize .)
    SEMIC           reduce using rule 50 (statement -> optimize .)
    ELSE            reduce using rule 50 (statement -> optimize .)


state 44

    (49) statement -> write .

    ID              reduce using rule 49 (statement -> write .)
    IF              reduce using rule 49 (statement -> write .)
    PRINT           reduce using rule 49 (statement -> write .)
    MIN             reduce using rule 49 (statement -> write .)
    MAX             reduce using rule 49 (statement -> write .)
    RETURN          reduce using rule 49 (statement -> write .)
    FOR             reduce using rule 49 (statement -> write .)
    RCURLY          reduce using rule 49 (statement -> write .)
    RBRACKET        reduce using rule 49 (statement -> write .)
    SEMIC           reduce using rule 49 (statement -> write .)
    ELSE            reduce using rule 49 (statement -> write .)


state 45

    (62) block2 -> statement . block2
    (63) block2 -> statement .
    (62) block2 -> . statement block2
    (63) block2 -> . statement
    (64) block2 -> . empty
    (47) statement -> . asign
    (48) statement -> . condition
    (49) statement -> . write
    (50) statement -> . optimize
    (51) statement -> . loop
    (52) statement -> . return
    (88) empty -> .
    (46) asign -> . ID EQUALS expresion SEMIC
    (32) condition -> . IF LPAREN expresion RPAREN block SEMIC
    (33) condition -> . IF LPAREN expresion RPAREN block ELSE block SEMIC
    (41) write -> . PRINT LPAREN write2 RPAREN SEMIC
    (15) optimize -> . MIN EQUALS restrictions
    (16) optimize -> . MAX EQUALS restrictions
    (53) loop -> . for
    (54) return -> . RETURN asign
    (20) for -> . FOR ID IN DOT ID LBRACKET statement RBRACKET

  ! reduce/reduce conflict for RCURLY resolved using rule 63 (block2 -> statement .)
  ! reduce/reduce conflict for SEMIC resolved using rule 63 (block2 -> statement .)
  ! reduce/reduce conflict for ELSE resolved using rule 63 (block2 -> statement .)
    SEMIC           reduce using rule 63 (block2 -> statement .)
    ELSE            reduce using rule 63 (block2 -> statement .)
    RCURLY          reduce using rule 63 (block2 -> statement .)
    ID              shift and go to state 49
    IF              shift and go to state 51
    PRINT           shift and go to state 41
    MIN             shift and go to state 40
    MAX             shift and go to state 52
    RETURN          shift and go to state 38
    FOR             shift and go to state 48

  ! RCURLY          [ reduce using rule 88 (empty -> .) ]
  ! SEMIC           [ reduce using rule 88 (empty -> .) ]
  ! ELSE            [ reduce using rule 88 (empty -> .) ]

    return                         shift and go to state 47
    block2                         shift and go to state 67
    for                            shift and go to state 42
    asign                          shift and go to state 53
    write                          shift and go to state 44
    condition                      shift and go to state 50
    statement                      shift and go to state 45
    loop                           shift and go to state 54
    optimize                       shift and go to state 43
    empty                          shift and go to state 46

state 46

    (64) block2 -> empty .

    SEMIC           reduce using rule 64 (block2 -> empty .)
    ELSE            reduce using rule 64 (block2 -> empty .)
    RCURLY          reduce using rule 64 (block2 -> empty .)


state 47

    (52) statement -> return .

    ID              reduce using rule 52 (statement -> return .)
    IF              reduce using rule 52 (statement -> return .)
    PRINT           reduce using rule 52 (statement -> return .)
    MIN             reduce using rule 52 (statement -> return .)
    MAX             reduce using rule 52 (statement -> return .)
    RETURN          reduce using rule 52 (statement -> return .)
    FOR             reduce using rule 52 (statement -> return .)
    RCURLY          reduce using rule 52 (statement -> return .)
    RBRACKET        reduce using rule 52 (statement -> return .)
    SEMIC           reduce using rule 52 (statement -> return .)
    ELSE            reduce using rule 52 (statement -> return .)


state 48

    (20) for -> FOR . ID IN DOT ID LBRACKET statement RBRACKET

    ID              shift and go to state 68


state 49

    (46) asign -> ID . EQUALS expresion SEMIC

    EQUALS          shift and go to state 69


state 50

    (48) statement -> condition .

    ID              reduce using rule 48 (statement -> condition .)
    IF              reduce using rule 48 (statement -> condition .)
    PRINT           reduce using rule 48 (statement -> condition .)
    MIN             reduce using rule 48 (statement -> condition .)
    MAX             reduce using rule 48 (statement -> condition .)
    RETURN          reduce using rule 48 (statement -> condition .)
    FOR             reduce using rule 48 (statement -> condition .)
    RCURLY          reduce using rule 48 (statement -> condition .)
    RBRACKET        reduce using rule 48 (statement -> condition .)
    SEMIC           reduce using rule 48 (statement -> condition .)
    ELSE            reduce using rule 48 (statement -> condition .)


state 51

    (32) condition -> IF . LPAREN expresion RPAREN block SEMIC
    (33) condition -> IF . LPAREN expresion RPAREN block ELSE block SEMIC

    LPAREN          shift and go to state 70


state 52

    (16) optimize -> MAX . EQUALS restrictions

    EQUALS          shift and go to state 71


state 53

    (47) statement -> asign .

    ID              reduce using rule 47 (statement -> asign .)
    IF              reduce using rule 47 (statement -> asign .)
    PRINT           reduce using rule 47 (statement -> asign .)
    MIN             reduce using rule 47 (statement -> asign .)
    MAX             reduce using rule 47 (statement -> asign .)
    RETURN          reduce using rule 47 (statement -> asign .)
    FOR             reduce using rule 47 (statement -> asign .)
    RCURLY          reduce using rule 47 (statement -> asign .)
    RBRACKET        reduce using rule 47 (statement -> asign .)
    SEMIC           reduce using rule 47 (statement -> asign .)
    ELSE            reduce using rule 47 (statement -> asign .)


state 54

    (51) statement -> loop .

    ID              reduce using rule 51 (statement -> loop .)
    IF              reduce using rule 51 (statement -> loop .)
    PRINT           reduce using rule 51 (statement -> loop .)
    MIN             reduce using rule 51 (statement -> loop .)
    MAX             reduce using rule 51 (statement -> loop .)
    RETURN          reduce using rule 51 (statement -> loop .)
    FOR             reduce using rule 51 (statement -> loop .)
    RCURLY          reduce using rule 51 (statement -> loop .)
    RBRACKET        reduce using rule 51 (statement -> loop .)
    SEMIC           reduce using rule 51 (statement -> loop .)
    ELSE            reduce using rule 51 (statement -> loop .)


state 55

    (57) manyargs -> tipo ID . liargs
    (58) liargs -> . empty
    (59) liargs -> . COMMA manyargs
    (88) empty -> .

    COMMA           shift and go to state 73
    RPAREN          reduce using rule 88 (empty -> .)

    liargs                         shift and go to state 72
    empty                          shift and go to state 74

state 56

    (55) function -> FUNC ID LPAREN manyargs RPAREN . LCURLY varsdata block2 RCURLY

    LCURLY          shift and go to state 75


state 57

    (69) matrix -> LBRACKET CTEI RBRACKET LBRACKET . CTEI RBRACKET

    CTEI            shift and go to state 76


state 58

    (79) listofvars -> declaracion POINTS listofids SEMIC .

    RCURLY          reduce using rule 79 (listofvars -> declaracion POINTS listofids SEMIC .)


state 59

    (76) listofids -> ID lid .

    SEMIC           reduce using rule 76 (listofids -> ID lid .)


state 60

    (75) lid -> empty .

    SEMIC           reduce using rule 75 (lid -> empty .)


state 61

    (74) lid -> COMMA . listofids
    (76) listofids -> . ID lid

    ID              shift and go to state 35

    listofids                      shift and go to state 77

state 62

    (10) data -> DATA LCURLY . asignmany RCURLY
    (11) asignmany -> . asign SEMIC asignlist
    (12) asignmany -> . asign
    (46) asign -> . ID EQUALS expresion SEMIC

    ID              shift and go to state 49

    asignmany                      shift and go to state 78
    asign                          shift and go to state 79

state 63

    (54) return -> RETURN asign .

    ID              reduce using rule 54 (return -> RETURN asign .)
    IF              reduce using rule 54 (return -> RETURN asign .)
    PRINT           reduce using rule 54 (return -> RETURN asign .)
    MIN             reduce using rule 54 (return -> RETURN asign .)
    MAX             reduce using rule 54 (return -> RETURN asign .)
    RETURN          reduce using rule 54 (return -> RETURN asign .)
    FOR             reduce using rule 54 (return -> RETURN asign .)
    SEMIC           reduce using rule 54 (return -> RETURN asign .)
    RCURLY          reduce using rule 54 (return -> RETURN asign .)
    ELSE            reduce using rule 54 (return -> RETURN asign .)
    RBRACKET        reduce using rule 54 (return -> RETURN asign .)


state 64

    (87) program -> declarevars declarefunc MODEL LCURLY varsdata block2 RCURLY .

    $end            reduce using rule 87 (program -> declarevars declarefunc MODEL LCURLY varsdata block2 RCURLY .)


state 65

    (15) optimize -> MIN EQUALS . restrictions
    (17) restrictions -> . WHERE restrictions2

    WHERE           shift and go to state 81

    restrictions                   shift and go to state 80

state 66

    (41) write -> PRINT LPAREN . write2 RPAREN SEMIC
    (42) write2 -> . expresion
    (43) write2 -> . CTESTRING
    (44) write2 -> . expresion DOT write2
    (45) write2 -> . CTESTRING DOT write2
    (34) expresion -> . exp
    (35) expresion -> . exp LESSTHAN exp
    (36) expresion -> . exp GREATERTHAN exp
    (37) expresion -> . exp BETWEEN exp
    (38) exp -> . term
    (39) exp -> . term PLUS exp
    (40) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . ID
    (6) constant -> . functioncall
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    CTESTRING       shift and go to state 83
    PLUS            shift and go to state 85
    MINUS           shift and go to state 84
    LPAREN          shift and go to state 82
    CTEI            shift and go to state 96
    CTEF            shift and go to state 94
    CTEBOOL         shift and go to state 92
    ID              shift and go to state 89

    expresion                      shift and go to state 90
    term                           shift and go to state 91
    constant                       shift and go to state 88
    write2                         shift and go to state 93
    functioncall                   shift and go to state 87
    exp                            shift and go to state 95
    factor                         shift and go to state 86

state 67

    (62) block2 -> statement block2 .

    SEMIC           reduce using rule 62 (block2 -> statement block2 .)
    ELSE            reduce using rule 62 (block2 -> statement block2 .)
    RCURLY          reduce using rule 62 (block2 -> statement block2 .)


state 68

    (20) for -> FOR ID . IN DOT ID LBRACKET statement RBRACKET

    IN              shift and go to state 97


state 69

    (46) asign -> ID EQUALS . expresion SEMIC
    (34) expresion -> . exp
    (35) expresion -> . exp LESSTHAN exp
    (36) expresion -> . exp GREATERTHAN exp
    (37) expresion -> . exp BETWEEN exp
    (38) exp -> . term
    (39) exp -> . term PLUS exp
    (40) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . ID
    (6) constant -> . functioncall
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 85
    MINUS           shift and go to state 84
    LPAREN          shift and go to state 82
    CTEI            shift and go to state 96
    CTEF            shift and go to state 94
    CTESTRING       shift and go to state 99
    CTEBOOL         shift and go to state 92
    ID              shift and go to state 89

    expresion                      shift and go to state 98
    term                           shift and go to state 91
    constant                       shift and go to state 88
    functioncall                   shift and go to state 87
    exp                            shift and go to state 95
    factor                         shift and go to state 86

state 70

    (32) condition -> IF LPAREN . expresion RPAREN block SEMIC
    (33) condition -> IF LPAREN . expresion RPAREN block ELSE block SEMIC
    (34) expresion -> . exp
    (35) expresion -> . exp LESSTHAN exp
    (36) expresion -> . exp GREATERTHAN exp
    (37) expresion -> . exp BETWEEN exp
    (38) exp -> . term
    (39) exp -> . term PLUS exp
    (40) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . ID
    (6) constant -> . functioncall
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 85
    MINUS           shift and go to state 84
    LPAREN          shift and go to state 82
    CTEI            shift and go to state 96
    CTEF            shift and go to state 94
    CTESTRING       shift and go to state 99
    CTEBOOL         shift and go to state 92
    ID              shift and go to state 89

    expresion                      shift and go to state 100
    term                           shift and go to state 91
    constant                       shift and go to state 88
    functioncall                   shift and go to state 87
    exp                            shift and go to state 95
    factor                         shift and go to state 86

state 71

    (16) optimize -> MAX EQUALS . restrictions
    (17) restrictions -> . WHERE restrictions2

    WHERE           shift and go to state 81

    restrictions                   shift and go to state 101

state 72

    (57) manyargs -> tipo ID liargs .

    RPAREN          reduce using rule 57 (manyargs -> tipo ID liargs .)


state 73

    (59) liargs -> COMMA . manyargs
    (56) manyargs -> . empty
    (57) manyargs -> . tipo ID liargs
    (88) empty -> .
    (65) tipo -> . TINT
    (66) tipo -> . TFLOAT
    (67) tipo -> . TBOOL

    RPAREN          reduce using rule 88 (empty -> .)
    TINT            shift and go to state 13
    TFLOAT          shift and go to state 19
    TBOOL           shift and go to state 17

    empty                          shift and go to state 32
    manyargs                       shift and go to state 102
    tipo                           shift and go to state 30

state 74

    (58) liargs -> empty .

    RPAREN          reduce using rule 58 (liargs -> empty .)


state 75

    (55) function -> FUNC ID LPAREN manyargs RPAREN LCURLY . varsdata block2 RCURLY
    (80) varsdata -> . vars data
    (81) varsdata -> . empty
    (82) varsdata -> . vars
    (68) vars -> . VARS LCURLY listofvars RCURLY
    (88) empty -> .

    VARS            shift and go to state 4
    ID              reduce using rule 88 (empty -> .)
    IF              reduce using rule 88 (empty -> .)
    PRINT           reduce using rule 88 (empty -> .)
    MIN             reduce using rule 88 (empty -> .)
    MAX             reduce using rule 88 (empty -> .)
    RETURN          reduce using rule 88 (empty -> .)
    FOR             reduce using rule 88 (empty -> .)
    RCURLY          reduce using rule 88 (empty -> .)

    vars                           shift and go to state 27
    varsdata                       shift and go to state 103
    empty                          shift and go to state 29

state 76

    (69) matrix -> LBRACKET CTEI RBRACKET LBRACKET CTEI . RBRACKET

    RBRACKET        shift and go to state 104


state 77

    (74) lid -> COMMA listofids .

    SEMIC           reduce using rule 74 (lid -> COMMA listofids .)


state 78

    (10) data -> DATA LCURLY asignmany . RCURLY

    RCURLY          shift and go to state 105


state 79

    (11) asignmany -> asign . SEMIC asignlist
    (12) asignmany -> asign .

    SEMIC           shift and go to state 106
    RCURLY          reduce using rule 12 (asignmany -> asign .)


state 80

    (15) optimize -> MIN EQUALS restrictions .

    RBRACKET        reduce using rule 15 (optimize -> MIN EQUALS restrictions .)
    ID              reduce using rule 15 (optimize -> MIN EQUALS restrictions .)
    IF              reduce using rule 15 (optimize -> MIN EQUALS restrictions .)
    PRINT           reduce using rule 15 (optimize -> MIN EQUALS restrictions .)
    MIN             reduce using rule 15 (optimize -> MIN EQUALS restrictions .)
    MAX             reduce using rule 15 (optimize -> MIN EQUALS restrictions .)
    RETURN          reduce using rule 15 (optimize -> MIN EQUALS restrictions .)
    FOR             reduce using rule 15 (optimize -> MIN EQUALS restrictions .)
    RCURLY          reduce using rule 15 (optimize -> MIN EQUALS restrictions .)
    SEMIC           reduce using rule 15 (optimize -> MIN EQUALS restrictions .)
    ELSE            reduce using rule 15 (optimize -> MIN EQUALS restrictions .)


state 81

    (17) restrictions -> WHERE . restrictions2
    (18) restrictions2 -> . expresion
    (19) restrictions2 -> . sum SEMIC forlist
    (34) expresion -> . exp
    (35) expresion -> . exp LESSTHAN exp
    (36) expresion -> . exp GREATERTHAN exp
    (37) expresion -> . exp BETWEEN exp
    (24) sum -> . SUM LPAREN ID POINTS expresion RPAREN
    (38) exp -> . term
    (39) exp -> . term PLUS exp
    (40) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . ID
    (6) constant -> . functioncall
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    SUM             shift and go to state 107
    PLUS            shift and go to state 85
    MINUS           shift and go to state 84
    LPAREN          shift and go to state 82
    CTEI            shift and go to state 96
    CTEF            shift and go to state 94
    CTESTRING       shift and go to state 99
    CTEBOOL         shift and go to state 92
    ID              shift and go to state 89

    expresion                      shift and go to state 110
    term                           shift and go to state 91
    constant                       shift and go to state 88
    sum                            shift and go to state 108
    functioncall                   shift and go to state 87
    exp                            shift and go to state 95
    factor                         shift and go to state 86
    restrictions2                  shift and go to state 109

state 82

    (28) factor -> LPAREN . expresion RPAREN
    (34) expresion -> . exp
    (35) expresion -> . exp LESSTHAN exp
    (36) expresion -> . exp GREATERTHAN exp
    (37) expresion -> . exp BETWEEN exp
    (38) exp -> . term
    (39) exp -> . term PLUS exp
    (40) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . ID
    (6) constant -> . functioncall
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 85
    MINUS           shift and go to state 84
    LPAREN          shift and go to state 82
    CTEI            shift and go to state 96
    CTEF            shift and go to state 94
    CTESTRING       shift and go to state 99
    CTEBOOL         shift and go to state 92
    ID              shift and go to state 89

    expresion                      shift and go to state 111
    term                           shift and go to state 91
    constant                       shift and go to state 88
    functioncall                   shift and go to state 87
    exp                            shift and go to state 95
    factor                         shift and go to state 86

state 83

    (43) write2 -> CTESTRING .
    (45) write2 -> CTESTRING . DOT write2
    (3) constant -> CTESTRING .

  ! shift/reduce conflict for DOT resolved as shift
  ! reduce/reduce conflict for RPAREN resolved using rule 3 (constant -> CTESTRING .)
    DOT             shift and go to state 112
    STAR            reduce using rule 3 (constant -> CTESTRING .)
    SLASH           reduce using rule 3 (constant -> CTESTRING .)
    PLUS            reduce using rule 3 (constant -> CTESTRING .)
    MINUS           reduce using rule 3 (constant -> CTESTRING .)
    LESSTHAN        reduce using rule 3 (constant -> CTESTRING .)
    GREATERTHAN     reduce using rule 3 (constant -> CTESTRING .)
    BETWEEN         reduce using rule 3 (constant -> CTESTRING .)
    RPAREN          reduce using rule 3 (constant -> CTESTRING .)

  ! RPAREN          [ reduce using rule 43 (write2 -> CTESTRING .) ]
  ! DOT             [ reduce using rule 3 (constant -> CTESTRING .) ]


state 84

    (26) factor -> MINUS . constant
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . ID
    (6) constant -> . functioncall
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    CTEI            shift and go to state 96
    CTEF            shift and go to state 94
    CTESTRING       shift and go to state 99
    CTEBOOL         shift and go to state 92
    ID              shift and go to state 89

    functioncall                   shift and go to state 87
    constant                       shift and go to state 113

state 85

    (25) factor -> PLUS . constant
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . ID
    (6) constant -> . functioncall
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    CTEI            shift and go to state 96
    CTEF            shift and go to state 94
    CTESTRING       shift and go to state 99
    CTEBOOL         shift and go to state 92
    ID              shift and go to state 89

    functioncall                   shift and go to state 87
    constant                       shift and go to state 114

state 86

    (29) term -> factor .
    (30) term -> factor . STAR term
    (31) term -> factor . SLASH term

    PLUS            reduce using rule 29 (term -> factor .)
    MINUS           reduce using rule 29 (term -> factor .)
    LESSTHAN        reduce using rule 29 (term -> factor .)
    GREATERTHAN     reduce using rule 29 (term -> factor .)
    BETWEEN         reduce using rule 29 (term -> factor .)
    ID              reduce using rule 29 (term -> factor .)
    IF              reduce using rule 29 (term -> factor .)
    PRINT           reduce using rule 29 (term -> factor .)
    MIN             reduce using rule 29 (term -> factor .)
    MAX             reduce using rule 29 (term -> factor .)
    RETURN          reduce using rule 29 (term -> factor .)
    FOR             reduce using rule 29 (term -> factor .)
    RCURLY          reduce using rule 29 (term -> factor .)
    SEMIC           reduce using rule 29 (term -> factor .)
    ELSE            reduce using rule 29 (term -> factor .)
    RBRACKET        reduce using rule 29 (term -> factor .)
    DOT             reduce using rule 29 (term -> factor .)
    RPAREN          reduce using rule 29 (term -> factor .)
    STAR            shift and go to state 115
    SLASH           shift and go to state 116


state 87

    (6) constant -> functioncall .

    STAR            reduce using rule 6 (constant -> functioncall .)
    SLASH           reduce using rule 6 (constant -> functioncall .)
    PLUS            reduce using rule 6 (constant -> functioncall .)
    MINUS           reduce using rule 6 (constant -> functioncall .)
    LESSTHAN        reduce using rule 6 (constant -> functioncall .)
    GREATERTHAN     reduce using rule 6 (constant -> functioncall .)
    BETWEEN         reduce using rule 6 (constant -> functioncall .)
    DOT             reduce using rule 6 (constant -> functioncall .)
    RPAREN          reduce using rule 6 (constant -> functioncall .)
    SEMIC           reduce using rule 6 (constant -> functioncall .)
    ID              reduce using rule 6 (constant -> functioncall .)
    IF              reduce using rule 6 (constant -> functioncall .)
    PRINT           reduce using rule 6 (constant -> functioncall .)
    MIN             reduce using rule 6 (constant -> functioncall .)
    MAX             reduce using rule 6 (constant -> functioncall .)
    RETURN          reduce using rule 6 (constant -> functioncall .)
    FOR             reduce using rule 6 (constant -> functioncall .)
    RCURLY          reduce using rule 6 (constant -> functioncall .)
    ELSE            reduce using rule 6 (constant -> functioncall .)
    RBRACKET        reduce using rule 6 (constant -> functioncall .)


state 88

    (27) factor -> constant .

    STAR            reduce using rule 27 (factor -> constant .)
    SLASH           reduce using rule 27 (factor -> constant .)
    PLUS            reduce using rule 27 (factor -> constant .)
    MINUS           reduce using rule 27 (factor -> constant .)
    DOT             reduce using rule 27 (factor -> constant .)
    RPAREN          reduce using rule 27 (factor -> constant .)
    SEMIC           reduce using rule 27 (factor -> constant .)
    ID              reduce using rule 27 (factor -> constant .)
    IF              reduce using rule 27 (factor -> constant .)
    PRINT           reduce using rule 27 (factor -> constant .)
    MIN             reduce using rule 27 (factor -> constant .)
    MAX             reduce using rule 27 (factor -> constant .)
    RETURN          reduce using rule 27 (factor -> constant .)
    FOR             reduce using rule 27 (factor -> constant .)
    RCURLY          reduce using rule 27 (factor -> constant .)
    ELSE            reduce using rule 27 (factor -> constant .)
    RBRACKET        reduce using rule 27 (factor -> constant .)
    LESSTHAN        reduce using rule 27 (factor -> constant .)
    GREATERTHAN     reduce using rule 27 (factor -> constant .)
    BETWEEN         reduce using rule 27 (factor -> constant .)


state 89

    (5) constant -> ID .
    (7) functioncall -> ID . LPAREN expresion RPAREN
    (8) functioncall -> ID . LPAREN CTEI RPAREN
    (9) functioncall -> ID . LPAREN CTEF RPAREN

    STAR            reduce using rule 5 (constant -> ID .)
    SLASH           reduce using rule 5 (constant -> ID .)
    PLUS            reduce using rule 5 (constant -> ID .)
    MINUS           reduce using rule 5 (constant -> ID .)
    LESSTHAN        reduce using rule 5 (constant -> ID .)
    GREATERTHAN     reduce using rule 5 (constant -> ID .)
    BETWEEN         reduce using rule 5 (constant -> ID .)
    DOT             reduce using rule 5 (constant -> ID .)
    RPAREN          reduce using rule 5 (constant -> ID .)
    SEMIC           reduce using rule 5 (constant -> ID .)
    ID              reduce using rule 5 (constant -> ID .)
    IF              reduce using rule 5 (constant -> ID .)
    PRINT           reduce using rule 5 (constant -> ID .)
    MIN             reduce using rule 5 (constant -> ID .)
    MAX             reduce using rule 5 (constant -> ID .)
    RETURN          reduce using rule 5 (constant -> ID .)
    FOR             reduce using rule 5 (constant -> ID .)
    RCURLY          reduce using rule 5 (constant -> ID .)
    ELSE            reduce using rule 5 (constant -> ID .)
    RBRACKET        reduce using rule 5 (constant -> ID .)
    LPAREN          shift and go to state 117


state 90

    (42) write2 -> expresion .
    (44) write2 -> expresion . DOT write2

    RPAREN          reduce using rule 42 (write2 -> expresion .)
    DOT             shift and go to state 118


state 91

    (38) exp -> term .
    (39) exp -> term . PLUS exp
    (40) exp -> term . MINUS exp

    DOT             reduce using rule 38 (exp -> term .)
    RPAREN          reduce using rule 38 (exp -> term .)
    SEMIC           reduce using rule 38 (exp -> term .)
    ID              reduce using rule 38 (exp -> term .)
    IF              reduce using rule 38 (exp -> term .)
    PRINT           reduce using rule 38 (exp -> term .)
    MIN             reduce using rule 38 (exp -> term .)
    MAX             reduce using rule 38 (exp -> term .)
    RETURN          reduce using rule 38 (exp -> term .)
    FOR             reduce using rule 38 (exp -> term .)
    RCURLY          reduce using rule 38 (exp -> term .)
    ELSE            reduce using rule 38 (exp -> term .)
    RBRACKET        reduce using rule 38 (exp -> term .)
    LESSTHAN        reduce using rule 38 (exp -> term .)
    GREATERTHAN     reduce using rule 38 (exp -> term .)
    BETWEEN         reduce using rule 38 (exp -> term .)
    PLUS            shift and go to state 119
    MINUS           shift and go to state 120


state 92

    (4) constant -> CTEBOOL .

    STAR            reduce using rule 4 (constant -> CTEBOOL .)
    SLASH           reduce using rule 4 (constant -> CTEBOOL .)
    PLUS            reduce using rule 4 (constant -> CTEBOOL .)
    MINUS           reduce using rule 4 (constant -> CTEBOOL .)
    LESSTHAN        reduce using rule 4 (constant -> CTEBOOL .)
    GREATERTHAN     reduce using rule 4 (constant -> CTEBOOL .)
    BETWEEN         reduce using rule 4 (constant -> CTEBOOL .)
    DOT             reduce using rule 4 (constant -> CTEBOOL .)
    RPAREN          reduce using rule 4 (constant -> CTEBOOL .)
    SEMIC           reduce using rule 4 (constant -> CTEBOOL .)
    ID              reduce using rule 4 (constant -> CTEBOOL .)
    IF              reduce using rule 4 (constant -> CTEBOOL .)
    PRINT           reduce using rule 4 (constant -> CTEBOOL .)
    MIN             reduce using rule 4 (constant -> CTEBOOL .)
    MAX             reduce using rule 4 (constant -> CTEBOOL .)
    RETURN          reduce using rule 4 (constant -> CTEBOOL .)
    FOR             reduce using rule 4 (constant -> CTEBOOL .)
    RCURLY          reduce using rule 4 (constant -> CTEBOOL .)
    ELSE            reduce using rule 4 (constant -> CTEBOOL .)
    RBRACKET        reduce using rule 4 (constant -> CTEBOOL .)


state 93

    (41) write -> PRINT LPAREN write2 . RPAREN SEMIC

    RPAREN          shift and go to state 121


state 94

    (2) constant -> CTEF .

    STAR            reduce using rule 2 (constant -> CTEF .)
    SLASH           reduce using rule 2 (constant -> CTEF .)
    PLUS            reduce using rule 2 (constant -> CTEF .)
    MINUS           reduce using rule 2 (constant -> CTEF .)
    LESSTHAN        reduce using rule 2 (constant -> CTEF .)
    GREATERTHAN     reduce using rule 2 (constant -> CTEF .)
    BETWEEN         reduce using rule 2 (constant -> CTEF .)
    DOT             reduce using rule 2 (constant -> CTEF .)
    RPAREN          reduce using rule 2 (constant -> CTEF .)
    SEMIC           reduce using rule 2 (constant -> CTEF .)
    ID              reduce using rule 2 (constant -> CTEF .)
    IF              reduce using rule 2 (constant -> CTEF .)
    PRINT           reduce using rule 2 (constant -> CTEF .)
    MIN             reduce using rule 2 (constant -> CTEF .)
    MAX             reduce using rule 2 (constant -> CTEF .)
    RETURN          reduce using rule 2 (constant -> CTEF .)
    FOR             reduce using rule 2 (constant -> CTEF .)
    RCURLY          reduce using rule 2 (constant -> CTEF .)
    ELSE            reduce using rule 2 (constant -> CTEF .)
    RBRACKET        reduce using rule 2 (constant -> CTEF .)


state 95

    (34) expresion -> exp .
    (35) expresion -> exp . LESSTHAN exp
    (36) expresion -> exp . GREATERTHAN exp
    (37) expresion -> exp . BETWEEN exp

    RPAREN          reduce using rule 34 (expresion -> exp .)
    DOT             reduce using rule 34 (expresion -> exp .)
    SEMIC           reduce using rule 34 (expresion -> exp .)
    ID              reduce using rule 34 (expresion -> exp .)
    IF              reduce using rule 34 (expresion -> exp .)
    PRINT           reduce using rule 34 (expresion -> exp .)
    MIN             reduce using rule 34 (expresion -> exp .)
    MAX             reduce using rule 34 (expresion -> exp .)
    RETURN          reduce using rule 34 (expresion -> exp .)
    FOR             reduce using rule 34 (expresion -> exp .)
    RCURLY          reduce using rule 34 (expresion -> exp .)
    ELSE            reduce using rule 34 (expresion -> exp .)
    RBRACKET        reduce using rule 34 (expresion -> exp .)
    LESSTHAN        shift and go to state 122
    GREATERTHAN     shift and go to state 123
    BETWEEN         shift and go to state 124


state 96

    (1) constant -> CTEI .

    STAR            reduce using rule 1 (constant -> CTEI .)
    SLASH           reduce using rule 1 (constant -> CTEI .)
    PLUS            reduce using rule 1 (constant -> CTEI .)
    MINUS           reduce using rule 1 (constant -> CTEI .)
    LESSTHAN        reduce using rule 1 (constant -> CTEI .)
    GREATERTHAN     reduce using rule 1 (constant -> CTEI .)
    BETWEEN         reduce using rule 1 (constant -> CTEI .)
    DOT             reduce using rule 1 (constant -> CTEI .)
    RPAREN          reduce using rule 1 (constant -> CTEI .)
    SEMIC           reduce using rule 1 (constant -> CTEI .)
    ID              reduce using rule 1 (constant -> CTEI .)
    IF              reduce using rule 1 (constant -> CTEI .)
    PRINT           reduce using rule 1 (constant -> CTEI .)
    MIN             reduce using rule 1 (constant -> CTEI .)
    MAX             reduce using rule 1 (constant -> CTEI .)
    RETURN          reduce using rule 1 (constant -> CTEI .)
    FOR             reduce using rule 1 (constant -> CTEI .)
    RCURLY          reduce using rule 1 (constant -> CTEI .)
    ELSE            reduce using rule 1 (constant -> CTEI .)
    RBRACKET        reduce using rule 1 (constant -> CTEI .)


state 97

    (20) for -> FOR ID IN . DOT ID LBRACKET statement RBRACKET

    DOT             shift and go to state 125


state 98

    (46) asign -> ID EQUALS expresion . SEMIC

    SEMIC           shift and go to state 126


state 99

    (3) constant -> CTESTRING .

    STAR            reduce using rule 3 (constant -> CTESTRING .)
    SLASH           reduce using rule 3 (constant -> CTESTRING .)
    PLUS            reduce using rule 3 (constant -> CTESTRING .)
    MINUS           reduce using rule 3 (constant -> CTESTRING .)
    LESSTHAN        reduce using rule 3 (constant -> CTESTRING .)
    GREATERTHAN     reduce using rule 3 (constant -> CTESTRING .)
    BETWEEN         reduce using rule 3 (constant -> CTESTRING .)
    DOT             reduce using rule 3 (constant -> CTESTRING .)
    RPAREN          reduce using rule 3 (constant -> CTESTRING .)
    SEMIC           reduce using rule 3 (constant -> CTESTRING .)
    ID              reduce using rule 3 (constant -> CTESTRING .)
    IF              reduce using rule 3 (constant -> CTESTRING .)
    PRINT           reduce using rule 3 (constant -> CTESTRING .)
    MIN             reduce using rule 3 (constant -> CTESTRING .)
    MAX             reduce using rule 3 (constant -> CTESTRING .)
    RETURN          reduce using rule 3 (constant -> CTESTRING .)
    FOR             reduce using rule 3 (constant -> CTESTRING .)
    RCURLY          reduce using rule 3 (constant -> CTESTRING .)
    ELSE            reduce using rule 3 (constant -> CTESTRING .)
    RBRACKET        reduce using rule 3 (constant -> CTESTRING .)


state 100

    (32) condition -> IF LPAREN expresion . RPAREN block SEMIC
    (33) condition -> IF LPAREN expresion . RPAREN block ELSE block SEMIC

    RPAREN          shift and go to state 127


state 101

    (16) optimize -> MAX EQUALS restrictions .

    RBRACKET        reduce using rule 16 (optimize -> MAX EQUALS restrictions .)
    ID              reduce using rule 16 (optimize -> MAX EQUALS restrictions .)
    IF              reduce using rule 16 (optimize -> MAX EQUALS restrictions .)
    PRINT           reduce using rule 16 (optimize -> MAX EQUALS restrictions .)
    MIN             reduce using rule 16 (optimize -> MAX EQUALS restrictions .)
    MAX             reduce using rule 16 (optimize -> MAX EQUALS restrictions .)
    RETURN          reduce using rule 16 (optimize -> MAX EQUALS restrictions .)
    FOR             reduce using rule 16 (optimize -> MAX EQUALS restrictions .)
    RCURLY          reduce using rule 16 (optimize -> MAX EQUALS restrictions .)
    SEMIC           reduce using rule 16 (optimize -> MAX EQUALS restrictions .)
    ELSE            reduce using rule 16 (optimize -> MAX EQUALS restrictions .)


state 102

    (59) liargs -> COMMA manyargs .

    RPAREN          reduce using rule 59 (liargs -> COMMA manyargs .)


state 103

    (55) function -> FUNC ID LPAREN manyargs RPAREN LCURLY varsdata . block2 RCURLY
    (62) block2 -> . statement block2
    (63) block2 -> . statement
    (64) block2 -> . empty
    (47) statement -> . asign
    (48) statement -> . condition
    (49) statement -> . write
    (50) statement -> . optimize
    (51) statement -> . loop
    (52) statement -> . return
    (88) empty -> .
    (46) asign -> . ID EQUALS expresion SEMIC
    (32) condition -> . IF LPAREN expresion RPAREN block SEMIC
    (33) condition -> . IF LPAREN expresion RPAREN block ELSE block SEMIC
    (41) write -> . PRINT LPAREN write2 RPAREN SEMIC
    (15) optimize -> . MIN EQUALS restrictions
    (16) optimize -> . MAX EQUALS restrictions
    (53) loop -> . for
    (54) return -> . RETURN asign
    (20) for -> . FOR ID IN DOT ID LBRACKET statement RBRACKET

    RCURLY          reduce using rule 88 (empty -> .)
    ID              shift and go to state 49
    IF              shift and go to state 51
    PRINT           shift and go to state 41
    MIN             shift and go to state 40
    MAX             shift and go to state 52
    RETURN          shift and go to state 38
    FOR             shift and go to state 48

    return                         shift and go to state 47
    block2                         shift and go to state 128
    for                            shift and go to state 42
    asign                          shift and go to state 53
    write                          shift and go to state 44
    condition                      shift and go to state 50
    statement                      shift and go to state 45
    loop                           shift and go to state 54
    optimize                       shift and go to state 43
    empty                          shift and go to state 46

state 104

    (69) matrix -> LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET .

    POINTS          reduce using rule 69 (matrix -> LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET .)


state 105

    (10) data -> DATA LCURLY asignmany RCURLY .

    ID              reduce using rule 10 (data -> DATA LCURLY asignmany RCURLY .)
    IF              reduce using rule 10 (data -> DATA LCURLY asignmany RCURLY .)
    PRINT           reduce using rule 10 (data -> DATA LCURLY asignmany RCURLY .)
    MIN             reduce using rule 10 (data -> DATA LCURLY asignmany RCURLY .)
    MAX             reduce using rule 10 (data -> DATA LCURLY asignmany RCURLY .)
    RETURN          reduce using rule 10 (data -> DATA LCURLY asignmany RCURLY .)
    FOR             reduce using rule 10 (data -> DATA LCURLY asignmany RCURLY .)
    RCURLY          reduce using rule 10 (data -> DATA LCURLY asignmany RCURLY .)


state 106

    (11) asignmany -> asign SEMIC . asignlist
    (13) asignlist -> . empty
    (14) asignlist -> . asignmany
    (88) empty -> .
    (11) asignmany -> . asign SEMIC asignlist
    (12) asignmany -> . asign
    (46) asign -> . ID EQUALS expresion SEMIC

    RCURLY          reduce using rule 88 (empty -> .)
    ID              shift and go to state 49

    asignmany                      shift and go to state 129
    asignlist                      shift and go to state 130
    empty                          shift and go to state 131
    asign                          shift and go to state 79

state 107

    (24) sum -> SUM . LPAREN ID POINTS expresion RPAREN

    LPAREN          shift and go to state 132


state 108

    (19) restrictions2 -> sum . SEMIC forlist

    SEMIC           shift and go to state 133


state 109

    (17) restrictions -> WHERE restrictions2 .

    ID              reduce using rule 17 (restrictions -> WHERE restrictions2 .)
    IF              reduce using rule 17 (restrictions -> WHERE restrictions2 .)
    PRINT           reduce using rule 17 (restrictions -> WHERE restrictions2 .)
    MIN             reduce using rule 17 (restrictions -> WHERE restrictions2 .)
    MAX             reduce using rule 17 (restrictions -> WHERE restrictions2 .)
    RETURN          reduce using rule 17 (restrictions -> WHERE restrictions2 .)
    FOR             reduce using rule 17 (restrictions -> WHERE restrictions2 .)
    RCURLY          reduce using rule 17 (restrictions -> WHERE restrictions2 .)
    SEMIC           reduce using rule 17 (restrictions -> WHERE restrictions2 .)
    ELSE            reduce using rule 17 (restrictions -> WHERE restrictions2 .)
    RBRACKET        reduce using rule 17 (restrictions -> WHERE restrictions2 .)


state 110

    (18) restrictions2 -> expresion .

    ID              reduce using rule 18 (restrictions2 -> expresion .)
    IF              reduce using rule 18 (restrictions2 -> expresion .)
    PRINT           reduce using rule 18 (restrictions2 -> expresion .)
    MIN             reduce using rule 18 (restrictions2 -> expresion .)
    MAX             reduce using rule 18 (restrictions2 -> expresion .)
    RETURN          reduce using rule 18 (restrictions2 -> expresion .)
    FOR             reduce using rule 18 (restrictions2 -> expresion .)
    RCURLY          reduce using rule 18 (restrictions2 -> expresion .)
    SEMIC           reduce using rule 18 (restrictions2 -> expresion .)
    ELSE            reduce using rule 18 (restrictions2 -> expresion .)
    RBRACKET        reduce using rule 18 (restrictions2 -> expresion .)


state 111

    (28) factor -> LPAREN expresion . RPAREN

    RPAREN          shift and go to state 134


state 112

    (45) write2 -> CTESTRING DOT . write2
    (42) write2 -> . expresion
    (43) write2 -> . CTESTRING
    (44) write2 -> . expresion DOT write2
    (45) write2 -> . CTESTRING DOT write2
    (34) expresion -> . exp
    (35) expresion -> . exp LESSTHAN exp
    (36) expresion -> . exp GREATERTHAN exp
    (37) expresion -> . exp BETWEEN exp
    (38) exp -> . term
    (39) exp -> . term PLUS exp
    (40) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . ID
    (6) constant -> . functioncall
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    CTESTRING       shift and go to state 83
    PLUS            shift and go to state 85
    MINUS           shift and go to state 84
    LPAREN          shift and go to state 82
    CTEI            shift and go to state 96
    CTEF            shift and go to state 94
    CTEBOOL         shift and go to state 92
    ID              shift and go to state 89

    expresion                      shift and go to state 90
    term                           shift and go to state 91
    constant                       shift and go to state 88
    write2                         shift and go to state 135
    functioncall                   shift and go to state 87
    exp                            shift and go to state 95
    factor                         shift and go to state 86

state 113

    (26) factor -> MINUS constant .

    STAR            reduce using rule 26 (factor -> MINUS constant .)
    SLASH           reduce using rule 26 (factor -> MINUS constant .)
    PLUS            reduce using rule 26 (factor -> MINUS constant .)
    MINUS           reduce using rule 26 (factor -> MINUS constant .)
    DOT             reduce using rule 26 (factor -> MINUS constant .)
    RPAREN          reduce using rule 26 (factor -> MINUS constant .)
    SEMIC           reduce using rule 26 (factor -> MINUS constant .)
    ID              reduce using rule 26 (factor -> MINUS constant .)
    IF              reduce using rule 26 (factor -> MINUS constant .)
    PRINT           reduce using rule 26 (factor -> MINUS constant .)
    MIN             reduce using rule 26 (factor -> MINUS constant .)
    MAX             reduce using rule 26 (factor -> MINUS constant .)
    RETURN          reduce using rule 26 (factor -> MINUS constant .)
    FOR             reduce using rule 26 (factor -> MINUS constant .)
    RCURLY          reduce using rule 26 (factor -> MINUS constant .)
    ELSE            reduce using rule 26 (factor -> MINUS constant .)
    RBRACKET        reduce using rule 26 (factor -> MINUS constant .)
    LESSTHAN        reduce using rule 26 (factor -> MINUS constant .)
    GREATERTHAN     reduce using rule 26 (factor -> MINUS constant .)
    BETWEEN         reduce using rule 26 (factor -> MINUS constant .)


state 114

    (25) factor -> PLUS constant .

    STAR            reduce using rule 25 (factor -> PLUS constant .)
    SLASH           reduce using rule 25 (factor -> PLUS constant .)
    PLUS            reduce using rule 25 (factor -> PLUS constant .)
    MINUS           reduce using rule 25 (factor -> PLUS constant .)
    DOT             reduce using rule 25 (factor -> PLUS constant .)
    RPAREN          reduce using rule 25 (factor -> PLUS constant .)
    SEMIC           reduce using rule 25 (factor -> PLUS constant .)
    ID              reduce using rule 25 (factor -> PLUS constant .)
    IF              reduce using rule 25 (factor -> PLUS constant .)
    PRINT           reduce using rule 25 (factor -> PLUS constant .)
    MIN             reduce using rule 25 (factor -> PLUS constant .)
    MAX             reduce using rule 25 (factor -> PLUS constant .)
    RETURN          reduce using rule 25 (factor -> PLUS constant .)
    FOR             reduce using rule 25 (factor -> PLUS constant .)
    RCURLY          reduce using rule 25 (factor -> PLUS constant .)
    ELSE            reduce using rule 25 (factor -> PLUS constant .)
    RBRACKET        reduce using rule 25 (factor -> PLUS constant .)
    LESSTHAN        reduce using rule 25 (factor -> PLUS constant .)
    GREATERTHAN     reduce using rule 25 (factor -> PLUS constant .)
    BETWEEN         reduce using rule 25 (factor -> PLUS constant .)


state 115

    (30) term -> factor STAR . term
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . ID
    (6) constant -> . functioncall
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 85
    MINUS           shift and go to state 84
    LPAREN          shift and go to state 82
    CTEI            shift and go to state 96
    CTEF            shift and go to state 94
    CTESTRING       shift and go to state 99
    CTEBOOL         shift and go to state 92
    ID              shift and go to state 89

    functioncall                   shift and go to state 87
    term                           shift and go to state 136
    constant                       shift and go to state 88
    factor                         shift and go to state 86

state 116

    (31) term -> factor SLASH . term
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . ID
    (6) constant -> . functioncall
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 85
    MINUS           shift and go to state 84
    LPAREN          shift and go to state 82
    CTEI            shift and go to state 96
    CTEF            shift and go to state 94
    CTESTRING       shift and go to state 99
    CTEBOOL         shift and go to state 92
    ID              shift and go to state 89

    functioncall                   shift and go to state 87
    term                           shift and go to state 137
    constant                       shift and go to state 88
    factor                         shift and go to state 86

state 117

    (7) functioncall -> ID LPAREN . expresion RPAREN
    (8) functioncall -> ID LPAREN . CTEI RPAREN
    (9) functioncall -> ID LPAREN . CTEF RPAREN
    (34) expresion -> . exp
    (35) expresion -> . exp LESSTHAN exp
    (36) expresion -> . exp GREATERTHAN exp
    (37) expresion -> . exp BETWEEN exp
    (38) exp -> . term
    (39) exp -> . term PLUS exp
    (40) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . ID
    (6) constant -> . functioncall
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    CTEI            shift and go to state 140
    CTEF            shift and go to state 139
    PLUS            shift and go to state 85
    MINUS           shift and go to state 84
    LPAREN          shift and go to state 82
    CTESTRING       shift and go to state 99
    CTEBOOL         shift and go to state 92
    ID              shift and go to state 89

    expresion                      shift and go to state 138
    term                           shift and go to state 91
    constant                       shift and go to state 88
    functioncall                   shift and go to state 87
    exp                            shift and go to state 95
    factor                         shift and go to state 86

state 118

    (44) write2 -> expresion DOT . write2
    (42) write2 -> . expresion
    (43) write2 -> . CTESTRING
    (44) write2 -> . expresion DOT write2
    (45) write2 -> . CTESTRING DOT write2
    (34) expresion -> . exp
    (35) expresion -> . exp LESSTHAN exp
    (36) expresion -> . exp GREATERTHAN exp
    (37) expresion -> . exp BETWEEN exp
    (38) exp -> . term
    (39) exp -> . term PLUS exp
    (40) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . ID
    (6) constant -> . functioncall
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    CTESTRING       shift and go to state 83
    PLUS            shift and go to state 85
    MINUS           shift and go to state 84
    LPAREN          shift and go to state 82
    CTEI            shift and go to state 96
    CTEF            shift and go to state 94
    CTEBOOL         shift and go to state 92
    ID              shift and go to state 89

    expresion                      shift and go to state 90
    term                           shift and go to state 91
    constant                       shift and go to state 88
    write2                         shift and go to state 141
    functioncall                   shift and go to state 87
    exp                            shift and go to state 95
    factor                         shift and go to state 86

state 119

    (39) exp -> term PLUS . exp
    (38) exp -> . term
    (39) exp -> . term PLUS exp
    (40) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . ID
    (6) constant -> . functioncall
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 85
    MINUS           shift and go to state 84
    LPAREN          shift and go to state 82
    CTEI            shift and go to state 96
    CTEF            shift and go to state 94
    CTESTRING       shift and go to state 99
    CTEBOOL         shift and go to state 92
    ID              shift and go to state 89

    term                           shift and go to state 91
    constant                       shift and go to state 88
    functioncall                   shift and go to state 87
    exp                            shift and go to state 142
    factor                         shift and go to state 86

state 120

    (40) exp -> term MINUS . exp
    (38) exp -> . term
    (39) exp -> . term PLUS exp
    (40) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . ID
    (6) constant -> . functioncall
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 85
    MINUS           shift and go to state 84
    LPAREN          shift and go to state 82
    CTEI            shift and go to state 96
    CTEF            shift and go to state 94
    CTESTRING       shift and go to state 99
    CTEBOOL         shift and go to state 92
    ID              shift and go to state 89

    term                           shift and go to state 91
    constant                       shift and go to state 88
    functioncall                   shift and go to state 87
    exp                            shift and go to state 143
    factor                         shift and go to state 86

state 121

    (41) write -> PRINT LPAREN write2 RPAREN . SEMIC

    SEMIC           shift and go to state 144


state 122

    (35) expresion -> exp LESSTHAN . exp
    (38) exp -> . term
    (39) exp -> . term PLUS exp
    (40) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . ID
    (6) constant -> . functioncall
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 85
    MINUS           shift and go to state 84
    LPAREN          shift and go to state 82
    CTEI            shift and go to state 96
    CTEF            shift and go to state 94
    CTESTRING       shift and go to state 99
    CTEBOOL         shift and go to state 92
    ID              shift and go to state 89

    term                           shift and go to state 91
    constant                       shift and go to state 88
    functioncall                   shift and go to state 87
    exp                            shift and go to state 145
    factor                         shift and go to state 86

state 123

    (36) expresion -> exp GREATERTHAN . exp
    (38) exp -> . term
    (39) exp -> . term PLUS exp
    (40) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . ID
    (6) constant -> . functioncall
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 85
    MINUS           shift and go to state 84
    LPAREN          shift and go to state 82
    CTEI            shift and go to state 96
    CTEF            shift and go to state 94
    CTESTRING       shift and go to state 99
    CTEBOOL         shift and go to state 92
    ID              shift and go to state 89

    term                           shift and go to state 91
    constant                       shift and go to state 88
    functioncall                   shift and go to state 87
    exp                            shift and go to state 146
    factor                         shift and go to state 86

state 124

    (37) expresion -> exp BETWEEN . exp
    (38) exp -> . term
    (39) exp -> . term PLUS exp
    (40) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . ID
    (6) constant -> . functioncall
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 85
    MINUS           shift and go to state 84
    LPAREN          shift and go to state 82
    CTEI            shift and go to state 96
    CTEF            shift and go to state 94
    CTESTRING       shift and go to state 99
    CTEBOOL         shift and go to state 92
    ID              shift and go to state 89

    term                           shift and go to state 91
    constant                       shift and go to state 88
    functioncall                   shift and go to state 87
    exp                            shift and go to state 147
    factor                         shift and go to state 86

state 125

    (20) for -> FOR ID IN DOT . ID LBRACKET statement RBRACKET

    ID              shift and go to state 148


state 126

    (46) asign -> ID EQUALS expresion SEMIC .

    ID              reduce using rule 46 (asign -> ID EQUALS expresion SEMIC .)
    IF              reduce using rule 46 (asign -> ID EQUALS expresion SEMIC .)
    PRINT           reduce using rule 46 (asign -> ID EQUALS expresion SEMIC .)
    MIN             reduce using rule 46 (asign -> ID EQUALS expresion SEMIC .)
    MAX             reduce using rule 46 (asign -> ID EQUALS expresion SEMIC .)
    RETURN          reduce using rule 46 (asign -> ID EQUALS expresion SEMIC .)
    FOR             reduce using rule 46 (asign -> ID EQUALS expresion SEMIC .)
    RCURLY          reduce using rule 46 (asign -> ID EQUALS expresion SEMIC .)
    SEMIC           reduce using rule 46 (asign -> ID EQUALS expresion SEMIC .)
    ELSE            reduce using rule 46 (asign -> ID EQUALS expresion SEMIC .)
    RBRACKET        reduce using rule 46 (asign -> ID EQUALS expresion SEMIC .)


state 127

    (32) condition -> IF LPAREN expresion RPAREN . block SEMIC
    (33) condition -> IF LPAREN expresion RPAREN . block ELSE block SEMIC
    (60) block -> . block2
    (61) block -> . LCURLY RCURLY
    (62) block2 -> . statement block2
    (63) block2 -> . statement
    (64) block2 -> . empty
    (47) statement -> . asign
    (48) statement -> . condition
    (49) statement -> . write
    (50) statement -> . optimize
    (51) statement -> . loop
    (52) statement -> . return
    (88) empty -> .
    (46) asign -> . ID EQUALS expresion SEMIC
    (32) condition -> . IF LPAREN expresion RPAREN block SEMIC
    (33) condition -> . IF LPAREN expresion RPAREN block ELSE block SEMIC
    (41) write -> . PRINT LPAREN write2 RPAREN SEMIC
    (15) optimize -> . MIN EQUALS restrictions
    (16) optimize -> . MAX EQUALS restrictions
    (53) loop -> . for
    (54) return -> . RETURN asign
    (20) for -> . FOR ID IN DOT ID LBRACKET statement RBRACKET

    LCURLY          shift and go to state 150
    SEMIC           reduce using rule 88 (empty -> .)
    ELSE            reduce using rule 88 (empty -> .)
    ID              shift and go to state 49
    IF              shift and go to state 51
    PRINT           shift and go to state 41
    MIN             shift and go to state 40
    MAX             shift and go to state 52
    RETURN          shift and go to state 38
    FOR             shift and go to state 48

    return                         shift and go to state 47
    block2                         shift and go to state 149
    for                            shift and go to state 42
    condition                      shift and go to state 50
    asign                          shift and go to state 53
    write                          shift and go to state 44
    block                          shift and go to state 151
    statement                      shift and go to state 45
    loop                           shift and go to state 54
    optimize                       shift and go to state 43
    empty                          shift and go to state 46

state 128

    (55) function -> FUNC ID LPAREN manyargs RPAREN LCURLY varsdata block2 . RCURLY

    RCURLY          shift and go to state 152


state 129

    (14) asignlist -> asignmany .

    RCURLY          reduce using rule 14 (asignlist -> asignmany .)


state 130

    (11) asignmany -> asign SEMIC asignlist .

    RCURLY          reduce using rule 11 (asignmany -> asign SEMIC asignlist .)


state 131

    (13) asignlist -> empty .

    RCURLY          reduce using rule 13 (asignlist -> empty .)


state 132

    (24) sum -> SUM LPAREN . ID POINTS expresion RPAREN

    ID              shift and go to state 153


state 133

    (19) restrictions2 -> sum SEMIC . forlist
    (21) forlist -> . for SEMIC lfor
    (20) for -> . FOR ID IN DOT ID LBRACKET statement RBRACKET

    FOR             shift and go to state 48

    forlist                        shift and go to state 155
    for                            shift and go to state 154

state 134

    (28) factor -> LPAREN expresion RPAREN .

    STAR            reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    SLASH           reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    PLUS            reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    MINUS           reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    DOT             reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    RPAREN          reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    SEMIC           reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    ID              reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    IF              reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    PRINT           reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    MIN             reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    MAX             reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    RETURN          reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    FOR             reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    RCURLY          reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    ELSE            reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    RBRACKET        reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    LESSTHAN        reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    GREATERTHAN     reduce using rule 28 (factor -> LPAREN expresion RPAREN .)
    BETWEEN         reduce using rule 28 (factor -> LPAREN expresion RPAREN .)


state 135

    (45) write2 -> CTESTRING DOT write2 .

    RPAREN          reduce using rule 45 (write2 -> CTESTRING DOT write2 .)


state 136

    (30) term -> factor STAR term .

    PLUS            reduce using rule 30 (term -> factor STAR term .)
    MINUS           reduce using rule 30 (term -> factor STAR term .)
    LESSTHAN        reduce using rule 30 (term -> factor STAR term .)
    GREATERTHAN     reduce using rule 30 (term -> factor STAR term .)
    BETWEEN         reduce using rule 30 (term -> factor STAR term .)
    ID              reduce using rule 30 (term -> factor STAR term .)
    IF              reduce using rule 30 (term -> factor STAR term .)
    PRINT           reduce using rule 30 (term -> factor STAR term .)
    MIN             reduce using rule 30 (term -> factor STAR term .)
    MAX             reduce using rule 30 (term -> factor STAR term .)
    RETURN          reduce using rule 30 (term -> factor STAR term .)
    FOR             reduce using rule 30 (term -> factor STAR term .)
    RCURLY          reduce using rule 30 (term -> factor STAR term .)
    SEMIC           reduce using rule 30 (term -> factor STAR term .)
    ELSE            reduce using rule 30 (term -> factor STAR term .)
    RBRACKET        reduce using rule 30 (term -> factor STAR term .)
    DOT             reduce using rule 30 (term -> factor STAR term .)
    RPAREN          reduce using rule 30 (term -> factor STAR term .)


state 137

    (31) term -> factor SLASH term .

    PLUS            reduce using rule 31 (term -> factor SLASH term .)
    MINUS           reduce using rule 31 (term -> factor SLASH term .)
    LESSTHAN        reduce using rule 31 (term -> factor SLASH term .)
    GREATERTHAN     reduce using rule 31 (term -> factor SLASH term .)
    BETWEEN         reduce using rule 31 (term -> factor SLASH term .)
    ID              reduce using rule 31 (term -> factor SLASH term .)
    IF              reduce using rule 31 (term -> factor SLASH term .)
    PRINT           reduce using rule 31 (term -> factor SLASH term .)
    MIN             reduce using rule 31 (term -> factor SLASH term .)
    MAX             reduce using rule 31 (term -> factor SLASH term .)
    RETURN          reduce using rule 31 (term -> factor SLASH term .)
    FOR             reduce using rule 31 (term -> factor SLASH term .)
    RCURLY          reduce using rule 31 (term -> factor SLASH term .)
    SEMIC           reduce using rule 31 (term -> factor SLASH term .)
    ELSE            reduce using rule 31 (term -> factor SLASH term .)
    RBRACKET        reduce using rule 31 (term -> factor SLASH term .)
    DOT             reduce using rule 31 (term -> factor SLASH term .)
    RPAREN          reduce using rule 31 (term -> factor SLASH term .)


state 138

    (7) functioncall -> ID LPAREN expresion . RPAREN

    RPAREN          shift and go to state 156


state 139

    (9) functioncall -> ID LPAREN CTEF . RPAREN
    (2) constant -> CTEF .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 157
    STAR            reduce using rule 2 (constant -> CTEF .)
    SLASH           reduce using rule 2 (constant -> CTEF .)
    PLUS            reduce using rule 2 (constant -> CTEF .)
    MINUS           reduce using rule 2 (constant -> CTEF .)
    LESSTHAN        reduce using rule 2 (constant -> CTEF .)
    GREATERTHAN     reduce using rule 2 (constant -> CTEF .)
    BETWEEN         reduce using rule 2 (constant -> CTEF .)

  ! RPAREN          [ reduce using rule 2 (constant -> CTEF .) ]


state 140

    (8) functioncall -> ID LPAREN CTEI . RPAREN
    (1) constant -> CTEI .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 158
    STAR            reduce using rule 1 (constant -> CTEI .)
    SLASH           reduce using rule 1 (constant -> CTEI .)
    PLUS            reduce using rule 1 (constant -> CTEI .)
    MINUS           reduce using rule 1 (constant -> CTEI .)
    LESSTHAN        reduce using rule 1 (constant -> CTEI .)
    GREATERTHAN     reduce using rule 1 (constant -> CTEI .)
    BETWEEN         reduce using rule 1 (constant -> CTEI .)

  ! RPAREN          [ reduce using rule 1 (constant -> CTEI .) ]


state 141

    (44) write2 -> expresion DOT write2 .

    RPAREN          reduce using rule 44 (write2 -> expresion DOT write2 .)


state 142

    (39) exp -> term PLUS exp .

    DOT             reduce using rule 39 (exp -> term PLUS exp .)
    RPAREN          reduce using rule 39 (exp -> term PLUS exp .)
    SEMIC           reduce using rule 39 (exp -> term PLUS exp .)
    ID              reduce using rule 39 (exp -> term PLUS exp .)
    IF              reduce using rule 39 (exp -> term PLUS exp .)
    PRINT           reduce using rule 39 (exp -> term PLUS exp .)
    MIN             reduce using rule 39 (exp -> term PLUS exp .)
    MAX             reduce using rule 39 (exp -> term PLUS exp .)
    RETURN          reduce using rule 39 (exp -> term PLUS exp .)
    FOR             reduce using rule 39 (exp -> term PLUS exp .)
    RCURLY          reduce using rule 39 (exp -> term PLUS exp .)
    ELSE            reduce using rule 39 (exp -> term PLUS exp .)
    RBRACKET        reduce using rule 39 (exp -> term PLUS exp .)
    LESSTHAN        reduce using rule 39 (exp -> term PLUS exp .)
    GREATERTHAN     reduce using rule 39 (exp -> term PLUS exp .)
    BETWEEN         reduce using rule 39 (exp -> term PLUS exp .)


state 143

    (40) exp -> term MINUS exp .

    DOT             reduce using rule 40 (exp -> term MINUS exp .)
    RPAREN          reduce using rule 40 (exp -> term MINUS exp .)
    SEMIC           reduce using rule 40 (exp -> term MINUS exp .)
    ID              reduce using rule 40 (exp -> term MINUS exp .)
    IF              reduce using rule 40 (exp -> term MINUS exp .)
    PRINT           reduce using rule 40 (exp -> term MINUS exp .)
    MIN             reduce using rule 40 (exp -> term MINUS exp .)
    MAX             reduce using rule 40 (exp -> term MINUS exp .)
    RETURN          reduce using rule 40 (exp -> term MINUS exp .)
    FOR             reduce using rule 40 (exp -> term MINUS exp .)
    RCURLY          reduce using rule 40 (exp -> term MINUS exp .)
    ELSE            reduce using rule 40 (exp -> term MINUS exp .)
    RBRACKET        reduce using rule 40 (exp -> term MINUS exp .)
    LESSTHAN        reduce using rule 40 (exp -> term MINUS exp .)
    GREATERTHAN     reduce using rule 40 (exp -> term MINUS exp .)
    BETWEEN         reduce using rule 40 (exp -> term MINUS exp .)


state 144

    (41) write -> PRINT LPAREN write2 RPAREN SEMIC .

    ID              reduce using rule 41 (write -> PRINT LPAREN write2 RPAREN SEMIC .)
    IF              reduce using rule 41 (write -> PRINT LPAREN write2 RPAREN SEMIC .)
    PRINT           reduce using rule 41 (write -> PRINT LPAREN write2 RPAREN SEMIC .)
    MIN             reduce using rule 41 (write -> PRINT LPAREN write2 RPAREN SEMIC .)
    MAX             reduce using rule 41 (write -> PRINT LPAREN write2 RPAREN SEMIC .)
    RETURN          reduce using rule 41 (write -> PRINT LPAREN write2 RPAREN SEMIC .)
    FOR             reduce using rule 41 (write -> PRINT LPAREN write2 RPAREN SEMIC .)
    RCURLY          reduce using rule 41 (write -> PRINT LPAREN write2 RPAREN SEMIC .)
    RBRACKET        reduce using rule 41 (write -> PRINT LPAREN write2 RPAREN SEMIC .)
    SEMIC           reduce using rule 41 (write -> PRINT LPAREN write2 RPAREN SEMIC .)
    ELSE            reduce using rule 41 (write -> PRINT LPAREN write2 RPAREN SEMIC .)


state 145

    (35) expresion -> exp LESSTHAN exp .

    RPAREN          reduce using rule 35 (expresion -> exp LESSTHAN exp .)
    DOT             reduce using rule 35 (expresion -> exp LESSTHAN exp .)
    SEMIC           reduce using rule 35 (expresion -> exp LESSTHAN exp .)
    ID              reduce using rule 35 (expresion -> exp LESSTHAN exp .)
    IF              reduce using rule 35 (expresion -> exp LESSTHAN exp .)
    PRINT           reduce using rule 35 (expresion -> exp LESSTHAN exp .)
    MIN             reduce using rule 35 (expresion -> exp LESSTHAN exp .)
    MAX             reduce using rule 35 (expresion -> exp LESSTHAN exp .)
    RETURN          reduce using rule 35 (expresion -> exp LESSTHAN exp .)
    FOR             reduce using rule 35 (expresion -> exp LESSTHAN exp .)
    RCURLY          reduce using rule 35 (expresion -> exp LESSTHAN exp .)
    ELSE            reduce using rule 35 (expresion -> exp LESSTHAN exp .)
    RBRACKET        reduce using rule 35 (expresion -> exp LESSTHAN exp .)


state 146

    (36) expresion -> exp GREATERTHAN exp .

    RPAREN          reduce using rule 36 (expresion -> exp GREATERTHAN exp .)
    DOT             reduce using rule 36 (expresion -> exp GREATERTHAN exp .)
    SEMIC           reduce using rule 36 (expresion -> exp GREATERTHAN exp .)
    ID              reduce using rule 36 (expresion -> exp GREATERTHAN exp .)
    IF              reduce using rule 36 (expresion -> exp GREATERTHAN exp .)
    PRINT           reduce using rule 36 (expresion -> exp GREATERTHAN exp .)
    MIN             reduce using rule 36 (expresion -> exp GREATERTHAN exp .)
    MAX             reduce using rule 36 (expresion -> exp GREATERTHAN exp .)
    RETURN          reduce using rule 36 (expresion -> exp GREATERTHAN exp .)
    FOR             reduce using rule 36 (expresion -> exp GREATERTHAN exp .)
    RCURLY          reduce using rule 36 (expresion -> exp GREATERTHAN exp .)
    ELSE            reduce using rule 36 (expresion -> exp GREATERTHAN exp .)
    RBRACKET        reduce using rule 36 (expresion -> exp GREATERTHAN exp .)


state 147

    (37) expresion -> exp BETWEEN exp .

    RPAREN          reduce using rule 37 (expresion -> exp BETWEEN exp .)
    DOT             reduce using rule 37 (expresion -> exp BETWEEN exp .)
    SEMIC           reduce using rule 37 (expresion -> exp BETWEEN exp .)
    ID              reduce using rule 37 (expresion -> exp BETWEEN exp .)
    IF              reduce using rule 37 (expresion -> exp BETWEEN exp .)
    PRINT           reduce using rule 37 (expresion -> exp BETWEEN exp .)
    MIN             reduce using rule 37 (expresion -> exp BETWEEN exp .)
    MAX             reduce using rule 37 (expresion -> exp BETWEEN exp .)
    RETURN          reduce using rule 37 (expresion -> exp BETWEEN exp .)
    FOR             reduce using rule 37 (expresion -> exp BETWEEN exp .)
    RCURLY          reduce using rule 37 (expresion -> exp BETWEEN exp .)
    ELSE            reduce using rule 37 (expresion -> exp BETWEEN exp .)
    RBRACKET        reduce using rule 37 (expresion -> exp BETWEEN exp .)


state 148

    (20) for -> FOR ID IN DOT ID . LBRACKET statement RBRACKET

    LBRACKET        shift and go to state 159


state 149

    (60) block -> block2 .

    SEMIC           reduce using rule 60 (block -> block2 .)
    ELSE            reduce using rule 60 (block -> block2 .)


state 150

    (61) block -> LCURLY . RCURLY

    RCURLY          shift and go to state 160


state 151

    (32) condition -> IF LPAREN expresion RPAREN block . SEMIC
    (33) condition -> IF LPAREN expresion RPAREN block . ELSE block SEMIC

    SEMIC           shift and go to state 161
    ELSE            shift and go to state 162


state 152

    (55) function -> FUNC ID LPAREN manyargs RPAREN LCURLY varsdata block2 RCURLY .

    MODEL           reduce using rule 55 (function -> FUNC ID LPAREN manyargs RPAREN LCURLY varsdata block2 RCURLY .)


state 153

    (24) sum -> SUM LPAREN ID . POINTS expresion RPAREN

    POINTS          shift and go to state 163


state 154

    (21) forlist -> for . SEMIC lfor

    SEMIC           shift and go to state 164


state 155

    (19) restrictions2 -> sum SEMIC forlist .

    ID              reduce using rule 19 (restrictions2 -> sum SEMIC forlist .)
    IF              reduce using rule 19 (restrictions2 -> sum SEMIC forlist .)
    PRINT           reduce using rule 19 (restrictions2 -> sum SEMIC forlist .)
    MIN             reduce using rule 19 (restrictions2 -> sum SEMIC forlist .)
    MAX             reduce using rule 19 (restrictions2 -> sum SEMIC forlist .)
    RETURN          reduce using rule 19 (restrictions2 -> sum SEMIC forlist .)
    FOR             reduce using rule 19 (restrictions2 -> sum SEMIC forlist .)
    RCURLY          reduce using rule 19 (restrictions2 -> sum SEMIC forlist .)
    SEMIC           reduce using rule 19 (restrictions2 -> sum SEMIC forlist .)
    ELSE            reduce using rule 19 (restrictions2 -> sum SEMIC forlist .)
    RBRACKET        reduce using rule 19 (restrictions2 -> sum SEMIC forlist .)


state 156

    (7) functioncall -> ID LPAREN expresion RPAREN .

    STAR            reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    SLASH           reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    PLUS            reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    MINUS           reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    LESSTHAN        reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    GREATERTHAN     reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    BETWEEN         reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    RPAREN          reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    DOT             reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    SEMIC           reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    ID              reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    IF              reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    PRINT           reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    MIN             reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    MAX             reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    RETURN          reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    FOR             reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    RCURLY          reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    ELSE            reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)
    RBRACKET        reduce using rule 7 (functioncall -> ID LPAREN expresion RPAREN .)


state 157

    (9) functioncall -> ID LPAREN CTEF RPAREN .

    STAR            reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    SLASH           reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    PLUS            reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    MINUS           reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    LESSTHAN        reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    GREATERTHAN     reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    BETWEEN         reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    RPAREN          reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    DOT             reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    SEMIC           reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    ID              reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    IF              reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    PRINT           reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    MIN             reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    MAX             reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    RETURN          reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    FOR             reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    RCURLY          reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    ELSE            reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)
    RBRACKET        reduce using rule 9 (functioncall -> ID LPAREN CTEF RPAREN .)


state 158

    (8) functioncall -> ID LPAREN CTEI RPAREN .

    STAR            reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    SLASH           reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    PLUS            reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    MINUS           reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    LESSTHAN        reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    GREATERTHAN     reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    BETWEEN         reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    RPAREN          reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    DOT             reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    SEMIC           reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    ID              reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    IF              reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    PRINT           reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    MIN             reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    MAX             reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    RETURN          reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    FOR             reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    RCURLY          reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    ELSE            reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)
    RBRACKET        reduce using rule 8 (functioncall -> ID LPAREN CTEI RPAREN .)


state 159

    (20) for -> FOR ID IN DOT ID LBRACKET . statement RBRACKET
    (47) statement -> . asign
    (48) statement -> . condition
    (49) statement -> . write
    (50) statement -> . optimize
    (51) statement -> . loop
    (52) statement -> . return
    (46) asign -> . ID EQUALS expresion SEMIC
    (32) condition -> . IF LPAREN expresion RPAREN block SEMIC
    (33) condition -> . IF LPAREN expresion RPAREN block ELSE block SEMIC
    (41) write -> . PRINT LPAREN write2 RPAREN SEMIC
    (15) optimize -> . MIN EQUALS restrictions
    (16) optimize -> . MAX EQUALS restrictions
    (53) loop -> . for
    (54) return -> . RETURN asign
    (20) for -> . FOR ID IN DOT ID LBRACKET statement RBRACKET

    ID              shift and go to state 49
    IF              shift and go to state 51
    PRINT           shift and go to state 41
    MIN             shift and go to state 40
    MAX             shift and go to state 52
    RETURN          shift and go to state 38
    FOR             shift and go to state 48

    return                         shift and go to state 47
    for                            shift and go to state 42
    asign                          shift and go to state 53
    write                          shift and go to state 44
    condition                      shift and go to state 50
    statement                      shift and go to state 165
    optimize                       shift and go to state 43
    loop                           shift and go to state 54

state 160

    (61) block -> LCURLY RCURLY .

    SEMIC           reduce using rule 61 (block -> LCURLY RCURLY .)
    ELSE            reduce using rule 61 (block -> LCURLY RCURLY .)


state 161

    (32) condition -> IF LPAREN expresion RPAREN block SEMIC .

    ID              reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)
    IF              reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)
    PRINT           reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)
    MIN             reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)
    MAX             reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)
    RETURN          reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)
    FOR             reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)
    RCURLY          reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)
    SEMIC           reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)
    ELSE            reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)
    RBRACKET        reduce using rule 32 (condition -> IF LPAREN expresion RPAREN block SEMIC .)


state 162

    (33) condition -> IF LPAREN expresion RPAREN block ELSE . block SEMIC
    (60) block -> . block2
    (61) block -> . LCURLY RCURLY
    (62) block2 -> . statement block2
    (63) block2 -> . statement
    (64) block2 -> . empty
    (47) statement -> . asign
    (48) statement -> . condition
    (49) statement -> . write
    (50) statement -> . optimize
    (51) statement -> . loop
    (52) statement -> . return
    (88) empty -> .
    (46) asign -> . ID EQUALS expresion SEMIC
    (32) condition -> . IF LPAREN expresion RPAREN block SEMIC
    (33) condition -> . IF LPAREN expresion RPAREN block ELSE block SEMIC
    (41) write -> . PRINT LPAREN write2 RPAREN SEMIC
    (15) optimize -> . MIN EQUALS restrictions
    (16) optimize -> . MAX EQUALS restrictions
    (53) loop -> . for
    (54) return -> . RETURN asign
    (20) for -> . FOR ID IN DOT ID LBRACKET statement RBRACKET

    LCURLY          shift and go to state 150
    SEMIC           reduce using rule 88 (empty -> .)
    ID              shift and go to state 49
    IF              shift and go to state 51
    PRINT           shift and go to state 41
    MIN             shift and go to state 40
    MAX             shift and go to state 52
    RETURN          shift and go to state 38
    FOR             shift and go to state 48

    return                         shift and go to state 47
    block2                         shift and go to state 149
    for                            shift and go to state 42
    condition                      shift and go to state 50
    asign                          shift and go to state 53
    write                          shift and go to state 44
    block                          shift and go to state 166
    statement                      shift and go to state 45
    loop                           shift and go to state 54
    optimize                       shift and go to state 43
    empty                          shift and go to state 46

state 163

    (24) sum -> SUM LPAREN ID POINTS . expresion RPAREN
    (34) expresion -> . exp
    (35) expresion -> . exp LESSTHAN exp
    (36) expresion -> . exp GREATERTHAN exp
    (37) expresion -> . exp BETWEEN exp
    (38) exp -> . term
    (39) exp -> . term PLUS exp
    (40) exp -> . term MINUS exp
    (29) term -> . factor
    (30) term -> . factor STAR term
    (31) term -> . factor SLASH term
    (25) factor -> . PLUS constant
    (26) factor -> . MINUS constant
    (27) factor -> . constant
    (28) factor -> . LPAREN expresion RPAREN
    (1) constant -> . CTEI
    (2) constant -> . CTEF
    (3) constant -> . CTESTRING
    (4) constant -> . CTEBOOL
    (5) constant -> . ID
    (6) constant -> . functioncall
    (7) functioncall -> . ID LPAREN expresion RPAREN
    (8) functioncall -> . ID LPAREN CTEI RPAREN
    (9) functioncall -> . ID LPAREN CTEF RPAREN

    PLUS            shift and go to state 85
    MINUS           shift and go to state 84
    LPAREN          shift and go to state 82
    CTEI            shift and go to state 96
    CTEF            shift and go to state 94
    CTESTRING       shift and go to state 99
    CTEBOOL         shift and go to state 92
    ID              shift and go to state 89

    expresion                      shift and go to state 167
    term                           shift and go to state 91
    constant                       shift and go to state 88
    functioncall                   shift and go to state 87
    exp                            shift and go to state 95
    factor                         shift and go to state 86

state 164

    (21) forlist -> for SEMIC . lfor
    (22) lfor -> . empty
    (23) lfor -> . forlist
    (88) empty -> .
    (21) forlist -> . for SEMIC lfor
    (20) for -> . FOR ID IN DOT ID LBRACKET statement RBRACKET

  ! shift/reduce conflict for FOR resolved as shift
    ID              reduce using rule 88 (empty -> .)
    IF              reduce using rule 88 (empty -> .)
    PRINT           reduce using rule 88 (empty -> .)
    MIN             reduce using rule 88 (empty -> .)
    MAX             reduce using rule 88 (empty -> .)
    RETURN          reduce using rule 88 (empty -> .)
    RCURLY          reduce using rule 88 (empty -> .)
    SEMIC           reduce using rule 88 (empty -> .)
    ELSE            reduce using rule 88 (empty -> .)
    RBRACKET        reduce using rule 88 (empty -> .)
    FOR             shift and go to state 48

  ! FOR             [ reduce using rule 88 (empty -> .) ]

    forlist                        shift and go to state 168
    empty                          shift and go to state 170
    lfor                           shift and go to state 169
    for                            shift and go to state 154

state 165

    (20) for -> FOR ID IN DOT ID LBRACKET statement . RBRACKET

    RBRACKET        shift and go to state 171


state 166

    (33) condition -> IF LPAREN expresion RPAREN block ELSE block . SEMIC

    SEMIC           shift and go to state 172


state 167

    (24) sum -> SUM LPAREN ID POINTS expresion . RPAREN

    RPAREN          shift and go to state 173


state 168

    (23) lfor -> forlist .

    ID              reduce using rule 23 (lfor -> forlist .)
    IF              reduce using rule 23 (lfor -> forlist .)
    PRINT           reduce using rule 23 (lfor -> forlist .)
    MIN             reduce using rule 23 (lfor -> forlist .)
    MAX             reduce using rule 23 (lfor -> forlist .)
    RETURN          reduce using rule 23 (lfor -> forlist .)
    FOR             reduce using rule 23 (lfor -> forlist .)
    RCURLY          reduce using rule 23 (lfor -> forlist .)
    SEMIC           reduce using rule 23 (lfor -> forlist .)
    ELSE            reduce using rule 23 (lfor -> forlist .)
    RBRACKET        reduce using rule 23 (lfor -> forlist .)


state 169

    (21) forlist -> for SEMIC lfor .

    ID              reduce using rule 21 (forlist -> for SEMIC lfor .)
    IF              reduce using rule 21 (forlist -> for SEMIC lfor .)
    PRINT           reduce using rule 21 (forlist -> for SEMIC lfor .)
    MIN             reduce using rule 21 (forlist -> for SEMIC lfor .)
    MAX             reduce using rule 21 (forlist -> for SEMIC lfor .)
    RETURN          reduce using rule 21 (forlist -> for SEMIC lfor .)
    FOR             reduce using rule 21 (forlist -> for SEMIC lfor .)
    RCURLY          reduce using rule 21 (forlist -> for SEMIC lfor .)
    SEMIC           reduce using rule 21 (forlist -> for SEMIC lfor .)
    ELSE            reduce using rule 21 (forlist -> for SEMIC lfor .)
    RBRACKET        reduce using rule 21 (forlist -> for SEMIC lfor .)


state 170

    (22) lfor -> empty .

    ID              reduce using rule 22 (lfor -> empty .)
    IF              reduce using rule 22 (lfor -> empty .)
    PRINT           reduce using rule 22 (lfor -> empty .)
    MIN             reduce using rule 22 (lfor -> empty .)
    MAX             reduce using rule 22 (lfor -> empty .)
    RETURN          reduce using rule 22 (lfor -> empty .)
    FOR             reduce using rule 22 (lfor -> empty .)
    RCURLY          reduce using rule 22 (lfor -> empty .)
    SEMIC           reduce using rule 22 (lfor -> empty .)
    ELSE            reduce using rule 22 (lfor -> empty .)
    RBRACKET        reduce using rule 22 (lfor -> empty .)


state 171

    (20) for -> FOR ID IN DOT ID LBRACKET statement RBRACKET .

    SEMIC           reduce using rule 20 (for -> FOR ID IN DOT ID LBRACKET statement RBRACKET .)
    ID              reduce using rule 20 (for -> FOR ID IN DOT ID LBRACKET statement RBRACKET .)
    IF              reduce using rule 20 (for -> FOR ID IN DOT ID LBRACKET statement RBRACKET .)
    PRINT           reduce using rule 20 (for -> FOR ID IN DOT ID LBRACKET statement RBRACKET .)
    MIN             reduce using rule 20 (for -> FOR ID IN DOT ID LBRACKET statement RBRACKET .)
    MAX             reduce using rule 20 (for -> FOR ID IN DOT ID LBRACKET statement RBRACKET .)
    RETURN          reduce using rule 20 (for -> FOR ID IN DOT ID LBRACKET statement RBRACKET .)
    FOR             reduce using rule 20 (for -> FOR ID IN DOT ID LBRACKET statement RBRACKET .)
    RCURLY          reduce using rule 20 (for -> FOR ID IN DOT ID LBRACKET statement RBRACKET .)
    ELSE            reduce using rule 20 (for -> FOR ID IN DOT ID LBRACKET statement RBRACKET .)
    RBRACKET        reduce using rule 20 (for -> FOR ID IN DOT ID LBRACKET statement RBRACKET .)


state 172

    (33) condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .

    ID              reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)
    IF              reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)
    PRINT           reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)
    MIN             reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)
    MAX             reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)
    RETURN          reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)
    FOR             reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)
    RCURLY          reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)
    SEMIC           reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)
    ELSE            reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)
    RBRACKET        reduce using rule 33 (condition -> IF LPAREN expresion RPAREN block ELSE block SEMIC .)


state 173

    (24) sum -> SUM LPAREN ID POINTS expresion RPAREN .

    SEMIC           reduce using rule 24 (sum -> SUM LPAREN ID POINTS expresion RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for DOT in state 83 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 139 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 140 resolved as shift
WARNING: shift/reduce conflict for FOR in state 164 resolved as shift
WARNING: reduce/reduce conflict in state 45 resolved using rule (block2 -> statement)
WARNING: rejected rule (empty -> <empty>) in state 45
WARNING: reduce/reduce conflict in state 83 resolved using rule (constant -> CTESTRING)
WARNING: rejected rule (write2 -> CTESTRING) in state 83
WARNING: Rule (write2 -> CTESTRING) is never reduced
